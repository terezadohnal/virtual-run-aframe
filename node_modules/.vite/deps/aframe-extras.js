import {
  AmbientLight,
  AnimationClip,
  Bone,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  ClampToEdgeWrapping,
  Color,
  Curve,
  DirectionalLight,
  EquirectangularReflectionMapping,
  Euler,
  FileLoader,
  Float32BufferAttribute,
  Group,
  Line,
  LineBasicMaterial,
  Loader,
  LoaderUtils,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshPhongMaterial,
  NumberKeyframeTrack,
  Object3D,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PointLight,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  RepeatWrapping,
  SRGBColorSpace,
  ShapeUtils,
  Skeleton,
  SkinnedMesh,
  SphereGeometry,
  SpotLight,
  Texture,
  TextureLoader,
  Triangle,
  Uint16BufferAttribute,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack,
  init_three_module
} from "./chunk-RSPL47FG.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/aframe-extras/src/controls/checkpoint-controls.js
var require_checkpoint_controls = __commonJS({
  "node_modules/aframe-extras/src/controls/checkpoint-controls.js"(exports, module) {
    var EPS = 0.1;
    module.exports = AFRAME.registerComponent("checkpoint-controls", {
      schema: {
        enabled: { default: true },
        mode: { default: "teleport", oneOf: ["teleport", "animate"] },
        animateSpeed: { default: 3 }
      },
      init: function() {
        this.active = true;
        this.checkpoint = null;
        this.isNavMeshConstrained = false;
        this.offset = new THREE.Vector3();
        this.position = new THREE.Vector3();
        this.targetPosition = new THREE.Vector3();
      },
      play: function() {
        this.active = true;
      },
      pause: function() {
        this.active = false;
      },
      setCheckpoint: function(checkpoint) {
        const el = this.el;
        if (!this.active) return;
        if (this.checkpoint === checkpoint) return;
        if (this.checkpoint) {
          el.emit("navigation-end", { checkpoint: this.checkpoint });
        }
        this.checkpoint = checkpoint;
        this.sync();
        if (this.position.distanceTo(this.targetPosition) < EPS) {
          this.checkpoint = null;
          return;
        }
        el.emit("navigation-start", { checkpoint });
        if (this.data.mode === "teleport") {
          this.el.setAttribute("position", this.targetPosition);
          this.checkpoint = null;
          el.emit("navigation-end", { checkpoint });
          el.components["movement-controls"].updateNavLocation();
        }
      },
      isVelocityActive: function() {
        return !!(this.active && this.checkpoint);
      },
      getVelocity: function() {
        if (!this.active) return;
        const data = this.data;
        const offset = this.offset;
        const position = this.position;
        const targetPosition = this.targetPosition;
        const checkpoint = this.checkpoint;
        this.sync();
        if (position.distanceTo(targetPosition) < EPS) {
          this.checkpoint = null;
          this.el.emit("navigation-end", { checkpoint });
          return offset.set(0, 0, 0);
        }
        offset.setLength(data.animateSpeed);
        return offset;
      },
      sync: function() {
        const offset = this.offset;
        const position = this.position;
        const targetPosition = this.targetPosition;
        position.copy(this.el.getAttribute("position"));
        this.checkpoint.object3D.getWorldPosition(targetPosition);
        targetPosition.add(this.checkpoint.components.checkpoint.getOffset());
        offset.copy(targetPosition).sub(position);
      }
    });
  }
});

// node_modules/aframe-extras/lib/GamepadButton.js
var require_GamepadButton = __commonJS({
  "node_modules/aframe-extras/lib/GamepadButton.js"(exports, module) {
    module.exports = Object.assign(function GamepadButton() {
    }, {
      FACE_1: 0,
      FACE_2: 1,
      FACE_3: 2,
      FACE_4: 3,
      L_SHOULDER_1: 4,
      R_SHOULDER_1: 5,
      L_SHOULDER_2: 6,
      R_SHOULDER_2: 7,
      SELECT: 8,
      START: 9,
      DPAD_UP: 12,
      DPAD_DOWN: 13,
      DPAD_LEFT: 14,
      DPAD_RIGHT: 15,
      VENDOR: 16
    });
  }
});

// node_modules/aframe-extras/lib/GamepadButtonEvent.js
var require_GamepadButtonEvent = __commonJS({
  "node_modules/aframe-extras/lib/GamepadButtonEvent.js"(exports, module) {
    function GamepadButtonEvent(type, index, details) {
      this.type = type;
      this.index = index;
      this.pressed = details.pressed;
      this.value = details.value;
    }
    module.exports = GamepadButtonEvent;
  }
});

// node_modules/aframe-extras/src/controls/gamepad-controls.js
var require_gamepad_controls = __commonJS({
  "node_modules/aframe-extras/src/controls/gamepad-controls.js"(exports, module) {
    var GamepadButton = require_GamepadButton();
    var GamepadButtonEvent = require_GamepadButtonEvent();
    var JOYSTICK_EPS = 0.2;
    var Hand = {
      LEFT: "left",
      RIGHT: "right"
    };
    var Joystick = {
      MOVEMENT: 1,
      ROTATION: 2
    };
    module.exports = AFRAME.registerComponent("gamepad-controls", {
      /*******************************************************************
       * Statics
       */
      GamepadButton,
      /*******************************************************************
       * Schema
       */
      schema: {
        // Enable/disable gamepad-controls
        enabled: { default: true },
        // Rotation sensitivity
        rotationSensitivity: { default: 2 }
      },
      /*******************************************************************
       * Core
       */
      /**
       * Called once when component is attached. Generally for initial setup.
       */
      init: function() {
        const sceneEl = this.el.sceneEl;
        this.system = sceneEl.systems["tracked-controls-webxr"] || { controllers: [] };
        this.prevTime = window.performance.now();
        this.buttons = {};
        const rotation = this.el.object3D.rotation;
        this.pitch = new THREE.Object3D();
        this.pitch.rotation.x = rotation.x;
        this.yaw = new THREE.Object3D();
        this.yaw.position.y = 10;
        this.yaw.rotation.y = rotation.y;
        this.yaw.add(this.pitch);
        this._lookVector = new THREE.Vector2();
        this._moveVector = new THREE.Vector2();
        this._dpadVector = new THREE.Vector2();
        sceneEl.addBehavior(this);
      },
      /**
       * Called when component is attached and when component data changes.
       * Generally modifies the entity based on the data.
       */
      update: function() {
        this.tick();
      },
      /**
       * Called on each iteration of main render loop.
       */
      tick: function(t, dt) {
        this.updateButtonState();
        this.updateRotation(dt);
      },
      /**
       * Called when a component is removed (e.g., via removeAttribute).
       * Generally undoes all modifications to the entity.
       */
      remove: function() {
      },
      /*******************************************************************
       * Movement
       */
      isVelocityActive: function() {
        if (!this.data.enabled || !this.isConnected()) return false;
        const dpad = this._dpadVector;
        const joystick = this._moveVector;
        this.getDpad(dpad);
        this.getJoystick(Joystick.MOVEMENT, joystick);
        const inputX = dpad.x || joystick.x;
        const inputY = dpad.y || joystick.y;
        return Math.abs(inputX) > JOYSTICK_EPS || Math.abs(inputY) > JOYSTICK_EPS;
      },
      getVelocityDelta: function() {
        const dpad = this._dpadVector;
        const joystick = this._moveVector;
        this.getDpad(dpad);
        this.getJoystick(Joystick.MOVEMENT, joystick);
        const inputX = dpad.x || joystick.x;
        const inputY = dpad.y || joystick.y;
        const dVelocity = new THREE.Vector3();
        if (Math.abs(inputX) > JOYSTICK_EPS) {
          dVelocity.x += inputX;
        }
        if (Math.abs(inputY) > JOYSTICK_EPS) {
          dVelocity.z += inputY;
        }
        return dVelocity;
      },
      /*******************************************************************
       * Rotation
       */
      isRotationActive: function() {
        if (!this.data.enabled || !this.isConnected()) return false;
        const joystick = this._lookVector;
        this.getJoystick(Joystick.ROTATION, joystick);
        return Math.abs(joystick.x) > JOYSTICK_EPS || Math.abs(joystick.y) > JOYSTICK_EPS;
      },
      updateRotation: function(dt) {
        if (!this.isRotationActive()) return;
        const data = this.data;
        const yaw = this.yaw;
        const pitch = this.pitch;
        yaw.rotation.y = this.el.object3D.rotation.y;
        pitch.rotation.x = this.el.object3D.rotation.x;
        const lookVector = this._lookVector;
        this.getJoystick(Joystick.ROTATION, lookVector);
        if (Math.abs(lookVector.x) <= JOYSTICK_EPS) lookVector.x = 0;
        if (Math.abs(lookVector.y) <= JOYSTICK_EPS) lookVector.y = 0;
        lookVector.multiplyScalar(data.rotationSensitivity * dt / 1e3);
        yaw.rotation.y -= lookVector.x;
        pitch.rotation.x -= lookVector.y;
        pitch.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch.rotation.x));
        this.el.object3D.rotation.set(pitch.rotation.x, yaw.rotation.y, 0);
      },
      /*******************************************************************
       * Button events
       */
      updateButtonState: function() {
        const gamepad = this.getGamepad(Hand.RIGHT);
        if (this.data.enabled && gamepad) {
          for (var i = 0; i < gamepad.buttons.length; i++) {
            if (gamepad.buttons[i].pressed && !this.buttons[i]) {
              this.emit(new GamepadButtonEvent("gamepadbuttondown", i, gamepad.buttons[i]));
            } else if (!gamepad.buttons[i].pressed && this.buttons[i]) {
              this.emit(new GamepadButtonEvent("gamepadbuttonup", i, gamepad.buttons[i]));
            }
            this.buttons[i] = gamepad.buttons[i].pressed;
          }
        } else if (Object.keys(this.buttons)) {
          this.buttons = {};
        }
      },
      emit: function(event) {
        this.el.emit(event.type, event);
        this.el.emit(
          event.type + ":" + event.index,
          new GamepadButtonEvent(event.type, event.index, event)
        );
      },
      /*******************************************************************
       * Gamepad state
       */
      /**
       * Returns the Gamepad instance attached to the component. If connected,
       * a proxy-controls component may provide access to Gamepad input from a
       * remote device.
       *
       * @param {string} handPreference
       * @return {Gamepad}
       */
      getGamepad: /* @__PURE__ */ function() {
        const _xrGamepads = [];
        const _empty = [];
        return function(handPreference) {
          const proxyControls = this.el.sceneEl.components["proxy-controls"];
          const proxyGamepad = proxyControls && proxyControls.isConnected() && proxyControls.getGamepad(0);
          if (proxyGamepad) return proxyGamepad;
          _xrGamepads.length = 0;
          for (let i = 0; i < this.system.controllers.length; i++) {
            const xrController = this.system.controllers[i];
            const xrGamepad = xrController ? xrController.gamepad : null;
            _xrGamepads.push(xrGamepad);
            if (xrGamepad && xrController.handedness === handPreference) return xrGamepad;
          }
          const navGamepads = navigator.getGamepads ? navigator.getGamepads() : _empty;
          for (let i = 0; i < navGamepads.length; i++) {
            const navGamepad = navGamepads[i];
            if (navGamepad && navGamepad.hand === handPreference) return navGamepad;
          }
          return _xrGamepads[0] || navGamepads[0];
        };
      }(),
      /**
       * Returns the state of the given button.
       * @param  {number} index The button (0-N) for which to find state.
       * @return {GamepadButton}
       */
      getButton: function(index) {
        return this.getGamepad(Hand.RIGHT).buttons[index];
      },
      /**
       * Returns state of the given axis. Axes are labelled 0-N, where 0-1 will
       * represent X/Y on the first joystick, and 2-3 X/Y on the second.
       * @param  {number} index The axis (0-N) for which to find state.
       * @return {number} On the interval [-1,1].
       */
      getAxis: function(index) {
        return this.getGamepad(index > 1 ? Hand.RIGHT : Hand.LEFT).axes[index];
      },
      /**
       * Returns the state of the specified joystick as a THREE.Vector2.
       * @param  {Joystick} role
       * @param  {THREE.Vector2} target
       * @return {THREE.Vector2}
       */
      getJoystick: function(index, target) {
        const gamepad = this.getGamepad(index === Joystick.MOVEMENT ? Hand.LEFT : Hand.RIGHT);
        if (!gamepad) {
          return target.set(0, 0);
        }
        if (gamepad.mapping === "xr-standard") {
          switch (index) {
            case Joystick.MOVEMENT:
              return target.set(gamepad.axes[2], gamepad.axes[3]);
            case Joystick.ROTATION:
              return target.set(gamepad.axes[2], 0);
          }
        } else {
          switch (index) {
            case Joystick.MOVEMENT:
              return target.set(gamepad.axes[0], gamepad.axes[1]);
            case Joystick.ROTATION:
              return target.set(gamepad.axes[2], gamepad.axes[3]);
          }
        }
        throw new Error('Unexpected joystick index "%d".', index);
      },
      /**
       * Returns the state of the dpad as a THREE.Vector2.
       * @param {THREE.Vector2} target
       * @return {THREE.Vector2}
       */
      getDpad: function(target) {
        const gamepad = this.getGamepad(Hand.LEFT);
        if (!gamepad) {
          return target.set(0, 0);
        }
        if (!gamepad.buttons[GamepadButton.DPAD_RIGHT]) {
          return target.set(0, 0);
        }
        return target.set(
          (gamepad.buttons[GamepadButton.DPAD_RIGHT].pressed ? 1 : 0) + (gamepad.buttons[GamepadButton.DPAD_LEFT].pressed ? -1 : 0),
          (gamepad.buttons[GamepadButton.DPAD_UP].pressed ? -1 : 0) + (gamepad.buttons[GamepadButton.DPAD_DOWN].pressed ? 1 : 0)
        );
      },
      /**
       * Returns true if the gamepad is currently connected to the system.
       * @return {boolean}
       */
      isConnected: function() {
        const gamepad = this.getGamepad(Hand.LEFT);
        return !!(gamepad && gamepad.connected);
      },
      /**
       * Returns a string containing some information about the controller. Result
       * may vary across browsers, for a given controller.
       * @return {string}
       */
      getID: function() {
        return this.getGamepad(Hand.LEFT).id;
      }
    });
  }
});

// node_modules/aframe-extras/lib/keyboard.polyfill.js
var require_keyboard_polyfill = __commonJS({
  "node_modules/aframe-extras/lib/keyboard.polyfill.js"() {
    (function(global) {
      var nativeKeyboardEvent = "KeyboardEvent" in global;
      if (!nativeKeyboardEvent)
        global.KeyboardEvent = function KeyboardEvent2() {
          throw TypeError("Illegal constructor");
        };
      if (!("DOM_KEY_LOCATION_STANDARD" in global.KeyboardEvent)) global.KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0;
      if (!("DOM_KEY_LOCATION_LEFT" in global.KeyboardEvent)) global.KeyboardEvent.DOM_KEY_LOCATION_LEFT = 1;
      if (!("DOM_KEY_LOCATION_RIGHT" in global.KeyboardEvent)) global.KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 2;
      if (!("DOM_KEY_LOCATION_NUMPAD" in global.KeyboardEvent)) global.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 3;
      var STANDARD = window.KeyboardEvent.DOM_KEY_LOCATION_STANDARD, LEFT = window.KeyboardEvent.DOM_KEY_LOCATION_LEFT, RIGHT = window.KeyboardEvent.DOM_KEY_LOCATION_RIGHT, NUMPAD = window.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD;
      function contains(s, ss) {
        return String(s).indexOf(ss) !== -1;
      }
      var os = function() {
        if (contains(navigator.platform, "Win")) {
          return "win";
        }
        if (contains(navigator.platform, "Mac")) {
          return "mac";
        }
        if (contains(navigator.platform, "CrOS")) {
          return "cros";
        }
        if (contains(navigator.platform, "Linux")) {
          return "linux";
        }
        if (contains(navigator.userAgent, "iPad") || contains(navigator.platform, "iPod") || contains(navigator.platform, "iPhone")) {
          return "ios";
        }
        return "";
      }();
      var browser = function() {
        if (contains(navigator.userAgent, "Chrome/")) {
          return "chrome";
        }
        if (contains(navigator.vendor, "Apple")) {
          return "safari";
        }
        if (contains(navigator.userAgent, "MSIE")) {
          return "ie";
        }
        if (contains(navigator.userAgent, "Gecko/")) {
          return "moz";
        }
        if (contains(navigator.userAgent, "Opera/")) {
          return "opera";
        }
        return "";
      }();
      var browser_os = browser + "-" + os;
      function mergeIf(baseTable, select, table) {
        if (browser_os === select || browser === select || os === select) {
          Object.keys(table).forEach(function(keyCode) {
            baseTable[keyCode] = table[keyCode];
          });
        }
      }
      function remap(o, key) {
        var r = {};
        Object.keys(o).forEach(function(k) {
          var item = o[k];
          if (key in item) {
            r[item[key]] = item;
          }
        });
        return r;
      }
      function invert(o) {
        var r = {};
        Object.keys(o).forEach(function(k) {
          r[o[k]] = k;
        });
        return r;
      }
      var keyCodeToInfoTable = {
        // 0x01 - VK_LBUTTON
        // 0x02 - VK_RBUTTON
        3: { code: "Cancel" },
        // [USB: 0x9b] char \x0018 ??? (Not in D3E)
        // 0x04 - VK_MBUTTON
        // 0x05 - VK_XBUTTON1
        // 0x06 - VK_XBUTTON2
        6: { code: "Help" },
        // [USB: 0x75] ???
        // 0x07 - undefined
        8: { code: "Backspace" },
        // [USB: 0x2a] Labelled Delete on Macintosh keyboards.
        9: { code: "Tab" },
        // [USB: 0x2b]
        // 0x0A-0x0B - reserved
        12: { code: "Clear" },
        // [USB: 0x9c] NumPad Center (Not in D3E)
        13: { code: "Enter" },
        // [USB: 0x28]
        // 0x0E-0x0F - undefined
        16: { code: "Shift" },
        17: { code: "Control" },
        18: { code: "Alt" },
        19: { code: "Pause" },
        // [USB: 0x48]
        20: { code: "CapsLock" },
        // [USB: 0x39]
        21: { code: "KanaMode" },
        // [USB: 0x88] - "HangulMode" for Korean layout
        22: { code: "HangulMode" },
        // [USB: 0x90] 0x15 as well in MSDN VK table ???
        23: { code: "JunjaMode" },
        // (Not in D3E)
        24: { code: "FinalMode" },
        // (Not in D3E)
        25: { code: "KanjiMode" },
        // [USB: 0x91] - "HanjaMode" for Korean layout
        // 0x1A - undefined
        27: { code: "Escape" },
        // [USB: 0x29]
        28: { code: "Convert" },
        // [USB: 0x8a]
        29: { code: "NonConvert" },
        // [USB: 0x8b]
        30: { code: "Accept" },
        // (Not in D3E)
        31: { code: "ModeChange" },
        // (Not in D3E)
        32: { code: "Space" },
        // [USB: 0x2c]
        33: { code: "PageUp" },
        // [USB: 0x4b]
        34: { code: "PageDown" },
        // [USB: 0x4e]
        35: { code: "End" },
        // [USB: 0x4d]
        36: { code: "Home" },
        // [USB: 0x4a]
        37: { code: "ArrowLeft" },
        // [USB: 0x50]
        38: { code: "ArrowUp" },
        // [USB: 0x52]
        39: { code: "ArrowRight" },
        // [USB: 0x4f]
        40: { code: "ArrowDown" },
        // [USB: 0x51]
        41: { code: "Select" },
        // (Not in D3E)
        42: { code: "Print" },
        // (Not in D3E)
        43: { code: "Execute" },
        // [USB: 0x74] (Not in D3E)
        44: { code: "PrintScreen" },
        // [USB: 0x46]
        45: { code: "Insert" },
        // [USB: 0x49]
        46: { code: "Delete" },
        // [USB: 0x4c]
        47: { code: "Help" },
        // [USB: 0x75] ???
        48: { code: "Digit0", keyCap: "0" },
        // [USB: 0x27] 0)
        49: { code: "Digit1", keyCap: "1" },
        // [USB: 0x1e] 1!
        50: { code: "Digit2", keyCap: "2" },
        // [USB: 0x1f] 2@
        51: { code: "Digit3", keyCap: "3" },
        // [USB: 0x20] 3#
        52: { code: "Digit4", keyCap: "4" },
        // [USB: 0x21] 4$
        53: { code: "Digit5", keyCap: "5" },
        // [USB: 0x22] 5%
        54: { code: "Digit6", keyCap: "6" },
        // [USB: 0x23] 6^
        55: { code: "Digit7", keyCap: "7" },
        // [USB: 0x24] 7&
        56: { code: "Digit8", keyCap: "8" },
        // [USB: 0x25] 8*
        57: { code: "Digit9", keyCap: "9" },
        // [USB: 0x26] 9(
        // 0x3A-0x40 - undefined
        65: { code: "KeyA", keyCap: "a" },
        // [USB: 0x04]
        66: { code: "KeyB", keyCap: "b" },
        // [USB: 0x05]
        67: { code: "KeyC", keyCap: "c" },
        // [USB: 0x06]
        68: { code: "KeyD", keyCap: "d" },
        // [USB: 0x07]
        69: { code: "KeyE", keyCap: "e" },
        // [USB: 0x08]
        70: { code: "KeyF", keyCap: "f" },
        // [USB: 0x09]
        71: { code: "KeyG", keyCap: "g" },
        // [USB: 0x0a]
        72: { code: "KeyH", keyCap: "h" },
        // [USB: 0x0b]
        73: { code: "KeyI", keyCap: "i" },
        // [USB: 0x0c]
        74: { code: "KeyJ", keyCap: "j" },
        // [USB: 0x0d]
        75: { code: "KeyK", keyCap: "k" },
        // [USB: 0x0e]
        76: { code: "KeyL", keyCap: "l" },
        // [USB: 0x0f]
        77: { code: "KeyM", keyCap: "m" },
        // [USB: 0x10]
        78: { code: "KeyN", keyCap: "n" },
        // [USB: 0x11]
        79: { code: "KeyO", keyCap: "o" },
        // [USB: 0x12]
        80: { code: "KeyP", keyCap: "p" },
        // [USB: 0x13]
        81: { code: "KeyQ", keyCap: "q" },
        // [USB: 0x14]
        82: { code: "KeyR", keyCap: "r" },
        // [USB: 0x15]
        83: { code: "KeyS", keyCap: "s" },
        // [USB: 0x16]
        84: { code: "KeyT", keyCap: "t" },
        // [USB: 0x17]
        85: { code: "KeyU", keyCap: "u" },
        // [USB: 0x18]
        86: { code: "KeyV", keyCap: "v" },
        // [USB: 0x19]
        87: { code: "KeyW", keyCap: "w" },
        // [USB: 0x1a]
        88: { code: "KeyX", keyCap: "x" },
        // [USB: 0x1b]
        89: { code: "KeyY", keyCap: "y" },
        // [USB: 0x1c]
        90: { code: "KeyZ", keyCap: "z" },
        // [USB: 0x1d]
        91: { code: "OSLeft", location: LEFT },
        // [USB: 0xe3]
        92: { code: "OSRight", location: RIGHT },
        // [USB: 0xe7]
        93: { code: "ContextMenu" },
        // [USB: 0x65] Context Menu
        // 0x5E - reserved
        95: { code: "Standby" },
        // [USB: 0x82] Sleep
        96: { code: "Numpad0", keyCap: "0", location: NUMPAD },
        // [USB: 0x62]
        97: { code: "Numpad1", keyCap: "1", location: NUMPAD },
        // [USB: 0x59]
        98: { code: "Numpad2", keyCap: "2", location: NUMPAD },
        // [USB: 0x5a]
        99: { code: "Numpad3", keyCap: "3", location: NUMPAD },
        // [USB: 0x5b]
        100: { code: "Numpad4", keyCap: "4", location: NUMPAD },
        // [USB: 0x5c]
        101: { code: "Numpad5", keyCap: "5", location: NUMPAD },
        // [USB: 0x5d]
        102: { code: "Numpad6", keyCap: "6", location: NUMPAD },
        // [USB: 0x5e]
        103: { code: "Numpad7", keyCap: "7", location: NUMPAD },
        // [USB: 0x5f]
        104: { code: "Numpad8", keyCap: "8", location: NUMPAD },
        // [USB: 0x60]
        105: { code: "Numpad9", keyCap: "9", location: NUMPAD },
        // [USB: 0x61]
        106: { code: "NumpadMultiply", keyCap: "*", location: NUMPAD },
        // [USB: 0x55]
        107: { code: "NumpadAdd", keyCap: "+", location: NUMPAD },
        // [USB: 0x57]
        108: { code: "NumpadComma", keyCap: ",", location: NUMPAD },
        // [USB: 0x85]
        109: { code: "NumpadSubtract", keyCap: "-", location: NUMPAD },
        // [USB: 0x56]
        110: { code: "NumpadDecimal", keyCap: ".", location: NUMPAD },
        // [USB: 0x63]
        111: { code: "NumpadDivide", keyCap: "/", location: NUMPAD },
        // [USB: 0x54]
        112: { code: "F1" },
        // [USB: 0x3a]
        113: { code: "F2" },
        // [USB: 0x3b]
        114: { code: "F3" },
        // [USB: 0x3c]
        115: { code: "F4" },
        // [USB: 0x3d]
        116: { code: "F5" },
        // [USB: 0x3e]
        117: { code: "F6" },
        // [USB: 0x3f]
        118: { code: "F7" },
        // [USB: 0x40]
        119: { code: "F8" },
        // [USB: 0x41]
        120: { code: "F9" },
        // [USB: 0x42]
        121: { code: "F10" },
        // [USB: 0x43]
        122: { code: "F11" },
        // [USB: 0x44]
        123: { code: "F12" },
        // [USB: 0x45]
        124: { code: "F13" },
        // [USB: 0x68]
        125: { code: "F14" },
        // [USB: 0x69]
        126: { code: "F15" },
        // [USB: 0x6a]
        127: { code: "F16" },
        // [USB: 0x6b]
        128: { code: "F17" },
        // [USB: 0x6c]
        129: { code: "F18" },
        // [USB: 0x6d]
        130: { code: "F19" },
        // [USB: 0x6e]
        131: { code: "F20" },
        // [USB: 0x6f]
        132: { code: "F21" },
        // [USB: 0x70]
        133: { code: "F22" },
        // [USB: 0x71]
        134: { code: "F23" },
        // [USB: 0x72]
        135: { code: "F24" },
        // [USB: 0x73]
        // 0x88-0x8F - unassigned
        144: { code: "NumLock", location: NUMPAD },
        // [USB: 0x53]
        145: { code: "ScrollLock" },
        // [USB: 0x47]
        // 0x92-0x96 - OEM specific
        // 0x97-0x9F - unassigned
        // NOTE: 0xA0-0xA5 usually mapped to 0x10-0x12 in browsers
        160: { code: "ShiftLeft", location: LEFT },
        // [USB: 0xe1]
        161: { code: "ShiftRight", location: RIGHT },
        // [USB: 0xe5]
        162: { code: "ControlLeft", location: LEFT },
        // [USB: 0xe0]
        163: { code: "ControlRight", location: RIGHT },
        // [USB: 0xe4]
        164: { code: "AltLeft", location: LEFT },
        // [USB: 0xe2]
        165: { code: "AltRight", location: RIGHT },
        // [USB: 0xe6]
        166: { code: "BrowserBack" },
        // [USB: 0x0c/0x0224]
        167: { code: "BrowserForward" },
        // [USB: 0x0c/0x0225]
        168: { code: "BrowserRefresh" },
        // [USB: 0x0c/0x0227]
        169: { code: "BrowserStop" },
        // [USB: 0x0c/0x0226]
        170: { code: "BrowserSearch" },
        // [USB: 0x0c/0x0221]
        171: { code: "BrowserFavorites" },
        // [USB: 0x0c/0x0228]
        172: { code: "BrowserHome" },
        // [USB: 0x0c/0x0222]
        173: { code: "VolumeMute" },
        // [USB: 0x7f]
        174: { code: "VolumeDown" },
        // [USB: 0x81]
        175: { code: "VolumeUp" },
        // [USB: 0x80]
        176: { code: "MediaTrackNext" },
        // [USB: 0x0c/0x00b5]
        177: { code: "MediaTrackPrevious" },
        // [USB: 0x0c/0x00b6]
        178: { code: "MediaStop" },
        // [USB: 0x0c/0x00b7]
        179: { code: "MediaPlayPause" },
        // [USB: 0x0c/0x00cd]
        180: { code: "LaunchMail" },
        // [USB: 0x0c/0x018a]
        181: { code: "MediaSelect" },
        182: { code: "LaunchApp1" },
        183: { code: "LaunchApp2" },
        // 0xB8-0xB9 - reserved
        186: { code: "Semicolon", keyCap: ";" },
        // [USB: 0x33] ;: (US Standard 101)
        187: { code: "Equal", keyCap: "=" },
        // [USB: 0x2e] =+
        188: { code: "Comma", keyCap: "," },
        // [USB: 0x36] ,<
        189: { code: "Minus", keyCap: "-" },
        // [USB: 0x2d] -_
        190: { code: "Period", keyCap: "." },
        // [USB: 0x37] .>
        191: { code: "Slash", keyCap: "/" },
        // [USB: 0x38] /? (US Standard 101)
        192: { code: "Backquote", keyCap: "`" },
        // [USB: 0x35] `~ (US Standard 101)
        // 0xC1-0xCF - reserved
        // 0xD0-0xD7 - reserved
        // 0xD8-0xDA - unassigned
        219: { code: "BracketLeft", keyCap: "[" },
        // [USB: 0x2f] [{ (US Standard 101)
        220: { code: "Backslash", keyCap: "\\" },
        // [USB: 0x31] \| (US Standard 101)
        221: { code: "BracketRight", keyCap: "]" },
        // [USB: 0x30] ]} (US Standard 101)
        222: { code: "Quote", keyCap: "'" },
        // [USB: 0x34] '" (US Standard 101)
        // 0xDF - miscellaneous/varies
        // 0xE0 - reserved
        // 0xE1 - OEM specific
        226: { code: "IntlBackslash", keyCap: "\\" },
        // [USB: 0x64] \| (UK Standard 102)
        // 0xE3-0xE4 - OEM specific
        229: { code: "Process" },
        // (Not in D3E)
        // 0xE6 - OEM specific
        // 0xE7 - VK_PACKET
        // 0xE8 - unassigned
        // 0xE9-0xEF - OEM specific
        // 0xF0-0xF5 - OEM specific
        246: { code: "Attn" },
        // [USB: 0x9a] (Not in D3E)
        247: { code: "CrSel" },
        // [USB: 0xa3] (Not in D3E)
        248: { code: "ExSel" },
        // [USB: 0xa4] (Not in D3E)
        249: { code: "EraseEof" },
        // (Not in D3E)
        250: { code: "Play" },
        // (Not in D3E)
        251: { code: "ZoomToggle" },
        // (Not in D3E)
        // 0xFC - VK_NONAME - reserved
        // 0xFD - VK_PA1
        254: { code: "Clear" }
        // [USB: 0x9c] (Not in D3E)
      };
      mergeIf(
        keyCodeToInfoTable,
        "moz",
        {
          59: { code: "Semicolon", keyCap: ";" },
          // [USB: 0x33] ;: (US Standard 101)
          61: { code: "Equal", keyCap: "=" },
          // [USB: 0x2e] =+
          107: { code: "Equal", keyCap: "=" },
          // [USB: 0x2e] =+
          109: { code: "Minus", keyCap: "-" },
          // [USB: 0x2d] -_
          187: { code: "NumpadAdd", keyCap: "+", location: NUMPAD },
          // [USB: 0x57]
          189: { code: "NumpadSubtract", keyCap: "-", location: NUMPAD }
          // [USB: 0x56]
        }
      );
      mergeIf(
        keyCodeToInfoTable,
        "moz-mac",
        {
          12: { code: "NumLock", location: NUMPAD },
          // [USB: 0x53]
          173: { code: "Minus", keyCap: "-" }
          // [USB: 0x2d] -_
        }
      );
      mergeIf(
        keyCodeToInfoTable,
        "moz-win",
        {
          173: { code: "Minus", keyCap: "-" }
          // [USB: 0x2d] -_
        }
      );
      mergeIf(
        keyCodeToInfoTable,
        "chrome-mac",
        {
          93: { code: "OSRight", location: RIGHT }
          // [USB: 0xe7]
        }
      );
      if (0) {
        mergeIf(
          keyCodeToInfoTable,
          "chrome-win",
          {
            192: { code: "Quote", keyCap: "'" },
            // [USB: 0x34] '" (US Standard 101)
            222: { code: "Backslash", keyCap: "\\" },
            // [USB: 0x31] \| (US Standard 101)
            223: { code: "Backquote", keyCap: "`" }
            // [USB: 0x35] `~ (US Standard 101)
          }
        );
        mergeIf(
          keyCodeToInfoTable,
          "ie",
          {
            192: { code: "Quote", keyCap: "'" },
            // [USB: 0x34] '" (US Standard 101)
            222: { code: "Backslash", keyCap: "\\" },
            // [USB: 0x31] \| (US Standard 101)
            223: { code: "Backquote", keyCap: "`" }
            // [USB: 0x35] `~ (US Standard 101)
          }
        );
      }
      mergeIf(
        keyCodeToInfoTable,
        "safari",
        {
          3: { code: "Enter" },
          // [USB: 0x28] old Safari
          25: { code: "Tab" }
          // [USB: 0x2b] old Safari for Shift+Tab
        }
      );
      mergeIf(
        keyCodeToInfoTable,
        "ios",
        {
          10: { code: "Enter", location: STANDARD }
          // [USB: 0x28]
        }
      );
      mergeIf(
        keyCodeToInfoTable,
        "safari-mac",
        {
          91: { code: "OSLeft", location: LEFT },
          // [USB: 0xe3]
          93: { code: "OSRight", location: RIGHT },
          // [USB: 0xe7]
          229: { code: "KeyQ", keyCap: "Q" }
          // [USB: 0x14] On alternate presses, Ctrl+Q sends this
        }
      );
      var keyIdentifierTable = {};
      if ("cros" === os) {
        keyIdentifierTable["U+00A0"] = { code: "ShiftLeft", location: LEFT };
        keyIdentifierTable["U+00A1"] = { code: "ShiftRight", location: RIGHT };
        keyIdentifierTable["U+00A2"] = { code: "ControlLeft", location: LEFT };
        keyIdentifierTable["U+00A3"] = { code: "ControlRight", location: RIGHT };
        keyIdentifierTable["U+00A4"] = { code: "AltLeft", location: LEFT };
        keyIdentifierTable["U+00A5"] = { code: "AltRight", location: RIGHT };
      }
      if ("chrome-mac" === browser_os) {
        keyIdentifierTable["U+0010"] = { code: "ContextMenu" };
      }
      if ("safari-mac" === browser_os) {
        keyIdentifierTable["U+0010"] = { code: "ContextMenu" };
      }
      if ("ios" === os) {
        keyIdentifierTable["U+0010"] = { code: "Function" };
        keyIdentifierTable["U+001C"] = { code: "ArrowLeft" };
        keyIdentifierTable["U+001D"] = { code: "ArrowRight" };
        keyIdentifierTable["U+001E"] = { code: "ArrowUp" };
        keyIdentifierTable["U+001F"] = { code: "ArrowDown" };
        keyIdentifierTable["U+0001"] = { code: "Home" };
        keyIdentifierTable["U+0004"] = { code: "End" };
        keyIdentifierTable["U+000B"] = { code: "PageUp" };
        keyIdentifierTable["U+000C"] = { code: "PageDown" };
      }
      var locationTable = [];
      locationTable[LEFT] = {
        16: { code: "ShiftLeft", location: LEFT },
        // [USB: 0xe1]
        17: { code: "ControlLeft", location: LEFT },
        // [USB: 0xe0]
        18: { code: "AltLeft", location: LEFT }
        // [USB: 0xe2]
      };
      locationTable[RIGHT] = {
        16: { code: "ShiftRight", location: RIGHT },
        // [USB: 0xe5]
        17: { code: "ControlRight", location: RIGHT },
        // [USB: 0xe4]
        18: { code: "AltRight", location: RIGHT }
        // [USB: 0xe6]
      };
      locationTable[NUMPAD] = {
        13: { code: "NumpadEnter", location: NUMPAD }
        // [USB: 0x58]
      };
      mergeIf(locationTable[NUMPAD], "moz", {
        109: { code: "NumpadSubtract", location: NUMPAD },
        // [USB: 0x56]
        107: { code: "NumpadAdd", location: NUMPAD }
        // [USB: 0x57]
      });
      mergeIf(locationTable[LEFT], "moz-mac", {
        224: { code: "OSLeft", location: LEFT }
        // [USB: 0xe3]
      });
      mergeIf(locationTable[RIGHT], "moz-mac", {
        224: { code: "OSRight", location: RIGHT }
        // [USB: 0xe7]
      });
      mergeIf(locationTable[RIGHT], "moz-win", {
        91: { code: "OSRight", location: RIGHT }
        // [USB: 0xe7]
      });
      mergeIf(locationTable[RIGHT], "mac", {
        93: { code: "OSRight", location: RIGHT }
        // [USB: 0xe7]
      });
      mergeIf(locationTable[NUMPAD], "chrome-mac", {
        12: { code: "NumLock", location: NUMPAD }
        // [USB: 0x53]
      });
      mergeIf(locationTable[NUMPAD], "safari-mac", {
        12: { code: "NumLock", location: NUMPAD },
        // [USB: 0x53]
        187: { code: "NumpadAdd", location: NUMPAD },
        // [USB: 0x57]
        189: { code: "NumpadSubtract", location: NUMPAD },
        // [USB: 0x56]
        190: { code: "NumpadDecimal", location: NUMPAD },
        // [USB: 0x63]
        191: { code: "NumpadDivide", location: NUMPAD }
        // [USB: 0x54]
      });
      var codeToKeyTable = {
        // Modifier Keys
        ShiftLeft: { key: "Shift" },
        ShiftRight: { key: "Shift" },
        ControlLeft: { key: "Control" },
        ControlRight: { key: "Control" },
        AltLeft: { key: "Alt" },
        AltRight: { key: "Alt" },
        OSLeft: { key: "OS" },
        OSRight: { key: "OS" },
        // Whitespace Keys
        NumpadEnter: { key: "Enter" },
        Space: { key: " " },
        // Printable Keys
        Digit0: { key: "0", shiftKey: ")" },
        Digit1: { key: "1", shiftKey: "!" },
        Digit2: { key: "2", shiftKey: "@" },
        Digit3: { key: "3", shiftKey: "#" },
        Digit4: { key: "4", shiftKey: "$" },
        Digit5: { key: "5", shiftKey: "%" },
        Digit6: { key: "6", shiftKey: "^" },
        Digit7: { key: "7", shiftKey: "&" },
        Digit8: { key: "8", shiftKey: "*" },
        Digit9: { key: "9", shiftKey: "(" },
        KeyA: { key: "a", shiftKey: "A" },
        KeyB: { key: "b", shiftKey: "B" },
        KeyC: { key: "c", shiftKey: "C" },
        KeyD: { key: "d", shiftKey: "D" },
        KeyE: { key: "e", shiftKey: "E" },
        KeyF: { key: "f", shiftKey: "F" },
        KeyG: { key: "g", shiftKey: "G" },
        KeyH: { key: "h", shiftKey: "H" },
        KeyI: { key: "i", shiftKey: "I" },
        KeyJ: { key: "j", shiftKey: "J" },
        KeyK: { key: "k", shiftKey: "K" },
        KeyL: { key: "l", shiftKey: "L" },
        KeyM: { key: "m", shiftKey: "M" },
        KeyN: { key: "n", shiftKey: "N" },
        KeyO: { key: "o", shiftKey: "O" },
        KeyP: { key: "p", shiftKey: "P" },
        KeyQ: { key: "q", shiftKey: "Q" },
        KeyR: { key: "r", shiftKey: "R" },
        KeyS: { key: "s", shiftKey: "S" },
        KeyT: { key: "t", shiftKey: "T" },
        KeyU: { key: "u", shiftKey: "U" },
        KeyV: { key: "v", shiftKey: "V" },
        KeyW: { key: "w", shiftKey: "W" },
        KeyX: { key: "x", shiftKey: "X" },
        KeyY: { key: "y", shiftKey: "Y" },
        KeyZ: { key: "z", shiftKey: "Z" },
        Numpad0: { key: "0" },
        Numpad1: { key: "1" },
        Numpad2: { key: "2" },
        Numpad3: { key: "3" },
        Numpad4: { key: "4" },
        Numpad5: { key: "5" },
        Numpad6: { key: "6" },
        Numpad7: { key: "7" },
        Numpad8: { key: "8" },
        Numpad9: { key: "9" },
        NumpadMultiply: { key: "*" },
        NumpadAdd: { key: "+" },
        NumpadComma: { key: "," },
        NumpadSubtract: { key: "-" },
        NumpadDecimal: { key: "." },
        NumpadDivide: { key: "/" },
        Semicolon: { key: ";", shiftKey: ":" },
        Equal: { key: "=", shiftKey: "+" },
        Comma: { key: ",", shiftKey: "<" },
        Minus: { key: "-", shiftKey: "_" },
        Period: { key: ".", shiftKey: ">" },
        Slash: { key: "/", shiftKey: "?" },
        Backquote: { key: "`", shiftKey: "~" },
        BracketLeft: { key: "[", shiftKey: "{" },
        Backslash: { key: "\\", shiftKey: "|" },
        BracketRight: { key: "]", shiftKey: "}" },
        Quote: { key: "'", shiftKey: '"' },
        IntlBackslash: { key: "\\", shiftKey: "|" }
      };
      mergeIf(codeToKeyTable, "mac", {
        OSLeft: { key: "Meta" },
        OSRight: { key: "Meta" }
      });
      var keyFixTable = {
        Esc: "Escape",
        Nonconvert: "NonConvert",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Menu: "ContextMenu",
        MediaNextTrack: "MediaTrackNext",
        MediaPreviousTrack: "MediaTrackPrevious",
        SelectMedia: "MediaSelect",
        HalfWidth: "Hankaku",
        FullWidth: "Zenkaku",
        RomanCharacters: "Romaji",
        Crsel: "CrSel",
        Exsel: "ExSel",
        Zoom: "ZoomToggle"
      };
      var codeTable = remap(keyCodeToInfoTable, "code");
      try {
        var nativeLocation = nativeKeyboardEvent && "location" in new KeyboardEvent("");
      } catch (_) {
      }
      function keyInfoForEvent(event) {
        var keyCode = "keyCode" in event ? event.keyCode : "which" in event ? event.which : 0;
        var keyInfo = function() {
          if (nativeLocation || "keyLocation" in event) {
            var location = nativeLocation ? event.location : event.keyLocation;
            if (location && keyCode in locationTable[location]) {
              return locationTable[location][keyCode];
            }
          }
          if ("keyIdentifier" in event && event.keyIdentifier in keyIdentifierTable) {
            return keyIdentifierTable[event.keyIdentifier];
          }
          if (keyCode in keyCodeToInfoTable) {
            return keyCodeToInfoTable[keyCode];
          }
          return null;
        }();
        if (0) {
          switch (event.keyIdentifier) {
            case "U+0010":
              keyInfo = { code: "Function" };
              break;
            case "U+001C":
              keyInfo = { code: "ArrowLeft" };
              break;
            case "U+001D":
              keyInfo = { code: "ArrowRight" };
              break;
            case "U+001E":
              keyInfo = { code: "ArrowUp" };
              break;
            case "U+001F":
              keyInfo = { code: "ArrowDown" };
              break;
          }
        }
        if (!keyInfo)
          return null;
        var key = function() {
          var entry = codeToKeyTable[keyInfo.code];
          if (!entry) return keyInfo.code;
          return event.shiftKey && "shiftKey" in entry ? entry.shiftKey : entry.key;
        }();
        return {
          code: keyInfo.code,
          key,
          location: keyInfo.location,
          keyCap: keyInfo.keyCap
        };
      }
      function queryKeyCap(code, locale) {
        code = String(code);
        if (!codeTable.hasOwnProperty(code)) return "Undefined";
        if (locale && String(locale).toLowerCase() !== "en-us") throw Error("Unsupported locale");
        var keyInfo = codeTable[code];
        return keyInfo.keyCap || keyInfo.code || "Undefined";
      }
      if ("KeyboardEvent" in global && "defineProperty" in Object) {
        (function() {
          function define(o, p2, v2) {
            if (p2 in o) return;
            Object.defineProperty(o, p2, v2);
          }
          define(KeyboardEvent.prototype, "code", { get: function() {
            var keyInfo = keyInfoForEvent(this);
            return keyInfo ? keyInfo.code : "";
          } });
          if ("key" in KeyboardEvent.prototype) {
            var desc = Object.getOwnPropertyDescriptor(KeyboardEvent.prototype, "key");
            Object.defineProperty(KeyboardEvent.prototype, "key", { get: function() {
              var key = desc.get.call(this);
              return keyFixTable.hasOwnProperty(key) ? keyFixTable[key] : key;
            } });
          }
          define(KeyboardEvent.prototype, "key", { get: function() {
            var keyInfo = keyInfoForEvent(this);
            return keyInfo && "key" in keyInfo ? keyInfo.key : "Unidentified";
          } });
          define(KeyboardEvent.prototype, "location", { get: function() {
            var keyInfo = keyInfoForEvent(this);
            return keyInfo && "location" in keyInfo ? keyInfo.location : STANDARD;
          } });
          define(KeyboardEvent.prototype, "locale", { get: function() {
            return "";
          } });
        })();
      }
      if (!("queryKeyCap" in global.KeyboardEvent))
        global.KeyboardEvent.queryKeyCap = queryKeyCap;
      global.identifyKey = function(event) {
        if ("code" in event)
          return;
        var keyInfo = keyInfoForEvent(event);
        event.code = keyInfo ? keyInfo.code : "";
        event.key = keyInfo && "key" in keyInfo ? keyInfo.key : "Unidentified";
        event.location = "location" in event ? event.location : "keyLocation" in event ? event.keyLocation : keyInfo && "location" in keyInfo ? keyInfo.location : STANDARD;
        event.locale = "";
      };
    })(window);
  }
});

// node_modules/aframe-extras/src/controls/keyboard-controls.js
var require_keyboard_controls = __commonJS({
  "node_modules/aframe-extras/src/controls/keyboard-controls.js"(exports, module) {
    require_keyboard_polyfill();
    var PROXY_FLAG = "__keyboard-controls-proxy";
    var KeyboardEvent2 = window.KeyboardEvent;
    module.exports = AFRAME.registerComponent("keyboard-controls", {
      schema: {
        enabled: { default: true },
        debug: { default: false }
      },
      init: function() {
        this.dVelocity = new THREE.Vector3();
        this.localKeys = {};
        this.listeners = {
          keydown: this.onKeyDown.bind(this),
          keyup: this.onKeyUp.bind(this),
          blur: this.onBlur.bind(this),
          onContextMenu: this.onContextMenu.bind(this)
        };
      },
      /*******************************************************************
      * Movement
      */
      isVelocityActive: function() {
        return this.data.enabled && !!Object.keys(this.getKeys()).length;
      },
      getVelocityDelta: function() {
        const data = this.data;
        const keys = this.getKeys();
        this.dVelocity.set(0, 0, 0);
        if (data.enabled) {
          if (keys.KeyW || keys.ArrowUp) {
            this.dVelocity.z -= 1;
          }
          if (keys.KeyA || keys.ArrowLeft) {
            this.dVelocity.x -= 1;
          }
          if (keys.KeyS || keys.ArrowDown) {
            this.dVelocity.z += 1;
          }
          if (keys.KeyD || keys.ArrowRight) {
            this.dVelocity.x += 1;
          }
          if (keys.ShiftLeft) {
            this.dVelocity = this.dVelocity.multiplyScalar(2);
          }
        }
        return this.dVelocity.clone();
      },
      /*******************************************************************
      * Events
      */
      play: function() {
        this.attachEventListeners();
      },
      pause: function() {
        this.removeEventListeners();
      },
      attachEventListeners: function() {
        window.addEventListener("contextmenu", this.listeners.onContextMenu, false);
        window.addEventListener("keydown", this.listeners.keydown, false);
        window.addEventListener("keyup", this.listeners.keyup, false);
        window.addEventListener("blur", this.listeners.blur, false);
      },
      onContextMenu: function() {
        for (const code in this.localKeys) {
          if (this.localKeys.hasOwnProperty(code)) {
            delete this.localKeys[code];
          }
        }
      },
      removeEventListeners: function() {
        window.removeEventListener("keydown", this.listeners.keydown);
        window.removeEventListener("keyup", this.listeners.keyup);
        window.removeEventListener("blur", this.listeners.blur);
      },
      onKeyDown: function(event) {
        if (AFRAME.utils.shouldCaptureKeyEvent(event)) {
          this.localKeys[event.code] = true;
          this.emit(event);
        }
      },
      onKeyUp: function(event) {
        if (AFRAME.utils.shouldCaptureKeyEvent(event)) {
          delete this.localKeys[event.code];
          this.emit(event);
        }
      },
      onBlur: function() {
        for (const code in this.localKeys) {
          if (this.localKeys.hasOwnProperty(code)) {
            delete this.localKeys[code];
          }
        }
      },
      emit: function(event) {
        if (PROXY_FLAG in event) {
          this.el.emit(event.type, event);
        }
        this.el.emit(event.type + ":" + event.code, new KeyboardEvent2(event.type, event));
        if (this.data.debug) console.log(event.type + ":" + event.code);
      },
      /*******************************************************************
      * Accessors
      */
      isPressed: function(code) {
        return code in this.getKeys();
      },
      getKeys: function() {
        if (this.isProxied()) {
          return this.el.sceneEl.components["proxy-controls"].getKeyboard();
        }
        return this.localKeys;
      },
      isProxied: function() {
        const proxyControls = this.el.sceneEl.components["proxy-controls"];
        return proxyControls && proxyControls.isConnected();
      }
    });
  }
});

// node_modules/aframe-extras/src/controls/touch-controls.js
var require_touch_controls = __commonJS({
  "node_modules/aframe-extras/src/controls/touch-controls.js"(exports, module) {
    module.exports = AFRAME.registerComponent("touch-controls", {
      schema: {
        enabled: { default: true },
        reverseEnabled: { default: true }
      },
      init: function() {
        this.dVelocity = new THREE.Vector3();
        this.bindMethods();
        this.direction = 0;
      },
      play: function() {
        this.addEventListeners();
      },
      pause: function() {
        this.removeEventListeners();
        this.dVelocity.set(0, 0, 0);
      },
      remove: function() {
        this.pause();
      },
      addEventListeners: function() {
        const sceneEl = this.el.sceneEl;
        const canvasEl = sceneEl.canvas;
        if (!canvasEl) {
          sceneEl.addEventListener("render-target-loaded", this.addEventListeners.bind(this));
          return;
        }
        canvasEl.addEventListener("touchstart", this.onTouchStart);
        canvasEl.addEventListener("touchend", this.onTouchEnd);
        const vrModeUI = sceneEl.getAttribute("vr-mode-ui");
        if (vrModeUI && vrModeUI.cardboardModeEnabled) {
          sceneEl.addEventListener("enter-vr", this.onEnterVR);
        }
      },
      removeEventListeners: function() {
        const canvasEl = this.el.sceneEl && this.el.sceneEl.canvas;
        if (!canvasEl) {
          return;
        }
        canvasEl.removeEventListener("touchstart", this.onTouchStart);
        canvasEl.removeEventListener("touchend", this.onTouchEnd);
        this.el.sceneEl.removeEventListener("enter-vr", this.onEnterVR);
      },
      isVelocityActive: function() {
        return this.data.enabled && !!this.direction;
      },
      getVelocityDelta: function() {
        this.dVelocity.z = this.direction;
        return this.dVelocity.clone();
      },
      bindMethods: function() {
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onEnterVR = this.onEnterVR.bind(this);
      },
      onTouchStart: function(e) {
        this.direction = -1;
        if (this.data.reverseEnabled && e.touches && e.touches.length === 2) {
          this.direction = 1;
        }
        e.preventDefault();
      },
      onTouchEnd: function(e) {
        this.direction = 0;
        e.preventDefault();
      },
      onEnterVR: function() {
        const xrSession = this.el.sceneEl.xrSession;
        if (!xrSession) {
          return;
        }
        xrSession.addEventListener("selectstart", this.onTouchStart);
        xrSession.addEventListener("selectend", this.onTouchEnd);
      }
    });
  }
});

// node_modules/aframe-extras/src/controls/movement-controls.js
var require_movement_controls = __commonJS({
  "node_modules/aframe-extras/src/controls/movement-controls.js"(exports, module) {
    var COMPONENT_SUFFIX = "-controls";
    var MAX_DELTA = 0.2;
    var EPS = 1e-5;
    var MOVED = "moved";
    module.exports = AFRAME.registerComponent("movement-controls", {
      /*******************************************************************
       * Schema
       */
      dependencies: ["rotation"],
      schema: {
        enabled: { default: true },
        controls: { default: ["gamepad", "trackpad", "keyboard", "touch"] },
        speed: { default: 0.3, min: 0 },
        fly: { default: false },
        constrainToNavMesh: { default: false },
        camera: { default: "[movement-controls] [camera]", type: "selector" }
      },
      /*******************************************************************
       * Lifecycle
       */
      init: function() {
        const el = this.el;
        if (!this.data.camera) {
          this.data.camera = el.querySelector("[camera]");
        }
        this.velocityCtrl = null;
        this.velocity = new THREE.Vector3();
        this.heading = new THREE.Quaternion();
        this.eventDetail = {};
        this.navGroup = null;
        this.navNode = null;
        if (el.sceneEl.hasLoaded) {
          this.injectControls();
        } else {
          el.sceneEl.addEventListener("loaded", this.injectControls.bind(this));
        }
      },
      update: function(prevData) {
        const el = this.el;
        const data = this.data;
        const nav = el.sceneEl.systems.nav;
        if (el.sceneEl.hasLoaded) {
          this.injectControls();
        }
        if (nav && data.constrainToNavMesh !== prevData.constrainToNavMesh) {
          data.constrainToNavMesh ? nav.addAgent(this) : nav.removeAgent(this);
        }
        if (data.enabled !== prevData.enabled) {
          for (let i = 0; i < data.controls.length; i++) {
            const name = data.controls[i] + COMPONENT_SUFFIX;
            this.el.setAttribute(name, { enabled: this.data.enabled });
          }
        }
      },
      injectControls: function() {
        const data = this.data;
        for (let i = 0; i < data.controls.length; i++) {
          const name = data.controls[i] + COMPONENT_SUFFIX;
          this.el.setAttribute(name, { enabled: this.data.enabled });
        }
      },
      updateNavLocation: function() {
        this.navGroup = null;
        this.navNode = null;
      },
      /*******************************************************************
       * Tick
       */
      tick: function() {
        const start = new THREE.Vector3();
        const end = new THREE.Vector3();
        const clampedEnd = new THREE.Vector3();
        return function(t, dt) {
          if (!dt) return;
          const el = this.el;
          const data = this.data;
          if (!data.enabled) return;
          this.updateVelocityCtrl();
          const velocityCtrl = this.velocityCtrl;
          const velocity = this.velocity;
          if (!velocityCtrl) return;
          if (dt / 1e3 > MAX_DELTA) {
            velocity.set(0, 0, 0);
          } else {
            this.updateVelocity(dt);
          }
          if (data.constrainToNavMesh && velocityCtrl.isNavMeshConstrained !== false) {
            if (velocity.lengthSq() < EPS) return;
            start.copy(el.object3D.position);
            end.copy(velocity).multiplyScalar(dt / 1e3).add(start);
            const nav = el.sceneEl.systems.nav;
            this.navGroup = this.navGroup === null ? nav.getGroup(start) : this.navGroup;
            this.navNode = this.navNode || nav.getNode(start, this.navGroup);
            this.navNode = nav.clampStep(start, end, this.navGroup, this.navNode, clampedEnd);
            el.object3D.position.copy(clampedEnd);
          } else if (el.hasAttribute("velocity")) {
            el.setAttribute("velocity", velocity);
          } else {
            el.object3D.position.x += velocity.x * dt / 1e3;
            el.object3D.position.y += velocity.y * dt / 1e3;
            el.object3D.position.z += velocity.z * dt / 1e3;
          }
        };
      }(),
      /*******************************************************************
       * Movement
       */
      updateVelocityCtrl: function() {
        const data = this.data;
        if (data.enabled) {
          for (let i = 0, l = data.controls.length; i < l; i++) {
            const control = this.el.components[data.controls[i] + COMPONENT_SUFFIX];
            if (control && control.isVelocityActive()) {
              this.velocityCtrl = control;
              return;
            }
          }
          this.velocityCtrl = null;
        }
      },
      updateVelocity: function() {
        const vector2 = new THREE.Vector2();
        const quaternion = new THREE.Quaternion();
        return function(dt) {
          let dVelocity;
          const el = this.el;
          const control = this.velocityCtrl;
          const velocity = this.velocity;
          const data = this.data;
          if (control) {
            if (control.getVelocityDelta) {
              dVelocity = control.getVelocityDelta(dt);
            } else if (control.getVelocity) {
              velocity.copy(control.getVelocity());
              return;
            } else if (control.getPositionDelta) {
              velocity.copy(control.getPositionDelta(dt).multiplyScalar(1e3 / dt));
              return;
            } else {
              throw new Error("Incompatible movement controls: ", control);
            }
          }
          if (el.hasAttribute("velocity") && !data.constrainToNavMesh) {
            velocity.copy(this.el.getAttribute("velocity"));
          }
          if (dVelocity && data.enabled) {
            const cameraEl = data.camera;
            quaternion.copy(cameraEl.object3D.quaternion);
            quaternion.premultiply(el.object3D.quaternion);
            dVelocity.applyQuaternion(quaternion);
            const factor = dVelocity.length();
            if (data.fly) {
              velocity.copy(dVelocity);
              velocity.multiplyScalar(this.data.speed * 16.66667);
            } else {
              vector2.set(dVelocity.x, dVelocity.z);
              vector2.setLength(factor * this.data.speed * 16.66667);
              velocity.x = vector2.x;
              velocity.y = 0;
              velocity.z = vector2.y;
            }
            if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {
              this.eventDetail.velocity = velocity;
              this.el.emit(MOVED, this.eventDetail);
            }
          }
        };
      }()
    });
  }
});

// node_modules/aframe-extras/src/controls/trackpad-controls.js
var require_trackpad_controls = __commonJS({
  "node_modules/aframe-extras/src/controls/trackpad-controls.js"(exports, module) {
    module.exports = AFRAME.registerComponent("trackpad-controls", {
      schema: {
        enabled: { default: true },
        enableNegX: { default: true },
        enablePosX: { default: true },
        enableNegZ: { default: true },
        enablePosZ: { default: true },
        mode: { default: "touch", oneOf: ["swipe", "touch", "press"] }
      },
      init: function() {
        this.dVelocity = new THREE.Vector3();
        this.zVel = 0;
        this.xVel = 0;
        this.bindMethods();
      },
      play: function() {
        this.addEventListeners();
      },
      pause: function() {
        this.removeEventListeners();
        this.dVelocity.set(0, 0, 0);
      },
      remove: function() {
        this.pause();
      },
      addEventListeners: function() {
        const data = this.data;
        const sceneEl = this.el.sceneEl;
        sceneEl.addEventListener("axismove", this.onAxisMove);
        switch (data.mode) {
          case "swipe":
          case "touch":
            sceneEl.addEventListener("trackpadtouchstart", this.onTouchStart);
            sceneEl.addEventListener("trackpadtouchend", this.onTouchEnd);
            break;
          case "press":
            sceneEl.addEventListener("trackpaddown", this.onTouchStart);
            sceneEl.addEventListener("trackpadup", this.onTouchEnd);
            break;
        }
      },
      removeEventListeners: function() {
        const sceneEl = this.el.sceneEl;
        sceneEl.removeEventListener("axismove", this.onAxisMove);
        sceneEl.removeEventListener("trackpadtouchstart", this.onTouchStart);
        sceneEl.removeEventListener("trackpadtouchend", this.onTouchEnd);
        sceneEl.removeEventListener("trackpaddown", this.onTouchStart);
        sceneEl.removeEventListener("trackpadup", this.onTouchEnd);
      },
      isVelocityActive: function() {
        return this.data.enabled && this.isMoving;
      },
      getVelocityDelta: function() {
        this.dVelocity.z = this.isMoving ? -this.zVel : 1;
        this.dVelocity.x = this.isMoving ? this.xVel : 1;
        return this.dVelocity.clone();
      },
      bindMethods: function() {
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onAxisMove = this.onAxisMove.bind(this);
      },
      onTouchStart: function(e) {
        switch (this.data.mode) {
          case "swipe":
            this.canRecordAxis = true;
            this.startingAxisData = [];
            break;
          case "touch":
            this.isMoving = true;
            break;
          case "press":
            this.isMoving = true;
            break;
        }
        e.preventDefault();
      },
      onTouchEnd: function(e) {
        if (this.data.mode == "swipe") {
          this.startingAxisData = [];
        }
        this.isMoving = false;
        e.preventDefault();
      },
      onAxisMove: function(e) {
        switch (this.data.mode) {
          case "swipe":
            return this.handleSwipeAxis(e);
          case "touch":
          case "press":
            return this.handleTouchAxis(e);
        }
      },
      handleSwipeAxis: function(e) {
        const data = this.data;
        const axisData = e.detail.axis;
        if (this.startingAxisData.length === 0 && this.canRecordAxis) {
          this.canRecordAxis = false;
          this.startingAxisData[0] = axisData[0];
          this.startingAxisData[1] = axisData[1];
        }
        if (this.startingAxisData.length > 0) {
          let velX = 0;
          let velZ = 0;
          if (data.enableNegX && axisData[0] < this.startingAxisData[0]) {
            velX = -1;
          }
          if (data.enablePosX && axisData[0] > this.startingAxisData[0]) {
            velX = 1;
          }
          if (data.enablePosZ && axisData[1] > this.startingAxisData[1]) {
            velZ = -1;
          }
          if (data.enableNegZ && axisData[1] < this.startingAxisData[1]) {
            velZ = 1;
          }
          const absChangeZ = Math.abs(this.startingAxisData[1] - axisData[1]);
          const absChangeX = Math.abs(this.startingAxisData[0] - axisData[0]);
          if (absChangeX > absChangeZ) {
            this.zVel = 0;
            this.xVel = velX;
            this.isMoving = true;
          } else {
            this.xVel = 0;
            this.zVel = velZ;
            this.isMoving = true;
          }
        }
      },
      handleTouchAxis: function(e) {
        const data = this.data;
        const axisData = e.detail.axis;
        let velX = 0;
        let velZ = 0;
        if (data.enableNegX && axisData[0] < 0) {
          velX = -1;
        }
        if (data.enablePosX && axisData[0] > 0) {
          velX = 1;
        }
        if (data.enablePosZ && axisData[1] > 0) {
          velZ = -1;
        }
        if (data.enableNegZ && axisData[1] < 0) {
          velZ = 1;
        }
        if (Math.abs(axisData[0]) > Math.abs(axisData[1])) {
          this.zVel = 0;
          this.xVel = velX;
        } else {
          this.xVel = 0;
          this.zVel = velZ;
        }
      }
    });
  }
});

// node_modules/nipplejs/src/utils.js
var distance, angle, findCoord, radians, degrees, isPressed, timers, throttle, bindEvt, unbindEvt, prepareEvent, getScroll, applyPosition, getTransitionStyle, getVendorStyle, configStylePropertyObject, extend, safeExtend, map, clamp;
var init_utils = __esm({
  "node_modules/nipplejs/src/utils.js"() {
    distance = (p1, p2) => {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      return Math.sqrt(dx * dx + dy * dy);
    };
    angle = (p1, p2) => {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      return degrees(Math.atan2(dy, dx));
    };
    findCoord = (p2, d2, a) => {
      const b = { x: 0, y: 0 };
      a = radians(a);
      b.x = p2.x - d2 * Math.cos(a);
      b.y = p2.y - d2 * Math.sin(a);
      return b;
    };
    radians = (a) => {
      return a * (Math.PI / 180);
    };
    degrees = (a) => {
      return a * (180 / Math.PI);
    };
    isPressed = (evt) => {
      if (isNaN(evt.buttons)) {
        return evt.pressure !== 0;
      }
      return evt.buttons !== 0;
    };
    timers = /* @__PURE__ */ new Map();
    throttle = (cb) => {
      if (timers.has(cb)) {
        clearTimeout(timers.get(cb));
      }
      timers.set(cb, setTimeout(cb, 100));
    };
    bindEvt = (el, arg, handler) => {
      const types = arg.split(/[ ,]+/g);
      let type;
      for (let i = 0; i < types.length; i += 1) {
        type = types[i];
        if (el.addEventListener) {
          el.addEventListener(type, handler, false);
        } else if (el.attachEvent) {
          el.attachEvent(type, handler);
        }
      }
    };
    unbindEvt = (el, arg, handler) => {
      const types = arg.split(/[ ,]+/g);
      let type;
      for (let i = 0; i < types.length; i += 1) {
        type = types[i];
        if (el.removeEventListener) {
          el.removeEventListener(type, handler);
        } else if (el.detachEvent) {
          el.detachEvent(type, handler);
        }
      }
    };
    prepareEvent = (evt) => {
      evt.preventDefault();
      return evt.type.match(/^touch/) ? evt.changedTouches : evt;
    };
    getScroll = () => {
      const x = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
      const y = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
      return {
        x,
        y
      };
    };
    applyPosition = (el, pos) => {
      if (pos.top || pos.right || pos.bottom || pos.left) {
        el.style.top = pos.top;
        el.style.right = pos.right;
        el.style.bottom = pos.bottom;
        el.style.left = pos.left;
      } else {
        el.style.left = pos.x + "px";
        el.style.top = pos.y + "px";
      }
    };
    getTransitionStyle = (property, values, time) => {
      const obj = configStylePropertyObject(property);
      for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (typeof values === "string") {
            obj[i] = values + " " + time;
          } else {
            let st = "";
            for (let j = 0, max2 = values.length; j < max2; j += 1) {
              st += values[j] + " " + time + ", ";
            }
            obj[i] = st.slice(0, -2);
          }
        }
      }
      return obj;
    };
    getVendorStyle = (property, value) => {
      const obj = configStylePropertyObject(property);
      for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
          obj[i] = value;
        }
      }
      return obj;
    };
    configStylePropertyObject = (prop) => {
      const obj = {};
      obj[prop] = "";
      const vendors = ["webkit", "Moz", "o"];
      vendors.forEach(function(vendor) {
        obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = "";
      });
      return obj;
    };
    extend = (objA, objB) => {
      for (let i in objB) {
        if (objB.hasOwnProperty(i)) {
          objA[i] = objB[i];
        }
      }
      return objA;
    };
    safeExtend = (objA, objB) => {
      const obj = {};
      for (let i in objA) {
        if (objA.hasOwnProperty(i) && objB.hasOwnProperty(i)) {
          obj[i] = objB[i];
        } else if (objA.hasOwnProperty(i)) {
          obj[i] = objA[i];
        }
      }
      return obj;
    };
    map = (ar, fn) => {
      if (ar.length) {
        for (let i = 0, max2 = ar.length; i < max2; i += 1) {
          fn(ar[i]);
        }
      } else {
        fn(ar);
      }
    };
    clamp = (pos, nipplePos, size) => ({
      //                          left-clamping        right-clamping
      x: Math.min(Math.max(pos.x, nipplePos.x - size), nipplePos.x + size),
      //                          top-clamping         bottom-clamping
      y: Math.min(Math.max(pos.y, nipplePos.y - size), nipplePos.y + size)
    });
  }
});

// node_modules/nipplejs/src/super.js
function Super() {
}
var isTouch, isPointer, isMSPointer, events, toBind, secondBind, super_default;
var init_super = __esm({
  "node_modules/nipplejs/src/super.js"() {
    init_utils();
    isTouch = !!("ontouchstart" in window);
    isPointer = window.PointerEvent ? true : false;
    isMSPointer = window.MSPointerEvent ? true : false;
    events = {
      touch: {
        start: "touchstart",
        move: "touchmove",
        end: "touchend, touchcancel"
      },
      mouse: {
        start: "mousedown",
        move: "mousemove",
        end: "mouseup"
      },
      pointer: {
        start: "pointerdown",
        move: "pointermove",
        end: "pointerup, pointercancel"
      },
      MSPointer: {
        start: "MSPointerDown",
        move: "MSPointerMove",
        end: "MSPointerUp"
      }
    };
    secondBind = {};
    if (isPointer) {
      toBind = events.pointer;
    } else if (isMSPointer) {
      toBind = events.MSPointer;
    } else if (isTouch) {
      toBind = events.touch;
      secondBind = events.mouse;
    } else {
      toBind = events.mouse;
    }
    Super.prototype.on = function(arg, cb) {
      var self = this;
      var types = arg.split(/[ ,]+/g);
      var type;
      self._handlers_ = self._handlers_ || {};
      for (var i = 0; i < types.length; i += 1) {
        type = types[i];
        self._handlers_[type] = self._handlers_[type] || [];
        self._handlers_[type].push(cb);
      }
      return self;
    };
    Super.prototype.off = function(type, cb) {
      var self = this;
      self._handlers_ = self._handlers_ || {};
      if (type === void 0) {
        self._handlers_ = {};
      } else if (cb === void 0) {
        self._handlers_[type] = null;
      } else if (self._handlers_[type] && self._handlers_[type].indexOf(cb) >= 0) {
        self._handlers_[type].splice(self._handlers_[type].indexOf(cb), 1);
      }
      return self;
    };
    Super.prototype.trigger = function(arg, data) {
      var self = this;
      var types = arg.split(/[ ,]+/g);
      var type;
      self._handlers_ = self._handlers_ || {};
      for (var i = 0; i < types.length; i += 1) {
        type = types[i];
        if (self._handlers_[type] && self._handlers_[type].length) {
          self._handlers_[type].forEach(function(handler) {
            handler.call(self, {
              type,
              target: self
            }, data);
          });
        }
      }
    };
    Super.prototype.config = function(options) {
      var self = this;
      self.options = self.defaults || {};
      if (options) {
        self.options = safeExtend(self.options, options);
      }
    };
    Super.prototype.bindEvt = function(el, type) {
      var self = this;
      self._domHandlers_ = self._domHandlers_ || {};
      self._domHandlers_[type] = function() {
        if (typeof self["on" + type] === "function") {
          self["on" + type].apply(self, arguments);
        } else {
          console.warn('[WARNING] : Missing "on' + type + '" handler.');
        }
      };
      bindEvt(el, toBind[type], self._domHandlers_[type]);
      if (secondBind[type]) {
        bindEvt(el, secondBind[type], self._domHandlers_[type]);
      }
      return self;
    };
    Super.prototype.unbindEvt = function(el, type) {
      var self = this;
      self._domHandlers_ = self._domHandlers_ || {};
      unbindEvt(el, toBind[type], self._domHandlers_[type]);
      if (secondBind[type]) {
        unbindEvt(el, secondBind[type], self._domHandlers_[type]);
      }
      delete self._domHandlers_[type];
      return this;
    };
    super_default = Super;
  }
});

// node_modules/nipplejs/src/nipple.js
function Nipple(collection, options) {
  this.identifier = options.identifier;
  this.position = options.position;
  this.frontPosition = options.frontPosition;
  this.collection = collection;
  this.defaults = {
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    mode: "dynamic",
    zone: document.body,
    lockX: false,
    lockY: false,
    shape: "circle"
  };
  this.config(options);
  if (this.options.mode === "dynamic") {
    this.options.restOpacity = 0;
  }
  this.id = Nipple.id;
  Nipple.id += 1;
  this.buildEl().stylize();
  this.instance = {
    el: this.ui.el,
    on: this.on.bind(this),
    off: this.off.bind(this),
    show: this.show.bind(this),
    hide: this.hide.bind(this),
    add: this.addToDom.bind(this),
    remove: this.removeFromDom.bind(this),
    destroy: this.destroy.bind(this),
    setPosition: this.setPosition.bind(this),
    resetDirection: this.resetDirection.bind(this),
    computeDirection: this.computeDirection.bind(this),
    trigger: this.trigger.bind(this),
    position: this.position,
    frontPosition: this.frontPosition,
    ui: this.ui,
    identifier: this.identifier,
    id: this.id,
    options: this.options
  };
  return this.instance;
}
var nipple_default;
var init_nipple = __esm({
  "node_modules/nipplejs/src/nipple.js"() {
    init_super();
    init_utils();
    Nipple.prototype = new super_default();
    Nipple.constructor = Nipple;
    Nipple.id = 0;
    Nipple.prototype.buildEl = function(options) {
      this.ui = {};
      if (this.options.dataOnly) {
        return this;
      }
      this.ui.el = document.createElement("div");
      this.ui.back = document.createElement("div");
      this.ui.front = document.createElement("div");
      this.ui.el.className = "nipple collection_" + this.collection.id;
      this.ui.back.className = "back";
      this.ui.front.className = "front";
      this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id);
      this.ui.el.appendChild(this.ui.back);
      this.ui.el.appendChild(this.ui.front);
      return this;
    };
    Nipple.prototype.stylize = function() {
      if (this.options.dataOnly) {
        return this;
      }
      var animTime = this.options.fadeTime + "ms";
      var borderStyle = getVendorStyle("borderRadius", "50%");
      var transitStyle = getTransitionStyle("transition", "opacity", animTime);
      var styles = {};
      styles.el = {
        position: "absolute",
        opacity: this.options.restOpacity,
        display: "block",
        "zIndex": 999
      };
      styles.back = {
        position: "absolute",
        display: "block",
        width: this.options.size + "px",
        height: this.options.size + "px",
        left: 0,
        marginLeft: -this.options.size / 2 + "px",
        marginTop: -this.options.size / 2 + "px",
        background: this.options.color,
        "opacity": ".5"
      };
      styles.front = {
        width: this.options.size / 2 + "px",
        height: this.options.size / 2 + "px",
        position: "absolute",
        display: "block",
        left: 0,
        marginLeft: -this.options.size / 4 + "px",
        marginTop: -this.options.size / 4 + "px",
        background: this.options.color,
        "opacity": ".5",
        transform: "translate(0px, 0px)"
      };
      extend(styles.el, transitStyle);
      if (this.options.shape === "circle") {
        extend(styles.back, borderStyle);
      }
      extend(styles.front, borderStyle);
      this.applyStyles(styles);
      return this;
    };
    Nipple.prototype.applyStyles = function(styles) {
      for (var i in this.ui) {
        if (this.ui.hasOwnProperty(i)) {
          for (var j in styles[i]) {
            this.ui[i].style[j] = styles[i][j];
          }
        }
      }
      return this;
    };
    Nipple.prototype.addToDom = function() {
      if (this.options.dataOnly || document.body.contains(this.ui.el)) {
        return this;
      }
      this.options.zone.appendChild(this.ui.el);
      return this;
    };
    Nipple.prototype.removeFromDom = function() {
      if (this.options.dataOnly || !document.body.contains(this.ui.el)) {
        return this;
      }
      this.options.zone.removeChild(this.ui.el);
      return this;
    };
    Nipple.prototype.destroy = function() {
      clearTimeout(this.removeTimeout);
      clearTimeout(this.showTimeout);
      clearTimeout(this.restTimeout);
      this.trigger("destroyed", this.instance);
      this.removeFromDom();
      this.off();
    };
    Nipple.prototype.show = function(cb) {
      var self = this;
      if (self.options.dataOnly) {
        return self;
      }
      clearTimeout(self.removeTimeout);
      clearTimeout(self.showTimeout);
      clearTimeout(self.restTimeout);
      self.addToDom();
      self.restCallback();
      setTimeout(function() {
        self.ui.el.style.opacity = 1;
      }, 0);
      self.showTimeout = setTimeout(function() {
        self.trigger("shown", self.instance);
        if (typeof cb === "function") {
          cb.call(this);
        }
      }, self.options.fadeTime);
      return self;
    };
    Nipple.prototype.hide = function(cb) {
      var self = this;
      if (self.options.dataOnly) {
        return self;
      }
      self.ui.el.style.opacity = self.options.restOpacity;
      clearTimeout(self.removeTimeout);
      clearTimeout(self.showTimeout);
      clearTimeout(self.restTimeout);
      self.removeTimeout = setTimeout(
        function() {
          var display = self.options.mode === "dynamic" ? "none" : "block";
          self.ui.el.style.display = display;
          if (typeof cb === "function") {
            cb.call(self);
          }
          self.trigger("hidden", self.instance);
        },
        self.options.fadeTime
      );
      if (self.options.restJoystick) {
        const rest = self.options.restJoystick;
        const newPosition = {};
        newPosition.x = rest === true || rest.x !== false ? 0 : self.instance.frontPosition.x;
        newPosition.y = rest === true || rest.y !== false ? 0 : self.instance.frontPosition.y;
        self.setPosition(cb, newPosition);
      }
      return self;
    };
    Nipple.prototype.setPosition = function(cb, position) {
      var self = this;
      self.frontPosition = {
        x: position.x,
        y: position.y
      };
      var animTime = self.options.fadeTime + "ms";
      var transitStyle = {};
      transitStyle.front = getTransitionStyle(
        "transition",
        ["transform"],
        animTime
      );
      var styles = { front: {} };
      styles.front = {
        transform: "translate(" + self.frontPosition.x + "px," + self.frontPosition.y + "px)"
      };
      self.applyStyles(transitStyle);
      self.applyStyles(styles);
      self.restTimeout = setTimeout(
        function() {
          if (typeof cb === "function") {
            cb.call(self);
          }
          self.restCallback();
        },
        self.options.fadeTime
      );
    };
    Nipple.prototype.restCallback = function() {
      var self = this;
      var transitStyle = {};
      transitStyle.front = getTransitionStyle("transition", "none", "");
      self.applyStyles(transitStyle);
      self.trigger("rested", self.instance);
    };
    Nipple.prototype.resetDirection = function() {
      this.direction = {
        x: false,
        y: false,
        angle: false
      };
    };
    Nipple.prototype.computeDirection = function(obj) {
      var rAngle = obj.angle.radian;
      var angle45 = Math.PI / 4;
      var angle90 = Math.PI / 2;
      var direction, directionX, directionY;
      if (rAngle > angle45 && rAngle < angle45 * 3 && !obj.lockX) {
        direction = "up";
      } else if (rAngle > -angle45 && rAngle <= angle45 && !obj.lockY) {
        direction = "left";
      } else if (rAngle > -angle45 * 3 && rAngle <= -angle45 && !obj.lockX) {
        direction = "down";
      } else if (!obj.lockY) {
        direction = "right";
      }
      if (!obj.lockY) {
        if (rAngle > -angle90 && rAngle < angle90) {
          directionX = "left";
        } else {
          directionX = "right";
        }
      }
      if (!obj.lockX) {
        if (rAngle > 0) {
          directionY = "up";
        } else {
          directionY = "down";
        }
      }
      if (obj.force > this.options.threshold) {
        var oldDirection = {};
        var i;
        for (i in this.direction) {
          if (this.direction.hasOwnProperty(i)) {
            oldDirection[i] = this.direction[i];
          }
        }
        var same = {};
        this.direction = {
          x: directionX,
          y: directionY,
          angle: direction
        };
        obj.direction = this.direction;
        for (i in oldDirection) {
          if (oldDirection[i] === this.direction[i]) {
            same[i] = true;
          }
        }
        if (same.x && same.y && same.angle) {
          return obj;
        }
        if (!same.x || !same.y) {
          this.trigger("plain", obj);
        }
        if (!same.x) {
          this.trigger("plain:" + directionX, obj);
        }
        if (!same.y) {
          this.trigger("plain:" + directionY, obj);
        }
        if (!same.angle) {
          this.trigger("dir dir:" + direction, obj);
        }
      } else {
        this.resetDirection();
      }
      return obj;
    };
    nipple_default = Nipple;
  }
});

// node_modules/nipplejs/src/collection.js
function Collection(manager, options) {
  var self = this;
  self.nipples = [];
  self.idles = [];
  self.actives = [];
  self.ids = [];
  self.pressureIntervals = {};
  self.manager = manager;
  self.id = Collection.id;
  Collection.id += 1;
  self.defaults = {
    zone: document.body,
    multitouch: false,
    maxNumberOfNipples: 10,
    mode: "dynamic",
    position: { top: 0, left: 0 },
    catchDistance: 200,
    size: 100,
    threshold: 0.1,
    color: "white",
    fadeTime: 250,
    dataOnly: false,
    restJoystick: true,
    restOpacity: 0.5,
    lockX: false,
    lockY: false,
    shape: "circle",
    dynamicPage: false,
    follow: false
  };
  self.config(options);
  if (self.options.mode === "static" || self.options.mode === "semi") {
    self.options.multitouch = false;
  }
  if (!self.options.multitouch) {
    self.options.maxNumberOfNipples = 1;
  }
  const computedStyle = getComputedStyle(self.options.zone.parentElement);
  if (computedStyle && computedStyle.display === "flex") {
    self.parentIsFlex = true;
  }
  self.updateBox();
  self.prepareNipples();
  self.bindings();
  self.begin();
  return self.nipples;
}
var collection_default;
var init_collection = __esm({
  "node_modules/nipplejs/src/collection.js"() {
    init_nipple();
    init_super();
    init_utils();
    Collection.prototype = new super_default();
    Collection.constructor = Collection;
    Collection.id = 0;
    Collection.prototype.prepareNipples = function() {
      var self = this;
      var nips = self.nipples;
      nips.on = self.on.bind(self);
      nips.off = self.off.bind(self);
      nips.options = self.options;
      nips.destroy = self.destroy.bind(self);
      nips.ids = self.ids;
      nips.id = self.id;
      nips.processOnMove = self.processOnMove.bind(self);
      nips.processOnEnd = self.processOnEnd.bind(self);
      nips.get = function(id) {
        if (id === void 0) {
          return nips[0];
        }
        for (var i = 0, max2 = nips.length; i < max2; i += 1) {
          if (nips[i].identifier === id) {
            return nips[i];
          }
        }
        return false;
      };
    };
    Collection.prototype.bindings = function() {
      var self = this;
      self.bindEvt(self.options.zone, "start");
      self.options.zone.style.touchAction = "none";
      self.options.zone.style.msTouchAction = "none";
    };
    Collection.prototype.begin = function() {
      var self = this;
      var opts = self.options;
      if (opts.mode === "static") {
        var nipple = self.createNipple(
          opts.position,
          self.manager.getIdentifier()
        );
        nipple.add();
        self.idles.push(nipple);
      }
    };
    Collection.prototype.createNipple = function(position, identifier) {
      var self = this;
      var scroll = self.manager.scroll;
      var toPutOn = {};
      var opts = self.options;
      var offset = {
        x: self.parentIsFlex ? scroll.x : scroll.x + self.box.left,
        y: self.parentIsFlex ? scroll.y : scroll.y + self.box.top
      };
      if (position.x && position.y) {
        toPutOn = {
          x: position.x - offset.x,
          y: position.y - offset.y
        };
      } else if (position.top || position.right || position.bottom || position.left) {
        var dumb = document.createElement("DIV");
        dumb.style.display = "hidden";
        dumb.style.top = position.top;
        dumb.style.right = position.right;
        dumb.style.bottom = position.bottom;
        dumb.style.left = position.left;
        dumb.style.position = "absolute";
        opts.zone.appendChild(dumb);
        var dumbBox = dumb.getBoundingClientRect();
        opts.zone.removeChild(dumb);
        toPutOn = position;
        position = {
          x: dumbBox.left + scroll.x,
          y: dumbBox.top + scroll.y
        };
      }
      var nipple = new nipple_default(self, {
        color: opts.color,
        size: opts.size,
        threshold: opts.threshold,
        fadeTime: opts.fadeTime,
        dataOnly: opts.dataOnly,
        restJoystick: opts.restJoystick,
        restOpacity: opts.restOpacity,
        mode: opts.mode,
        identifier,
        position,
        zone: opts.zone,
        frontPosition: {
          x: 0,
          y: 0
        },
        shape: opts.shape
      });
      if (!opts.dataOnly) {
        applyPosition(nipple.ui.el, toPutOn);
        applyPosition(nipple.ui.front, nipple.frontPosition);
      }
      self.nipples.push(nipple);
      self.trigger("added " + nipple.identifier + ":added", nipple);
      self.manager.trigger("added " + nipple.identifier + ":added", nipple);
      self.bindNipple(nipple);
      return nipple;
    };
    Collection.prototype.updateBox = function() {
      var self = this;
      self.box = self.options.zone.getBoundingClientRect();
    };
    Collection.prototype.bindNipple = function(nipple) {
      var self = this;
      var type;
      var handler = function(evt, data) {
        type = evt.type + " " + data.id + ":" + evt.type;
        self.trigger(type, data);
      };
      nipple.on("destroyed", self.onDestroyed.bind(self));
      nipple.on("shown hidden rested dir plain", handler);
      nipple.on("dir:up dir:right dir:down dir:left", handler);
      nipple.on("plain:up plain:right plain:down plain:left", handler);
    };
    Collection.prototype.pressureFn = function(touch, nipple, identifier) {
      var self = this;
      var previousPressure = 0;
      clearInterval(self.pressureIntervals[identifier]);
      self.pressureIntervals[identifier] = setInterval((function() {
        var pressure = touch.force || touch.pressure || touch.webkitForce || 0;
        if (pressure !== previousPressure) {
          nipple.trigger("pressure", pressure);
          self.trigger("pressure " + nipple.identifier + ":pressure", pressure);
          previousPressure = pressure;
        }
      }).bind(self), 100);
    };
    Collection.prototype.onstart = function(evt) {
      var self = this;
      var opts = self.options;
      var origEvt = evt;
      evt = prepareEvent(evt);
      self.updateBox();
      var process = function(touch) {
        if (self.actives.length < opts.maxNumberOfNipples) {
          self.processOnStart(touch);
        } else if (origEvt.type.match(/^touch/)) {
          Object.keys(self.manager.ids).forEach(function(k) {
            if (Object.values(origEvt.touches).findIndex(function(t) {
              return t.identifier === k;
            }) < 0) {
              var e = [evt[0]];
              e.identifier = k;
              self.processOnEnd(e);
            }
          });
          if (self.actives.length < opts.maxNumberOfNipples) {
            self.processOnStart(touch);
          }
        }
      };
      map(evt, process);
      self.manager.bindDocument();
      return false;
    };
    Collection.prototype.processOnStart = function(evt) {
      var self = this;
      var opts = self.options;
      var indexInIdles;
      var identifier = self.manager.getIdentifier(evt);
      var pressure = evt.force || evt.pressure || evt.webkitForce || 0;
      var position = {
        x: evt.pageX,
        y: evt.pageY
      };
      var nipple = self.getOrCreate(identifier, position);
      if (nipple.identifier !== identifier) {
        self.manager.removeIdentifier(nipple.identifier);
      }
      nipple.identifier = identifier;
      var process = function(nip) {
        nip.trigger("start", nip);
        self.trigger("start " + nip.id + ":start", nip);
        nip.show();
        if (pressure > 0) {
          self.pressureFn(evt, nip, nip.identifier);
        }
        self.processOnMove(evt);
      };
      if ((indexInIdles = self.idles.indexOf(nipple)) >= 0) {
        self.idles.splice(indexInIdles, 1);
      }
      self.actives.push(nipple);
      self.ids.push(nipple.identifier);
      if (opts.mode !== "semi") {
        process(nipple);
      } else {
        var distance2 = distance(position, nipple.position);
        if (distance2 <= opts.catchDistance) {
          process(nipple);
        } else {
          nipple.destroy();
          self.processOnStart(evt);
          return;
        }
      }
      return nipple;
    };
    Collection.prototype.getOrCreate = function(identifier, position) {
      var self = this;
      var opts = self.options;
      var nipple;
      if (/(semi|static)/.test(opts.mode)) {
        nipple = self.idles[0];
        if (nipple) {
          self.idles.splice(0, 1);
          return nipple;
        }
        if (opts.mode === "semi") {
          return self.createNipple(position, identifier);
        }
        console.warn("Coudln't find the needed nipple.");
        return false;
      }
      nipple = self.createNipple(position, identifier);
      return nipple;
    };
    Collection.prototype.processOnMove = function(evt) {
      var self = this;
      var opts = self.options;
      var identifier = self.manager.getIdentifier(evt);
      var nipple = self.nipples.get(identifier);
      var scroll = self.manager.scroll;
      if (!isPressed(evt)) {
        this.processOnEnd(evt);
        return;
      }
      if (!nipple) {
        console.error("Found zombie joystick with ID " + identifier);
        self.manager.removeIdentifier(identifier);
        return;
      }
      if (opts.dynamicPage) {
        var elBox = nipple.el.getBoundingClientRect();
        nipple.position = {
          x: scroll.x + elBox.left,
          y: scroll.y + elBox.top
        };
      }
      nipple.identifier = identifier;
      var size = nipple.options.size / 2;
      var pos = {
        x: evt.pageX,
        y: evt.pageY
      };
      if (opts.lockX) {
        pos.y = nipple.position.y;
      }
      if (opts.lockY) {
        pos.x = nipple.position.x;
      }
      var dist = distance(pos, nipple.position);
      var angle2 = angle(pos, nipple.position);
      var rAngle = radians(angle2);
      var force = dist / size;
      var raw = {
        distance: dist,
        position: pos
      };
      var clamped_dist;
      var clamped_pos;
      if (nipple.options.shape === "circle") {
        clamped_dist = Math.min(dist, size);
        clamped_pos = findCoord(nipple.position, clamped_dist, angle2);
      } else {
        clamped_pos = clamp(pos, nipple.position, size);
        clamped_dist = distance(clamped_pos, nipple.position);
      }
      if (opts.follow) {
        if (dist > size) {
          let delta_x = pos.x - clamped_pos.x;
          let delta_y = pos.y - clamped_pos.y;
          nipple.position.x += delta_x;
          nipple.position.y += delta_y;
          nipple.el.style.top = nipple.position.y - (self.box.top + scroll.y) + "px";
          nipple.el.style.left = nipple.position.x - (self.box.left + scroll.x) + "px";
          dist = distance(pos, nipple.position);
        }
      } else {
        pos = clamped_pos;
        dist = clamped_dist;
      }
      var xPosition = pos.x - nipple.position.x;
      var yPosition = pos.y - nipple.position.y;
      nipple.frontPosition = {
        x: xPosition,
        y: yPosition
      };
      if (!opts.dataOnly) {
        nipple.ui.front.style.transform = "translate(" + xPosition + "px," + yPosition + "px)";
      }
      var toSend = {
        identifier: nipple.identifier,
        position: pos,
        force,
        pressure: evt.force || evt.pressure || evt.webkitForce || 0,
        distance: dist,
        angle: {
          radian: rAngle,
          degree: angle2
        },
        vector: {
          x: xPosition / size,
          y: -yPosition / size
        },
        raw,
        instance: nipple,
        lockX: opts.lockX,
        lockY: opts.lockY
      };
      toSend = nipple.computeDirection(toSend);
      toSend.angle = {
        radian: radians(180 - angle2),
        degree: 180 - angle2
      };
      nipple.trigger("move", toSend);
      self.trigger("move " + nipple.id + ":move", toSend);
    };
    Collection.prototype.processOnEnd = function(evt) {
      var self = this;
      var opts = self.options;
      var identifier = self.manager.getIdentifier(evt);
      var nipple = self.nipples.get(identifier);
      var removedIdentifier = self.manager.removeIdentifier(nipple.identifier);
      if (!nipple) {
        return;
      }
      if (!opts.dataOnly) {
        nipple.hide(function() {
          if (opts.mode === "dynamic") {
            nipple.trigger("removed", nipple);
            self.trigger("removed " + nipple.id + ":removed", nipple);
            self.manager.trigger("removed " + nipple.id + ":removed", nipple);
            nipple.destroy();
          }
        });
      }
      clearInterval(self.pressureIntervals[nipple.identifier]);
      nipple.resetDirection();
      nipple.trigger("end", nipple);
      self.trigger("end " + nipple.id + ":end", nipple);
      if (self.ids.indexOf(nipple.identifier) >= 0) {
        self.ids.splice(self.ids.indexOf(nipple.identifier), 1);
      }
      if (self.actives.indexOf(nipple) >= 0) {
        self.actives.splice(self.actives.indexOf(nipple), 1);
      }
      if (/(semi|static)/.test(opts.mode)) {
        self.idles.push(nipple);
      } else if (self.nipples.indexOf(nipple) >= 0) {
        self.nipples.splice(self.nipples.indexOf(nipple), 1);
      }
      self.manager.unbindDocument();
      if (/(semi|static)/.test(opts.mode)) {
        self.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;
      }
    };
    Collection.prototype.onDestroyed = function(evt, nipple) {
      var self = this;
      if (self.nipples.indexOf(nipple) >= 0) {
        self.nipples.splice(self.nipples.indexOf(nipple), 1);
      }
      if (self.actives.indexOf(nipple) >= 0) {
        self.actives.splice(self.actives.indexOf(nipple), 1);
      }
      if (self.idles.indexOf(nipple) >= 0) {
        self.idles.splice(self.idles.indexOf(nipple), 1);
      }
      if (self.ids.indexOf(nipple.identifier) >= 0) {
        self.ids.splice(self.ids.indexOf(nipple.identifier), 1);
      }
      self.manager.removeIdentifier(nipple.identifier);
      self.manager.unbindDocument();
    };
    Collection.prototype.destroy = function() {
      var self = this;
      self.unbindEvt(self.options.zone, "start");
      self.nipples.forEach(function(nipple) {
        nipple.destroy();
      });
      for (var i in self.pressureIntervals) {
        if (self.pressureIntervals.hasOwnProperty(i)) {
          clearInterval(self.pressureIntervals[i]);
        }
      }
      self.trigger("destroyed", self.nipples);
      self.manager.unbindDocument();
      self.off();
    };
    collection_default = Collection;
  }
});

// node_modules/nipplejs/src/manager.js
function Manager(options) {
  var self = this;
  self.ids = {};
  self.index = 0;
  self.collections = [];
  self.scroll = getScroll();
  self.config(options);
  self.prepareCollections();
  var resizeHandler = function() {
    var pos;
    self.collections.forEach(function(collection) {
      collection.forEach(function(nipple) {
        pos = nipple.el.getBoundingClientRect();
        nipple.position = {
          x: self.scroll.x + pos.left,
          y: self.scroll.y + pos.top
        };
      });
    });
  };
  bindEvt(window, "resize", function() {
    throttle(resizeHandler);
  });
  var scrollHandler = function() {
    self.scroll = getScroll();
  };
  bindEvt(window, "scroll", function() {
    throttle(scrollHandler);
  });
  return self.collections;
}
var manager_default;
var init_manager = __esm({
  "node_modules/nipplejs/src/manager.js"() {
    init_collection();
    init_super();
    init_utils();
    Manager.prototype = new super_default();
    Manager.constructor = Manager;
    Manager.prototype.prepareCollections = function() {
      var self = this;
      self.collections.create = self.create.bind(self);
      self.collections.on = self.on.bind(self);
      self.collections.off = self.off.bind(self);
      self.collections.destroy = self.destroy.bind(self);
      self.collections.get = function(id) {
        var nipple;
        self.collections.every(function(collection) {
          nipple = collection.get(id);
          return nipple ? false : true;
        });
        return nipple;
      };
    };
    Manager.prototype.create = function(options) {
      return this.createCollection(options);
    };
    Manager.prototype.createCollection = function(options) {
      var self = this;
      var collection = new collection_default(self, options);
      self.bindCollection(collection);
      self.collections.push(collection);
      return collection;
    };
    Manager.prototype.bindCollection = function(collection) {
      var self = this;
      var type;
      var handler = function(evt, data) {
        type = evt.type + " " + data.id + ":" + evt.type;
        self.trigger(type, data);
      };
      collection.on("destroyed", self.onDestroyed.bind(self));
      collection.on("shown hidden rested dir plain", handler);
      collection.on("dir:up dir:right dir:down dir:left", handler);
      collection.on("plain:up plain:right plain:down plain:left", handler);
    };
    Manager.prototype.bindDocument = function() {
      var self = this;
      if (!self.binded) {
        self.bindEvt(document, "move").bindEvt(document, "end");
        self.binded = true;
      }
    };
    Manager.prototype.unbindDocument = function(force) {
      var self = this;
      if (!Object.keys(self.ids).length || force === true) {
        self.unbindEvt(document, "move").unbindEvt(document, "end");
        self.binded = false;
      }
    };
    Manager.prototype.getIdentifier = function(evt) {
      var id;
      if (!evt) {
        id = this.index;
      } else {
        id = evt.identifier === void 0 ? evt.pointerId : evt.identifier;
        if (id === void 0) {
          id = this.latest || 0;
        }
      }
      if (this.ids[id] === void 0) {
        this.ids[id] = this.index;
        this.index += 1;
      }
      this.latest = id;
      return this.ids[id];
    };
    Manager.prototype.removeIdentifier = function(identifier) {
      var removed = {};
      for (var id in this.ids) {
        if (this.ids[id] === identifier) {
          removed.id = id;
          removed.identifier = this.ids[id];
          delete this.ids[id];
          break;
        }
      }
      return removed;
    };
    Manager.prototype.onmove = function(evt) {
      var self = this;
      self.onAny("move", evt);
      return false;
    };
    Manager.prototype.onend = function(evt) {
      var self = this;
      self.onAny("end", evt);
      return false;
    };
    Manager.prototype.oncancel = function(evt) {
      var self = this;
      self.onAny("end", evt);
      return false;
    };
    Manager.prototype.onAny = function(which, evt) {
      var self = this;
      var id;
      var processFn = "processOn" + which.charAt(0).toUpperCase() + which.slice(1);
      evt = prepareEvent(evt);
      var processColl = function(e, id2, coll) {
        if (coll.ids.indexOf(id2) >= 0) {
          coll[processFn](e);
          e._found_ = true;
        }
      };
      var processEvt = function(e) {
        id = self.getIdentifier(e);
        map(self.collections, processColl.bind(null, e, id));
        if (!e._found_) {
          self.removeIdentifier(id);
        }
      };
      map(evt, processEvt);
      return false;
    };
    Manager.prototype.destroy = function() {
      var self = this;
      self.unbindDocument(true);
      self.ids = {};
      self.index = 0;
      self.collections.forEach(function(collection) {
        collection.destroy();
      });
      self.off();
    };
    Manager.prototype.onDestroyed = function(evt, coll) {
      var self = this;
      if (self.collections.indexOf(coll) < 0) {
        return false;
      }
      self.collections.splice(self.collections.indexOf(coll), 1);
    };
    manager_default = Manager;
  }
});

// node_modules/nipplejs/src/index.js
var factory, src_default;
var init_src = __esm({
  "node_modules/nipplejs/src/index.js"() {
    init_manager();
    factory = new manager_default();
    src_default = {
      create: function(options) {
        return factory.create(options);
      },
      factory
    };
  }
});

// node_modules/aframe-extras/src/controls/nipple-controls.js
var nipple_controls_exports = {};
var init_nipple_controls = __esm({
  "node_modules/aframe-extras/src/controls/nipple-controls.js"() {
    init_src();
    AFRAME.registerComponent("nipple-controls", {
      schema: {
        enabled: { default: true },
        mode: { default: "dynamic", oneOf: ["static", "semi", "dynamic"] },
        rotationSensitivity: { default: 1 },
        moveJoystickEnabled: { default: true },
        lookJoystickEnabled: { default: true },
        sideMargin: { default: "30px" },
        bottomMargin: { default: "70px" },
        moveJoystickPosition: { default: "left", oneOf: ["left", "right"] },
        lookJoystickPosition: { default: "right", oneOf: ["left", "right"] }
      },
      init() {
        this.dVelocity = new THREE.Vector3();
        this.lookVector = new THREE.Vector2();
        const lookControls = this.el.querySelector("[look-controls]").components["look-controls"];
        this.pitchObject = lookControls.pitchObject;
        this.yawObject = lookControls.yawObject;
        this.rigRotation = this.el.object3D.rotation;
        this.moveData = void 0;
        this.lookData = void 0;
        this.moving = false;
        this.rotating = false;
      },
      update(oldData) {
        if (this.data.moveJoystickPosition !== oldData.moveJoystickPosition || this.data.sideMargin !== oldData.sideMargin || this.data.bottomMargin !== oldData.bottomMargin || this.data.mode !== oldData.mode) {
          this.removeMoveJoystick();
        }
        if (this.data.lookJoystickPosition !== oldData.lookJoystickPosition || this.data.sideMargin !== oldData.sideMargin || this.data.bottomMargin !== oldData.bottomMargin || this.data.mode !== oldData.mode) {
          this.removeLookJoystick();
        }
        if (this.data.enabled && this.data.moveJoystickEnabled) {
          this.createMoveJoystick();
        } else {
          this.removeMoveJoystick();
        }
        if (this.data.enabled && this.data.lookJoystickEnabled) {
          this.createLookJoystick();
        } else {
          this.removeLookJoystick();
        }
      },
      pause() {
        this.moving = false;
        this.rotating = false;
      },
      remove() {
        this.removeMoveJoystick();
        this.removeLookJoystick();
      },
      isVelocityActive() {
        return this.data.enabled && this.moving;
      },
      getVelocityDelta() {
        this.dVelocity.set(0, 0, 0);
        if (this.isVelocityActive()) {
          const force = this.moveData.force < 1 ? this.moveData.force : 1;
          const angle2 = this.moveData.angle.radian;
          const x = Math.cos(angle2) * force;
          const z = -Math.sin(angle2) * force;
          this.dVelocity.set(x, 0, z);
        }
        return this.dVelocity;
      },
      isRotationActive() {
        return this.data.enabled && this.rotating;
      },
      updateRotation(dt) {
        if (!this.isRotationActive()) return;
        const force = this.lookData.force < 1 ? this.lookData.force : 1;
        const angle2 = this.lookData.angle.radian;
        const lookVector = this.lookVector;
        lookVector.x = Math.cos(angle2) * force;
        lookVector.y = Math.sin(angle2) * force;
        lookVector.multiplyScalar(this.data.rotationSensitivity * dt / 1e3);
        this.yawObject.rotation.y -= lookVector.x;
        let x = this.pitchObject.rotation.x + lookVector.y;
        x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, x));
        this.pitchObject.rotation.x = x;
      },
      tick: function(t, dt) {
        this.updateRotation(dt);
      },
      initLeftZone() {
        const leftZone = document.createElement("div");
        leftZone.setAttribute("id", "joystickLeftZone");
        leftZone.setAttribute(
          "style",
          `position:absolute;${this.data.moveJoystickPosition}:${this.data.sideMargin};bottom:${this.data.bottomMargin};z-index:1`
        );
        document.body.appendChild(leftZone);
        this.leftZone = leftZone;
      },
      initRightZone() {
        const rightZone = document.createElement("div");
        rightZone.setAttribute("id", "joystickRightZone");
        rightZone.setAttribute(
          "style",
          `position:absolute;${this.data.lookJoystickPosition}:${this.data.sideMargin};bottom:${this.data.bottomMargin};z-index:1`
        );
        document.body.appendChild(rightZone);
        this.rightZone = rightZone;
      },
      createMoveJoystick() {
        if (this.moveJoystick) return;
        this.initLeftZone();
        const options = {
          mode: this.data.mode,
          zone: this.leftZone,
          color: "white",
          fadeTime: 0
        };
        this.leftZone.style.width = "100px";
        if (this.data.mode === "static") {
          this.leftZone.style.height = "100px";
          options.position = { left: "50%", bottom: "50%" };
        } else {
          this.leftZone.style.height = "400px";
        }
        this.moveJoystick = src_default.create(options);
        this.moveJoystick.on("move", (evt, data) => {
          this.moveData = data;
          this.moving = true;
        });
        this.moveJoystick.on("end", (evt, data) => {
          this.moving = false;
        });
      },
      createLookJoystick() {
        if (this.lookJoystick) return;
        this.initRightZone();
        const options = {
          mode: this.data.mode,
          zone: this.rightZone,
          color: "white",
          fadeTime: 0
        };
        this.rightZone.style.width = "100px";
        if (this.data.mode === "static") {
          this.rightZone.style.height = "100px";
          options.position = { left: "50%", bottom: "50%" };
        } else {
          this.rightZone.style.height = "400px";
        }
        this.lookJoystick = src_default.create(options);
        this.lookJoystick.on("move", (evt, data) => {
          this.lookData = data;
          this.rotating = true;
        });
        this.lookJoystick.on("end", (evt, data) => {
          this.rotating = false;
        });
      },
      removeMoveJoystick() {
        if (this.moveJoystick) {
          this.moveJoystick.destroy();
          this.moveJoystick = void 0;
        }
        this.moveData = void 0;
        if (this.leftZone && this.leftZone.parentNode) {
          this.leftZone.remove();
          this.leftZone = void 0;
        }
      },
      removeLookJoystick() {
        if (this.lookJoystick) {
          this.lookJoystick.destroy();
          this.lookJoystick = void 0;
        }
        this.lookData = void 0;
        if (this.rightZone && this.rightZone.parentNode) {
          this.rightZone.remove();
          this.rightZone = void 0;
        }
      }
    });
  }
});

// node_modules/aframe-extras/src/controls/index.js
var require_controls = __commonJS({
  "node_modules/aframe-extras/src/controls/index.js"() {
    require_checkpoint_controls();
    require_gamepad_controls();
    require_keyboard_controls();
    require_touch_controls();
    require_movement_controls();
    require_trackpad_controls();
    init_nipple_controls();
  }
});

// node_modules/aframe-extras/src/loaders/animation-mixer.js
var require_animation_mixer = __commonJS({
  "node_modules/aframe-extras/src/loaders/animation-mixer.js"(exports, module) {
    var LoopMode = {
      once: THREE.LoopOnce,
      repeat: THREE.LoopRepeat,
      pingpong: THREE.LoopPingPong
    };
    module.exports = AFRAME.registerComponent("animation-mixer", {
      schema: {
        clip: { default: "*" },
        useRegExp: { default: false },
        duration: { default: 0 },
        clampWhenFinished: { default: false, type: "boolean" },
        crossFadeDuration: { default: 0 },
        loop: { default: "repeat", oneOf: Object.keys(LoopMode) },
        repetitions: { default: Infinity, min: 0 },
        timeScale: { default: 1 },
        startAt: { default: 0 }
      },
      init: function() {
        this.model = null;
        this.mixer = null;
        this.activeActions = [];
        const model = this.el.getObject3D("mesh");
        if (model) {
          this.load(model);
        } else {
          this.el.addEventListener("model-loaded", (e) => {
            this.load(e.detail.model);
          });
        }
      },
      load: function(model) {
        const el = this.el;
        this.model = model;
        this.mixer = new THREE.AnimationMixer(model);
        this.mixer.addEventListener("loop", (e) => {
          el.emit("animation-loop", { action: e.action, loopDelta: e.loopDelta });
        });
        this.mixer.addEventListener("finished", (e) => {
          el.emit("animation-finished", { action: e.action, direction: e.direction });
        });
        if (this.data.clip) this.update({});
      },
      remove: function() {
        if (this.mixer) this.mixer.stopAllAction();
      },
      update: function(prevData) {
        if (!prevData) return;
        const data = this.data;
        const changes = AFRAME.utils.diff(data, prevData);
        if ("clip" in changes) {
          this.stopAction();
          if (data.clip) this.playAction();
          return;
        }
        this.activeActions.forEach((action) => {
          if ("duration" in changes && data.duration) {
            action.setDuration(data.duration);
          }
          if ("clampWhenFinished" in changes) {
            action.clampWhenFinished = data.clampWhenFinished;
          }
          if ("loop" in changes || "repetitions" in changes) {
            action.setLoop(LoopMode[data.loop], data.repetitions);
          }
          if ("timeScale" in changes) {
            action.setEffectiveTimeScale(data.timeScale);
          }
        });
      },
      stopAction: function() {
        const data = this.data;
        for (let i = 0; i < this.activeActions.length; i++) {
          data.crossFadeDuration ? this.activeActions[i].fadeOut(data.crossFadeDuration) : this.activeActions[i].stop();
        }
        this.activeActions.length = 0;
      },
      playAction: function() {
        if (!this.mixer) return;
        const model = this.model, data = this.data, clips = model.animations || (model.geometry || {}).animations || [];
        if (!clips.length) return;
        const re = data.useRegExp ? data.clip : wildcardToRegExp(data.clip);
        for (let clip, i = 0; clip = clips[i]; i++) {
          if (clip.name.match(re)) {
            const action = this.mixer.clipAction(clip, model);
            action.enabled = true;
            action.clampWhenFinished = data.clampWhenFinished;
            if (data.duration) action.setDuration(data.duration);
            if (data.timeScale !== 1) action.setEffectiveTimeScale(data.timeScale);
            action.startAt(this.mixer.time - data.startAt / 1e3);
            action.setLoop(LoopMode[data.loop], data.repetitions).fadeIn(data.crossFadeDuration).play();
            this.activeActions.push(action);
          }
        }
      },
      tick: function(t, dt) {
        if (this.mixer && !isNaN(dt)) this.mixer.update(dt / 1e3);
      }
    });
    function wildcardToRegExp(s) {
      return new RegExp("^" + s.split(/\*+/).map(regExpEscape).join(".*") + "$");
    }
    function regExpEscape(s) {
      return s.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
    }
  }
});

// node_modules/aframe-extras/lib/ColladaLoader.js
var require_ColladaLoader = __commonJS({
  "node_modules/aframe-extras/lib/ColladaLoader.js"(exports, module) {
    module.exports = THREE.ColladaLoader = function(manager) {
      this.manager = manager !== void 0 ? manager : THREE.DefaultLoadingManager;
    };
    THREE.ColladaLoader.prototype = {
      constructor: THREE.ColladaLoader,
      crossOrigin: "anonymous",
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = scope.path === void 0 ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;
        var loader = new THREE.FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.load(url, function(text) {
          onLoad(scope.parse(text, path));
        }, onProgress, onError);
      },
      setPath: function(value) {
        this.path = value;
        return this;
      },
      setResourcePath: function(value) {
        this.resourcePath = value;
        return this;
      },
      options: {
        set convertUpAxis(value) {
          console.warn("THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.");
        }
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
        return this;
      },
      parse: function(text, path) {
        function getElementsByTagName(xml2, name) {
          var array = [];
          var childNodes = xml2.childNodes;
          for (var i = 0, l = childNodes.length; i < l; i++) {
            var child = childNodes[i];
            if (child.nodeName === name) {
              array.push(child);
            }
          }
          return array;
        }
        function parseStrings(text2) {
          if (text2.length === 0) return [];
          var parts = text2.trim().split(/\s+/);
          var array = new Array(parts.length);
          for (var i = 0, l = parts.length; i < l; i++) {
            array[i] = parts[i];
          }
          return array;
        }
        function parseFloats(text2) {
          if (text2.length === 0) return [];
          var parts = text2.trim().split(/\s+/);
          var array = new Array(parts.length);
          for (var i = 0, l = parts.length; i < l; i++) {
            array[i] = parseFloat(parts[i]);
          }
          return array;
        }
        function parseInts(text2) {
          if (text2.length === 0) return [];
          var parts = text2.trim().split(/\s+/);
          var array = new Array(parts.length);
          for (var i = 0, l = parts.length; i < l; i++) {
            array[i] = parseInt(parts[i]);
          }
          return array;
        }
        function parseId(text2) {
          return text2.substring(1);
        }
        function generateId() {
          return "three_default_" + count++;
        }
        function isEmpty(object) {
          return Object.keys(object).length === 0;
        }
        function parseAsset(xml2) {
          return {
            unit: parseAssetUnit(getElementsByTagName(xml2, "unit")[0]),
            upAxis: parseAssetUpAxis(getElementsByTagName(xml2, "up_axis")[0])
          };
        }
        function parseAssetUnit(xml2) {
          if (xml2 !== void 0 && xml2.hasAttribute("meter") === true) {
            return parseFloat(xml2.getAttribute("meter"));
          } else {
            return 1;
          }
        }
        function parseAssetUpAxis(xml2) {
          return xml2 !== void 0 ? xml2.textContent : "Y_UP";
        }
        function parseLibrary(xml2, libraryName, nodeName, parser) {
          var library2 = getElementsByTagName(xml2, libraryName)[0];
          if (library2 !== void 0) {
            var elements = getElementsByTagName(library2, nodeName);
            for (var i = 0; i < elements.length; i++) {
              parser(elements[i]);
            }
          }
        }
        function buildLibrary(data, builder) {
          for (var name in data) {
            var object = data[name];
            object.build = builder(data[name]);
          }
        }
        function getBuild(data, builder) {
          if (data.build !== void 0) return data.build;
          data.build = builder(data);
          return data.build;
        }
        function parseAnimation(xml2) {
          var data = {
            sources: {},
            samplers: {},
            channels: {}
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            var id;
            switch (child.nodeName) {
              case "source":
                id = child.getAttribute("id");
                data.sources[id] = parseSource(child);
                break;
              case "sampler":
                id = child.getAttribute("id");
                data.samplers[id] = parseAnimationSampler(child);
                break;
              case "channel":
                id = child.getAttribute("target");
                data.channels[id] = parseAnimationChannel(child);
                break;
              default:
                console.log(child);
            }
          }
          library.animations[xml2.getAttribute("id")] = data;
        }
        function parseAnimationSampler(xml2) {
          var data = {
            inputs: {}
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "input":
                var id = parseId(child.getAttribute("source"));
                var semantic = child.getAttribute("semantic");
                data.inputs[semantic] = id;
                break;
            }
          }
          return data;
        }
        function parseAnimationChannel(xml2) {
          var data = {};
          var target = xml2.getAttribute("target");
          var parts = target.split("/");
          var id = parts.shift();
          var sid = parts.shift();
          var arraySyntax = sid.indexOf("(") !== -1;
          var memberSyntax = sid.indexOf(".") !== -1;
          if (memberSyntax) {
            parts = sid.split(".");
            sid = parts.shift();
            data.member = parts.shift();
          } else if (arraySyntax) {
            var indices = sid.split("(");
            sid = indices.shift();
            for (var i = 0; i < indices.length; i++) {
              indices[i] = parseInt(indices[i].replace(/\)/, ""));
            }
            data.indices = indices;
          }
          data.id = id;
          data.sid = sid;
          data.arraySyntax = arraySyntax;
          data.memberSyntax = memberSyntax;
          data.sampler = parseId(xml2.getAttribute("source"));
          return data;
        }
        function buildAnimation(data) {
          var tracks = [];
          var channels = data.channels;
          var samplers = data.samplers;
          var sources = data.sources;
          for (var target in channels) {
            if (channels.hasOwnProperty(target)) {
              var channel = channels[target];
              var sampler = samplers[channel.sampler];
              var inputId = sampler.inputs.INPUT;
              var outputId = sampler.inputs.OUTPUT;
              var inputSource = sources[inputId];
              var outputSource = sources[outputId];
              var animation = buildAnimationChannel(channel, inputSource, outputSource);
              createKeyframeTracks(animation, tracks);
            }
          }
          return tracks;
        }
        function getAnimation(id) {
          return getBuild(library.animations[id], buildAnimation);
        }
        function buildAnimationChannel(channel, inputSource, outputSource) {
          var node = library.nodes[channel.id];
          var object3D = getNode(node.id);
          var transform = node.transforms[channel.sid];
          var defaultMatrix = node.matrix.clone().transpose();
          var time, stride;
          var i, il, j, jl;
          var data = {};
          switch (transform) {
            case "matrix":
              for (i = 0, il = inputSource.array.length; i < il; i++) {
                time = inputSource.array[i];
                stride = i * outputSource.stride;
                if (data[time] === void 0) data[time] = {};
                if (channel.arraySyntax === true) {
                  var value = outputSource.array[stride];
                  var index = channel.indices[0] + 4 * channel.indices[1];
                  data[time][index] = value;
                } else {
                  for (j = 0, jl = outputSource.stride; j < jl; j++) {
                    data[time][j] = outputSource.array[stride + j];
                  }
                }
              }
              break;
            case "translate":
              console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
              break;
            case "rotate":
              console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
              break;
            case "scale":
              console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', transform);
              break;
          }
          var keyframes = prepareAnimationData(data, defaultMatrix);
          var animation = {
            name: object3D.uuid,
            keyframes
          };
          return animation;
        }
        function prepareAnimationData(data, defaultMatrix) {
          var keyframes = [];
          for (var time in data) {
            keyframes.push({ time: parseFloat(time), value: data[time] });
          }
          keyframes.sort(ascending);
          for (var i = 0; i < 16; i++) {
            transformAnimationData(keyframes, i, defaultMatrix.elements[i]);
          }
          return keyframes;
          function ascending(a, b) {
            return a.time - b.time;
          }
        }
        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();
        function createKeyframeTracks(animation, tracks) {
          var keyframes = animation.keyframes;
          var name = animation.name;
          var times = [];
          var positionData = [];
          var quaternionData = [];
          var scaleData = [];
          for (var i = 0, l = keyframes.length; i < l; i++) {
            var keyframe = keyframes[i];
            var time = keyframe.time;
            var value = keyframe.value;
            matrix.fromArray(value).transpose();
            matrix.decompose(position, quaternion, scale);
            times.push(time);
            positionData.push(position.x, position.y, position.z);
            quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
            scaleData.push(scale.x, scale.y, scale.z);
          }
          if (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + ".position", times, positionData));
          if (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + ".quaternion", times, quaternionData));
          if (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + ".scale", times, scaleData));
          return tracks;
        }
        function transformAnimationData(keyframes, property, defaultValue) {
          var keyframe;
          var empty = true;
          var i, l;
          for (i = 0, l = keyframes.length; i < l; i++) {
            keyframe = keyframes[i];
            if (keyframe.value[property] === void 0) {
              keyframe.value[property] = null;
            } else {
              empty = false;
            }
          }
          if (empty === true) {
            for (i = 0, l = keyframes.length; i < l; i++) {
              keyframe = keyframes[i];
              keyframe.value[property] = defaultValue;
            }
          } else {
            createMissingKeyframes(keyframes, property);
          }
        }
        function createMissingKeyframes(keyframes, property) {
          var prev, next;
          for (var i = 0, l = keyframes.length; i < l; i++) {
            var keyframe = keyframes[i];
            if (keyframe.value[property] === null) {
              prev = getPrev(keyframes, i, property);
              next = getNext(keyframes, i, property);
              if (prev === null) {
                keyframe.value[property] = next.value[property];
                continue;
              }
              if (next === null) {
                keyframe.value[property] = prev.value[property];
                continue;
              }
              interpolate(keyframe, prev, next, property);
            }
          }
        }
        function getPrev(keyframes, i, property) {
          while (i >= 0) {
            var keyframe = keyframes[i];
            if (keyframe.value[property] !== null) return keyframe;
            i--;
          }
          return null;
        }
        function getNext(keyframes, i, property) {
          while (i < keyframes.length) {
            var keyframe = keyframes[i];
            if (keyframe.value[property] !== null) return keyframe;
            i++;
          }
          return null;
        }
        function interpolate(key, prev, next, property) {
          if (next.time - prev.time === 0) {
            key.value[property] = prev.value[property];
            return;
          }
          key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];
        }
        function parseAnimationClip(xml2) {
          var data = {
            name: xml2.getAttribute("id") || "default",
            start: parseFloat(xml2.getAttribute("start") || 0),
            end: parseFloat(xml2.getAttribute("end") || 0),
            animations: []
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "instance_animation":
                data.animations.push(parseId(child.getAttribute("url")));
                break;
            }
          }
          library.clips[xml2.getAttribute("id")] = data;
        }
        function buildAnimationClip(data) {
          var tracks = [];
          var name = data.name;
          var duration = data.end - data.start || -1;
          var animations2 = data.animations;
          for (var i = 0, il = animations2.length; i < il; i++) {
            var animationTracks = getAnimation(animations2[i]);
            for (var j = 0, jl = animationTracks.length; j < jl; j++) {
              tracks.push(animationTracks[j]);
            }
          }
          return new THREE.AnimationClip(name, duration, tracks);
        }
        function getAnimationClip(id) {
          return getBuild(library.clips[id], buildAnimationClip);
        }
        function parseController(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "skin":
                data.id = parseId(child.getAttribute("source"));
                data.skin = parseSkin(child);
                break;
              case "morph":
                data.id = parseId(child.getAttribute("source"));
                console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
                break;
            }
          }
          library.controllers[xml2.getAttribute("id")] = data;
        }
        function parseSkin(xml2) {
          var data = {
            sources: {}
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "bind_shape_matrix":
                data.bindShapeMatrix = parseFloats(child.textContent);
                break;
              case "source":
                var id = child.getAttribute("id");
                data.sources[id] = parseSource(child);
                break;
              case "joints":
                data.joints = parseJoints(child);
                break;
              case "vertex_weights":
                data.vertexWeights = parseVertexWeights(child);
                break;
            }
          }
          return data;
        }
        function parseJoints(xml2) {
          var data = {
            inputs: {}
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "input":
                var semantic = child.getAttribute("semantic");
                var id = parseId(child.getAttribute("source"));
                data.inputs[semantic] = id;
                break;
            }
          }
          return data;
        }
        function parseVertexWeights(xml2) {
          var data = {
            inputs: {}
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "input":
                var semantic = child.getAttribute("semantic");
                var id = parseId(child.getAttribute("source"));
                var offset = parseInt(child.getAttribute("offset"));
                data.inputs[semantic] = { id, offset };
                break;
              case "vcount":
                data.vcount = parseInts(child.textContent);
                break;
              case "v":
                data.v = parseInts(child.textContent);
                break;
            }
          }
          return data;
        }
        function buildController(data) {
          var build = {
            id: data.id
          };
          var geometry = library.geometries[build.id];
          if (data.skin !== void 0) {
            build.skin = buildSkin(data.skin);
            geometry.sources.skinIndices = build.skin.indices;
            geometry.sources.skinWeights = build.skin.weights;
          }
          return build;
        }
        function buildSkin(data) {
          var BONE_LIMIT = 4;
          var build = {
            joints: [],
            // this must be an array to preserve the joint order
            indices: {
              array: [],
              stride: BONE_LIMIT
            },
            weights: {
              array: [],
              stride: BONE_LIMIT
            }
          };
          var sources = data.sources;
          var vertexWeights = data.vertexWeights;
          var vcount = vertexWeights.vcount;
          var v2 = vertexWeights.v;
          var jointOffset = vertexWeights.inputs.JOINT.offset;
          var weightOffset = vertexWeights.inputs.WEIGHT.offset;
          var jointSource = data.sources[data.joints.inputs.JOINT];
          var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];
          var weights = sources[vertexWeights.inputs.WEIGHT.id].array;
          var stride = 0;
          var i, j, l;
          for (i = 0, l = vcount.length; i < l; i++) {
            var jointCount = vcount[i];
            var vertexSkinData = [];
            for (j = 0; j < jointCount; j++) {
              var skinIndex = v2[stride + jointOffset];
              var weightId = v2[stride + weightOffset];
              var skinWeight = weights[weightId];
              vertexSkinData.push({ index: skinIndex, weight: skinWeight });
              stride += 2;
            }
            vertexSkinData.sort(descending);
            for (j = 0; j < BONE_LIMIT; j++) {
              var d2 = vertexSkinData[j];
              if (d2 !== void 0) {
                build.indices.array.push(d2.index);
                build.weights.array.push(d2.weight);
              } else {
                build.indices.array.push(0);
                build.weights.array.push(0);
              }
            }
          }
          if (data.bindShapeMatrix) {
            build.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();
          } else {
            build.bindMatrix = new THREE.Matrix4().identity();
          }
          for (i = 0, l = jointSource.array.length; i < l; i++) {
            var name = jointSource.array[i];
            var boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();
            build.joints.push({ name, boneInverse });
          }
          return build;
          function descending(a, b) {
            return b.weight - a.weight;
          }
        }
        function getController(id) {
          return getBuild(library.controllers[id], buildController);
        }
        function parseImage(xml2) {
          var data = {
            init_from: getElementsByTagName(xml2, "init_from")[0].textContent
          };
          library.images[xml2.getAttribute("id")] = data;
        }
        function buildImage(data) {
          if (data.build !== void 0) return data.build;
          return data.init_from;
        }
        function getImage(id) {
          var data = library.images[id];
          if (data !== void 0) {
            return getBuild(data, buildImage);
          }
          console.warn("THREE.ColladaLoader: Couldn't find image with ID:", id);
          return null;
        }
        function parseEffect(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "profile_COMMON":
                data.profile = parseEffectProfileCOMMON(child);
                break;
            }
          }
          library.effects[xml2.getAttribute("id")] = data;
        }
        function parseEffectProfileCOMMON(xml2) {
          var data = {
            surfaces: {},
            samplers: {}
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "newparam":
                parseEffectNewparam(child, data);
                break;
              case "technique":
                data.technique = parseEffectTechnique(child);
                break;
              case "extra":
                data.extra = parseEffectExtra(child);
                break;
            }
          }
          return data;
        }
        function parseEffectNewparam(xml2, data) {
          var sid = xml2.getAttribute("sid");
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "surface":
                data.surfaces[sid] = parseEffectSurface(child);
                break;
              case "sampler2D":
                data.samplers[sid] = parseEffectSampler(child);
                break;
            }
          }
        }
        function parseEffectSurface(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "init_from":
                data.init_from = child.textContent;
                break;
            }
          }
          return data;
        }
        function parseEffectSampler(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "source":
                data.source = child.textContent;
                break;
            }
          }
          return data;
        }
        function parseEffectTechnique(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "constant":
              case "lambert":
              case "blinn":
              case "phong":
                data.type = child.nodeName;
                data.parameters = parseEffectParameters(child);
                break;
            }
          }
          return data;
        }
        function parseEffectParameters(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "emission":
              case "diffuse":
              case "specular":
              case "bump":
              case "ambient":
              case "shininess":
              case "transparency":
                data[child.nodeName] = parseEffectParameter(child);
                break;
              case "transparent":
                data[child.nodeName] = {
                  opaque: child.getAttribute("opaque"),
                  data: parseEffectParameter(child)
                };
                break;
            }
          }
          return data;
        }
        function parseEffectParameter(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "color":
                data[child.nodeName] = parseFloats(child.textContent);
                break;
              case "float":
                data[child.nodeName] = parseFloat(child.textContent);
                break;
              case "texture":
                data[child.nodeName] = { id: child.getAttribute("texture"), extra: parseEffectParameterTexture(child) };
                break;
            }
          }
          return data;
        }
        function parseEffectParameterTexture(xml2) {
          var data = {
            technique: {}
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "extra":
                parseEffectParameterTextureExtra(child, data);
                break;
            }
          }
          return data;
        }
        function parseEffectParameterTextureExtra(xml2, data) {
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "technique":
                parseEffectParameterTextureExtraTechnique(child, data);
                break;
            }
          }
        }
        function parseEffectParameterTextureExtraTechnique(xml2, data) {
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "repeatU":
              case "repeatV":
              case "offsetU":
              case "offsetV":
                data.technique[child.nodeName] = parseFloat(child.textContent);
                break;
              case "wrapU":
              case "wrapV":
                if (child.textContent.toUpperCase() === "TRUE") {
                  data.technique[child.nodeName] = 1;
                } else if (child.textContent.toUpperCase() === "FALSE") {
                  data.technique[child.nodeName] = 0;
                } else {
                  data.technique[child.nodeName] = parseInt(child.textContent);
                }
                break;
            }
          }
        }
        function parseEffectExtra(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "technique":
                data.technique = parseEffectExtraTechnique(child);
                break;
            }
          }
          return data;
        }
        function parseEffectExtraTechnique(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "double_sided":
                data[child.nodeName] = parseInt(child.textContent);
                break;
            }
          }
          return data;
        }
        function buildEffect(data) {
          return data;
        }
        function getEffect(id) {
          return getBuild(library.effects[id], buildEffect);
        }
        function parseMaterial(xml2) {
          var data = {
            name: xml2.getAttribute("name")
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "instance_effect":
                data.url = parseId(child.getAttribute("url"));
                break;
            }
          }
          library.materials[xml2.getAttribute("id")] = data;
        }
        function getTextureLoader(image) {
          var loader;
          var extension = image.slice((image.lastIndexOf(".") - 1 >>> 0) + 2);
          extension = extension.toLowerCase();
          switch (extension) {
            case "tga":
              loader = tgaLoader;
              break;
            default:
              loader = textureLoader;
          }
          return loader;
        }
        function buildMaterial(data) {
          var effect = getEffect(data.url);
          var technique = effect.profile.technique;
          var extra = effect.profile.extra;
          var material;
          switch (technique.type) {
            case "phong":
            case "blinn":
              material = new THREE.MeshPhongMaterial();
              break;
            case "lambert":
              material = new THREE.MeshLambertMaterial();
              break;
            default:
              material = new THREE.MeshBasicMaterial();
              break;
          }
          material.name = data.name;
          function getTexture(textureObject) {
            var sampler = effect.profile.samplers[textureObject.id];
            var image = null;
            if (sampler !== void 0) {
              var surface = effect.profile.surfaces[sampler.source];
              image = getImage(surface.init_from);
            } else {
              console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).");
              image = getImage(textureObject.id);
            }
            if (image !== null) {
              var loader = getTextureLoader(image);
              if (loader !== void 0) {
                var texture = loader.load(image);
                var extra2 = textureObject.extra;
                if (extra2 !== void 0 && extra2.technique !== void 0 && isEmpty(extra2.technique) === false) {
                  var technique2 = extra2.technique;
                  texture.wrapS = technique2.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                  texture.wrapT = technique2.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                  texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);
                  texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);
                } else {
                  texture.wrapS = THREE.RepeatWrapping;
                  texture.wrapT = THREE.RepeatWrapping;
                }
                return texture;
              } else {
                console.warn("THREE.ColladaLoader: Loader for texture %s not found.", image);
                return null;
              }
            } else {
              console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", textureObject.id);
              return null;
            }
          }
          var parameters = technique.parameters;
          for (var key in parameters) {
            var parameter = parameters[key];
            switch (key) {
              case "diffuse":
                if (parameter.color) material.color.fromArray(parameter.color);
                if (parameter.texture) material.map = getTexture(parameter.texture);
                break;
              case "specular":
                if (parameter.color && material.specular) material.specular.fromArray(parameter.color);
                if (parameter.texture) material.specularMap = getTexture(parameter.texture);
                break;
              case "bump":
                if (parameter.texture) material.normalMap = getTexture(parameter.texture);
                break;
              case "ambient":
                if (parameter.texture) material.lightMap = getTexture(parameter.texture);
                break;
              case "shininess":
                if (parameter.float && material.shininess) material.shininess = parameter.float;
                break;
              case "emission":
                if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);
                if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);
                break;
            }
          }
          var transparent = parameters["transparent"];
          var transparency = parameters["transparency"];
          if (transparency === void 0 && transparent) {
            transparency = {
              float: 1
            };
          }
          if (transparent === void 0 && transparency) {
            transparent = {
              opaque: "A_ONE",
              data: {
                color: [1, 1, 1, 1]
              }
            };
          }
          if (transparent && transparency) {
            if (transparent.data.texture) {
              material.transparent = true;
            } else {
              var color = transparent.data.color;
              switch (transparent.opaque) {
                case "A_ONE":
                  material.opacity = color[3] * transparency.float;
                  break;
                case "RGB_ZERO":
                  material.opacity = 1 - color[0] * transparency.float;
                  break;
                case "A_ZERO":
                  material.opacity = 1 - color[3] * transparency.float;
                  break;
                case "RGB_ONE":
                  material.opacity = color[0] * transparency.float;
                  break;
                default:
                  console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', transparent.opaque);
              }
              if (material.opacity < 1) material.transparent = true;
            }
          }
          if (extra !== void 0 && extra.technique !== void 0 && extra.technique.double_sided === 1) {
            material.side = THREE.DoubleSide;
          }
          return material;
        }
        function getMaterial(id) {
          return getBuild(library.materials[id], buildMaterial);
        }
        function parseCamera(xml2) {
          var data = {
            name: xml2.getAttribute("name")
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "optics":
                data.optics = parseCameraOptics(child);
                break;
            }
          }
          library.cameras[xml2.getAttribute("id")] = data;
        }
        function parseCameraOptics(xml2) {
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            switch (child.nodeName) {
              case "technique_common":
                return parseCameraTechnique(child);
            }
          }
          return {};
        }
        function parseCameraTechnique(xml2) {
          var data = {};
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            switch (child.nodeName) {
              case "perspective":
              case "orthographic":
                data.technique = child.nodeName;
                data.parameters = parseCameraParameters(child);
                break;
            }
          }
          return data;
        }
        function parseCameraParameters(xml2) {
          var data = {};
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            switch (child.nodeName) {
              case "xfov":
              case "yfov":
              case "xmag":
              case "ymag":
              case "znear":
              case "zfar":
              case "aspect_ratio":
                data[child.nodeName] = parseFloat(child.textContent);
                break;
            }
          }
          return data;
        }
        function buildCamera(data) {
          var camera;
          switch (data.optics.technique) {
            case "perspective":
              camera = new THREE.PerspectiveCamera(
                data.optics.parameters.yfov,
                data.optics.parameters.aspect_ratio,
                data.optics.parameters.znear,
                data.optics.parameters.zfar
              );
              break;
            case "orthographic":
              var ymag = data.optics.parameters.ymag;
              var xmag = data.optics.parameters.xmag;
              var aspectRatio = data.optics.parameters.aspect_ratio;
              xmag = xmag === void 0 ? ymag * aspectRatio : xmag;
              ymag = ymag === void 0 ? xmag / aspectRatio : ymag;
              xmag *= 0.5;
              ymag *= 0.5;
              camera = new THREE.OrthographicCamera(
                -xmag,
                xmag,
                ymag,
                -ymag,
                // left, right, top, bottom
                data.optics.parameters.znear,
                data.optics.parameters.zfar
              );
              break;
            default:
              camera = new THREE.PerspectiveCamera();
              break;
          }
          camera.name = data.name;
          return camera;
        }
        function getCamera(id) {
          var data = library.cameras[id];
          if (data !== void 0) {
            return getBuild(data, buildCamera);
          }
          console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", id);
          return null;
        }
        function parseLight(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "technique_common":
                data = parseLightTechnique(child);
                break;
            }
          }
          library.lights[xml2.getAttribute("id")] = data;
        }
        function parseLightTechnique(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "directional":
              case "point":
              case "spot":
              case "ambient":
                data.technique = child.nodeName;
                data.parameters = parseLightParameters(child);
            }
          }
          return data;
        }
        function parseLightParameters(xml2) {
          var data = {};
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "color":
                var array = parseFloats(child.textContent);
                data.color = new THREE.Color().fromArray(array);
                break;
              case "falloff_angle":
                data.falloffAngle = parseFloat(child.textContent);
                break;
              case "quadratic_attenuation":
                var f2 = parseFloat(child.textContent);
                data.distance = f2 ? Math.sqrt(1 / f2) : 0;
                break;
            }
          }
          return data;
        }
        function buildLight(data) {
          var light;
          switch (data.technique) {
            case "directional":
              light = new THREE.DirectionalLight();
              break;
            case "point":
              light = new THREE.PointLight();
              break;
            case "spot":
              light = new THREE.SpotLight();
              break;
            case "ambient":
              light = new THREE.AmbientLight();
              break;
          }
          if (data.parameters.color) light.color.copy(data.parameters.color);
          if (data.parameters.distance) light.distance = data.parameters.distance;
          return light;
        }
        function getLight(id) {
          var data = library.lights[id];
          if (data !== void 0) {
            return getBuild(data, buildLight);
          }
          console.warn("THREE.ColladaLoader: Couldn't find light with ID:", id);
          return null;
        }
        function parseGeometry(xml2) {
          var data = {
            name: xml2.getAttribute("name"),
            sources: {},
            vertices: {},
            primitives: []
          };
          var mesh = getElementsByTagName(xml2, "mesh")[0];
          if (mesh === void 0) return;
          for (var i = 0; i < mesh.childNodes.length; i++) {
            var child = mesh.childNodes[i];
            if (child.nodeType !== 1) continue;
            var id = child.getAttribute("id");
            switch (child.nodeName) {
              case "source":
                data.sources[id] = parseSource(child);
                break;
              case "vertices":
                data.vertices = parseGeometryVertices(child);
                break;
              case "polygons":
                console.warn("THREE.ColladaLoader: Unsupported primitive type: ", child.nodeName);
                break;
              case "lines":
              case "linestrips":
              case "polylist":
              case "triangles":
                data.primitives.push(parseGeometryPrimitive(child));
                break;
              default:
                console.log(child);
            }
          }
          library.geometries[xml2.getAttribute("id")] = data;
        }
        function parseSource(xml2) {
          var data = {
            array: [],
            stride: 3
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "float_array":
                data.array = parseFloats(child.textContent);
                break;
              case "Name_array":
                data.array = parseStrings(child.textContent);
                break;
              case "technique_common":
                var accessor = getElementsByTagName(child, "accessor")[0];
                if (accessor !== void 0) {
                  data.stride = parseInt(accessor.getAttribute("stride"));
                }
                break;
            }
          }
          return data;
        }
        function parseGeometryVertices(xml2) {
          var data = {};
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            data[child.getAttribute("semantic")] = parseId(child.getAttribute("source"));
          }
          return data;
        }
        function parseGeometryPrimitive(xml2) {
          var primitive = {
            type: xml2.nodeName,
            material: xml2.getAttribute("material"),
            count: parseInt(xml2.getAttribute("count")),
            inputs: {},
            stride: 0,
            hasUV: false
          };
          for (var i = 0, l = xml2.childNodes.length; i < l; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "input":
                var id = parseId(child.getAttribute("source"));
                var semantic = child.getAttribute("semantic");
                var offset = parseInt(child.getAttribute("offset"));
                var set = parseInt(child.getAttribute("set"));
                var inputname = set > 0 ? semantic + set : semantic;
                primitive.inputs[inputname] = { id, offset };
                primitive.stride = Math.max(primitive.stride, offset + 1);
                if (semantic === "TEXCOORD") primitive.hasUV = true;
                break;
              case "vcount":
                primitive.vcount = parseInts(child.textContent);
                break;
              case "p":
                primitive.p = parseInts(child.textContent);
                break;
            }
          }
          return primitive;
        }
        function groupPrimitives(primitives) {
          var build = {};
          for (var i = 0; i < primitives.length; i++) {
            var primitive = primitives[i];
            if (build[primitive.type] === void 0) build[primitive.type] = [];
            build[primitive.type].push(primitive);
          }
          return build;
        }
        function checkUVCoordinates(primitives) {
          var count2 = 0;
          for (var i = 0, l = primitives.length; i < l; i++) {
            var primitive = primitives[i];
            if (primitive.hasUV === true) {
              count2++;
            }
          }
          if (count2 > 0 && count2 < primitives.length) {
            primitives.uvsNeedsFix = true;
          }
        }
        function buildGeometry(data) {
          var build = {};
          var sources = data.sources;
          var vertices = data.vertices;
          var primitives = data.primitives;
          if (primitives.length === 0) return {};
          var groupedPrimitives = groupPrimitives(primitives);
          for (var type in groupedPrimitives) {
            var primitiveType = groupedPrimitives[type];
            checkUVCoordinates(primitiveType);
            build[type] = buildGeometryType(primitiveType, sources, vertices);
          }
          return build;
        }
        function buildGeometryType(primitives, sources, vertices) {
          var build = {};
          var position2 = { array: [], stride: 0 };
          var normal = { array: [], stride: 0 };
          var uv = { array: [], stride: 0 };
          var uv2 = { array: [], stride: 0 };
          var color = { array: [], stride: 0 };
          var skinIndex = { array: [], stride: 4 };
          var skinWeight = { array: [], stride: 4 };
          var geometry = new THREE.BufferGeometry();
          var materialKeys = [];
          var start = 0;
          for (var p2 = 0; p2 < primitives.length; p2++) {
            var primitive = primitives[p2];
            var inputs = primitive.inputs;
            var count2 = 0;
            switch (primitive.type) {
              case "lines":
              case "linestrips":
                count2 = primitive.count * 2;
                break;
              case "triangles":
                count2 = primitive.count * 3;
                break;
              case "polylist":
                for (var g2 = 0; g2 < primitive.count; g2++) {
                  var vc = primitive.vcount[g2];
                  switch (vc) {
                    case 3:
                      count2 += 3;
                      break;
                    case 4:
                      count2 += 6;
                      break;
                    default:
                      count2 += (vc - 2) * 3;
                      break;
                  }
                }
                break;
              default:
                console.warn("THREE.ColladaLoader: Unknow primitive type:", primitive.type);
            }
            geometry.addGroup(start, count2, p2);
            start += count2;
            if (primitive.material) {
              materialKeys.push(primitive.material);
            }
            for (var name in inputs) {
              var input = inputs[name];
              switch (name) {
                case "VERTEX":
                  for (var key in vertices) {
                    var id = vertices[key];
                    switch (key) {
                      case "POSITION":
                        var prevLength = position2.array.length;
                        buildGeometryData(primitive, sources[id], input.offset, position2.array);
                        position2.stride = sources[id].stride;
                        if (sources.skinWeights && sources.skinIndices) {
                          buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);
                          buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);
                        }
                        if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {
                          var count2 = (position2.array.length - prevLength) / position2.stride;
                          for (var i = 0; i < count2; i++) {
                            uv.array.push(0, 0);
                          }
                        }
                        break;
                      case "NORMAL":
                        buildGeometryData(primitive, sources[id], input.offset, normal.array);
                        normal.stride = sources[id].stride;
                        break;
                      case "COLOR":
                        buildGeometryData(primitive, sources[id], input.offset, color.array);
                        color.stride = sources[id].stride;
                        break;
                      case "TEXCOORD":
                        buildGeometryData(primitive, sources[id], input.offset, uv.array);
                        uv.stride = sources[id].stride;
                        break;
                      case "TEXCOORD1":
                        buildGeometryData(primitive, sources[id], input.offset, uv2.array);
                        uv.stride = sources[id].stride;
                        break;
                      default:
                        console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', key);
                    }
                  }
                  break;
                case "NORMAL":
                  buildGeometryData(primitive, sources[input.id], input.offset, normal.array);
                  normal.stride = sources[input.id].stride;
                  break;
                case "COLOR":
                  buildGeometryData(primitive, sources[input.id], input.offset, color.array);
                  color.stride = sources[input.id].stride;
                  break;
                case "TEXCOORD":
                  buildGeometryData(primitive, sources[input.id], input.offset, uv.array);
                  uv.stride = sources[input.id].stride;
                  break;
                case "TEXCOORD1":
                  buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);
                  uv2.stride = sources[input.id].stride;
                  break;
              }
            }
          }
          if (position2.array.length > 0) geometry.addAttribute("position", new THREE.Float32BufferAttribute(position2.array, position2.stride));
          if (normal.array.length > 0) geometry.addAttribute("normal", new THREE.Float32BufferAttribute(normal.array, normal.stride));
          if (color.array.length > 0) geometry.addAttribute("color", new THREE.Float32BufferAttribute(color.array, color.stride));
          if (uv.array.length > 0) geometry.addAttribute("uv", new THREE.Float32BufferAttribute(uv.array, uv.stride));
          if (uv2.array.length > 0) geometry.addAttribute("uv2", new THREE.Float32BufferAttribute(uv2.array, uv2.stride));
          if (skinIndex.array.length > 0) geometry.addAttribute("skinIndex", new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));
          if (skinWeight.array.length > 0) geometry.addAttribute("skinWeight", new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));
          build.data = geometry;
          build.type = primitives[0].type;
          build.materialKeys = materialKeys;
          return build;
        }
        function buildGeometryData(primitive, source, offset, array) {
          var indices = primitive.p;
          var stride = primitive.stride;
          var vcount = primitive.vcount;
          function pushVector(i2) {
            var index2 = indices[i2 + offset] * sourceStride;
            var length = index2 + sourceStride;
            for (; index2 < length; index2++) {
              array.push(sourceArray[index2]);
            }
          }
          var sourceArray = source.array;
          var sourceStride = source.stride;
          if (primitive.vcount !== void 0) {
            var index = 0;
            for (var i = 0, l = vcount.length; i < l; i++) {
              var count2 = vcount[i];
              if (count2 === 4) {
                var a = index + stride * 0;
                var b = index + stride * 1;
                var c = index + stride * 2;
                var d2 = index + stride * 3;
                pushVector(a);
                pushVector(b);
                pushVector(d2);
                pushVector(b);
                pushVector(c);
                pushVector(d2);
              } else if (count2 === 3) {
                var a = index + stride * 0;
                var b = index + stride * 1;
                var c = index + stride * 2;
                pushVector(a);
                pushVector(b);
                pushVector(c);
              } else if (count2 > 4) {
                for (var k = 1, kl = count2 - 2; k <= kl; k++) {
                  var a = index + stride * 0;
                  var b = index + stride * k;
                  var c = index + stride * (k + 1);
                  pushVector(a);
                  pushVector(b);
                  pushVector(c);
                }
              }
              index += stride * count2;
            }
          } else {
            for (var i = 0, l = indices.length; i < l; i += stride) {
              pushVector(i);
            }
          }
        }
        function getGeometry(id) {
          return getBuild(library.geometries[id], buildGeometry);
        }
        function parseKinematicsModel(xml2) {
          var data = {
            name: xml2.getAttribute("name") || "",
            joints: {},
            links: []
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "technique_common":
                parseKinematicsTechniqueCommon(child, data);
                break;
            }
          }
          library.kinematicsModels[xml2.getAttribute("id")] = data;
        }
        function buildKinematicsModel(data) {
          if (data.build !== void 0) return data.build;
          return data;
        }
        function getKinematicsModel(id) {
          return getBuild(library.kinematicsModels[id], buildKinematicsModel);
        }
        function parseKinematicsTechniqueCommon(xml2, data) {
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "joint":
                data.joints[child.getAttribute("sid")] = parseKinematicsJoint(child);
                break;
              case "link":
                data.links.push(parseKinematicsLink(child));
                break;
            }
          }
        }
        function parseKinematicsJoint(xml2) {
          var data;
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "prismatic":
              case "revolute":
                data = parseKinematicsJointParameter(child);
                break;
            }
          }
          return data;
        }
        function parseKinematicsJointParameter(xml2, data) {
          var data = {
            sid: xml2.getAttribute("sid"),
            name: xml2.getAttribute("name") || "",
            axis: new THREE.Vector3(),
            limits: {
              min: 0,
              max: 0
            },
            type: xml2.nodeName,
            static: false,
            zeroPosition: 0,
            middlePosition: 0
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "axis":
                var array = parseFloats(child.textContent);
                data.axis.fromArray(array);
                break;
              case "limits":
                var max2 = child.getElementsByTagName("max")[0];
                var min = child.getElementsByTagName("min")[0];
                data.limits.max = parseFloat(max2.textContent);
                data.limits.min = parseFloat(min.textContent);
                break;
            }
          }
          if (data.limits.min >= data.limits.max) {
            data.static = true;
          }
          data.middlePosition = (data.limits.min + data.limits.max) / 2;
          return data;
        }
        function parseKinematicsLink(xml2) {
          var data = {
            sid: xml2.getAttribute("sid"),
            name: xml2.getAttribute("name") || "",
            attachments: [],
            transforms: []
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "attachment_full":
                data.attachments.push(parseKinematicsAttachment(child));
                break;
              case "matrix":
              case "translate":
              case "rotate":
                data.transforms.push(parseKinematicsTransform(child));
                break;
            }
          }
          return data;
        }
        function parseKinematicsAttachment(xml2) {
          var data = {
            joint: xml2.getAttribute("joint").split("/").pop(),
            transforms: [],
            links: []
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "link":
                data.links.push(parseKinematicsLink(child));
                break;
              case "matrix":
              case "translate":
              case "rotate":
                data.transforms.push(parseKinematicsTransform(child));
                break;
            }
          }
          return data;
        }
        function parseKinematicsTransform(xml2) {
          var data = {
            type: xml2.nodeName
          };
          var array = parseFloats(xml2.textContent);
          switch (data.type) {
            case "matrix":
              data.obj = new THREE.Matrix4();
              data.obj.fromArray(array).transpose();
              break;
            case "translate":
              data.obj = new THREE.Vector3();
              data.obj.fromArray(array);
              break;
            case "rotate":
              data.obj = new THREE.Vector3();
              data.obj.fromArray(array);
              data.angle = THREE.MathUtils.degToRad(array[3]);
              break;
          }
          return data;
        }
        function parsePhysicsModel(xml2) {
          var data = {
            name: xml2.getAttribute("name") || "",
            rigidBodies: {}
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "rigid_body":
                data.rigidBodies[child.getAttribute("name")] = {};
                parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute("name")]);
                break;
            }
          }
          library.physicsModels[xml2.getAttribute("id")] = data;
        }
        function parsePhysicsRigidBody(xml2, data) {
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "technique_common":
                parsePhysicsTechniqueCommon(child, data);
                break;
            }
          }
        }
        function parsePhysicsTechniqueCommon(xml2, data) {
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "inertia":
                data.inertia = parseFloats(child.textContent);
                break;
              case "mass":
                data.mass = parseFloats(child.textContent)[0];
                break;
            }
          }
        }
        function parseKinematicsScene(xml2) {
          var data = {
            bindJointAxis: []
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "bind_joint_axis":
                data.bindJointAxis.push(parseKinematicsBindJointAxis(child));
                break;
            }
          }
          library.kinematicsScenes[parseId(xml2.getAttribute("url"))] = data;
        }
        function parseKinematicsBindJointAxis(xml2) {
          var data = {
            target: xml2.getAttribute("target").split("/").pop()
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "axis":
                var param = child.getElementsByTagName("param")[0];
                data.axis = param.textContent;
                var tmpJointIndex = data.axis.split("inst_").pop().split("axis")[0];
                data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);
                break;
            }
          }
          return data;
        }
        function buildKinematicsScene(data) {
          if (data.build !== void 0) return data.build;
          return data;
        }
        function getKinematicsScene(id) {
          return getBuild(library.kinematicsScenes[id], buildKinematicsScene);
        }
        function setupKinematics() {
          var kinematicsModelId = Object.keys(library.kinematicsModels)[0];
          var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];
          var visualSceneId = Object.keys(library.visualScenes)[0];
          if (kinematicsModelId === void 0 || kinematicsSceneId === void 0) return;
          var kinematicsModel = getKinematicsModel(kinematicsModelId);
          var kinematicsScene = getKinematicsScene(kinematicsSceneId);
          var visualScene = getVisualScene(visualSceneId);
          var bindJointAxis = kinematicsScene.bindJointAxis;
          var jointMap = {};
          for (var i = 0, l = bindJointAxis.length; i < l; i++) {
            var axis = bindJointAxis[i];
            var targetElement = collada.querySelector('[sid="' + axis.target + '"]');
            if (targetElement) {
              var parentVisualElement = targetElement.parentElement;
              connect(axis.jointIndex, parentVisualElement);
            }
          }
          function connect(jointIndex, visualElement) {
            var visualElementName = visualElement.getAttribute("name");
            var joint = kinematicsModel.joints[jointIndex];
            visualScene.traverse(function(object) {
              if (object.name === visualElementName) {
                jointMap[jointIndex] = {
                  object,
                  transforms: buildTransformList(visualElement),
                  joint,
                  position: joint.zeroPosition
                };
              }
            });
          }
          var m0 = new THREE.Matrix4();
          kinematics = {
            joints: kinematicsModel && kinematicsModel.joints,
            getJointValue: function(jointIndex) {
              var jointData = jointMap[jointIndex];
              if (jointData) {
                return jointData.position;
              } else {
                console.warn("THREE.ColladaLoader: Joint " + jointIndex + " doesn't exist.");
              }
            },
            setJointValue: function(jointIndex, value) {
              var jointData = jointMap[jointIndex];
              if (jointData) {
                var joint = jointData.joint;
                if (value > joint.limits.max || value < joint.limits.min) {
                  console.warn("THREE.ColladaLoader: Joint " + jointIndex + " value " + value + " outside of limits (min: " + joint.limits.min + ", max: " + joint.limits.max + ").");
                } else if (joint.static) {
                  console.warn("THREE.ColladaLoader: Joint " + jointIndex + " is static.");
                } else {
                  var object = jointData.object;
                  var axis2 = joint.axis;
                  var transforms = jointData.transforms;
                  matrix.identity();
                  for (var i2 = 0; i2 < transforms.length; i2++) {
                    var transform = transforms[i2];
                    if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {
                      switch (joint.type) {
                        case "revolute":
                          matrix.multiply(m0.makeRotationAxis(axis2, THREE.MathUtils.degToRad(value)));
                          break;
                        case "prismatic":
                          matrix.multiply(m0.makeTranslation(axis2.x * value, axis2.y * value, axis2.z * value));
                          break;
                        default:
                          console.warn("THREE.ColladaLoader: Unknown joint type: " + joint.type);
                          break;
                      }
                    } else {
                      switch (transform.type) {
                        case "matrix":
                          matrix.multiply(transform.obj);
                          break;
                        case "translate":
                          matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));
                          break;
                        case "scale":
                          matrix.scale(transform.obj);
                          break;
                        case "rotate":
                          matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));
                          break;
                      }
                    }
                  }
                  object.matrix.copy(matrix);
                  object.matrix.decompose(object.position, object.quaternion, object.scale);
                  jointMap[jointIndex].position = value;
                }
              } else {
                console.log("THREE.ColladaLoader: " + jointIndex + " does not exist.");
              }
            }
          };
        }
        function buildTransformList(node) {
          var transforms = [];
          var xml2 = collada.querySelector('[id="' + node.id + '"]');
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "matrix":
                var array = parseFloats(child.textContent);
                var matrix2 = new THREE.Matrix4().fromArray(array).transpose();
                transforms.push({
                  sid: child.getAttribute("sid"),
                  type: child.nodeName,
                  obj: matrix2
                });
                break;
              case "translate":
              case "scale":
                var array = parseFloats(child.textContent);
                var vector2 = new THREE.Vector3().fromArray(array);
                transforms.push({
                  sid: child.getAttribute("sid"),
                  type: child.nodeName,
                  obj: vector2
                });
                break;
              case "rotate":
                var array = parseFloats(child.textContent);
                var vector2 = new THREE.Vector3().fromArray(array);
                var angle2 = THREE.MathUtils.degToRad(array[3]);
                transforms.push({
                  sid: child.getAttribute("sid"),
                  type: child.nodeName,
                  obj: vector2,
                  angle: angle2
                });
                break;
            }
          }
          return transforms;
        }
        function prepareNodes(xml2) {
          var elements = xml2.getElementsByTagName("node");
          for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            if (element.hasAttribute("id") === false) {
              element.setAttribute("id", generateId());
            }
          }
        }
        var matrix = new THREE.Matrix4();
        var vector = new THREE.Vector3();
        function parseNode(xml2) {
          var data = {
            name: xml2.getAttribute("name") || "",
            type: xml2.getAttribute("type"),
            id: xml2.getAttribute("id"),
            sid: xml2.getAttribute("sid"),
            matrix: new THREE.Matrix4(),
            nodes: [],
            instanceCameras: [],
            instanceControllers: [],
            instanceLights: [],
            instanceGeometries: [],
            instanceNodes: [],
            transforms: {}
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            if (child.nodeType !== 1) continue;
            switch (child.nodeName) {
              case "node":
                data.nodes.push(child.getAttribute("id"));
                parseNode(child);
                break;
              case "instance_camera":
                data.instanceCameras.push(parseId(child.getAttribute("url")));
                break;
              case "instance_controller":
                data.instanceControllers.push(parseNodeInstance(child));
                break;
              case "instance_light":
                data.instanceLights.push(parseId(child.getAttribute("url")));
                break;
              case "instance_geometry":
                data.instanceGeometries.push(parseNodeInstance(child));
                break;
              case "instance_node":
                data.instanceNodes.push(parseId(child.getAttribute("url")));
                break;
              case "matrix":
                var array = parseFloats(child.textContent);
                data.matrix.multiply(matrix.fromArray(array).transpose());
                data.transforms[child.getAttribute("sid")] = child.nodeName;
                break;
              case "translate":
                var array = parseFloats(child.textContent);
                vector.fromArray(array);
                data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));
                data.transforms[child.getAttribute("sid")] = child.nodeName;
                break;
              case "rotate":
                var array = parseFloats(child.textContent);
                var angle2 = THREE.MathUtils.degToRad(array[3]);
                data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle2));
                data.transforms[child.getAttribute("sid")] = child.nodeName;
                break;
              case "scale":
                var array = parseFloats(child.textContent);
                data.matrix.scale(vector.fromArray(array));
                data.transforms[child.getAttribute("sid")] = child.nodeName;
                break;
              case "extra":
                break;
              default:
                console.log(child);
            }
          }
          if (hasNode(data.id)) {
            console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", data.id);
          } else {
            library.nodes[data.id] = data;
          }
          return data;
        }
        function parseNodeInstance(xml2) {
          var data = {
            id: parseId(xml2.getAttribute("url")),
            materials: {},
            skeletons: []
          };
          for (var i = 0; i < xml2.childNodes.length; i++) {
            var child = xml2.childNodes[i];
            switch (child.nodeName) {
              case "bind_material":
                var instances = child.getElementsByTagName("instance_material");
                for (var j = 0; j < instances.length; j++) {
                  var instance = instances[j];
                  var symbol = instance.getAttribute("symbol");
                  var target = instance.getAttribute("target");
                  data.materials[symbol] = parseId(target);
                }
                break;
              case "skeleton":
                data.skeletons.push(parseId(child.textContent));
                break;
              default:
                break;
            }
          }
          return data;
        }
        function buildSkeleton(skeletons, joints) {
          var boneData = [];
          var sortedBoneData = [];
          var i, j, data;
          for (i = 0; i < skeletons.length; i++) {
            var skeleton = skeletons[i];
            var root;
            if (hasNode(skeleton)) {
              root = getNode(skeleton);
              buildBoneHierarchy(root, joints, boneData);
            } else if (hasVisualScene(skeleton)) {
              var visualScene = library.visualScenes[skeleton];
              var children = visualScene.children;
              for (var j = 0; j < children.length; j++) {
                var child = children[j];
                if (child.type === "JOINT") {
                  var root = getNode(child.id);
                  buildBoneHierarchy(root, joints, boneData);
                }
              }
            } else {
              console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", skeleton);
            }
          }
          for (i = 0; i < joints.length; i++) {
            for (j = 0; j < boneData.length; j++) {
              data = boneData[j];
              if (data.bone.name === joints[i].name) {
                sortedBoneData[i] = data;
                data.processed = true;
                break;
              }
            }
          }
          for (i = 0; i < boneData.length; i++) {
            data = boneData[i];
            if (data.processed === false) {
              sortedBoneData.push(data);
              data.processed = true;
            }
          }
          var bones = [];
          var boneInverses = [];
          for (i = 0; i < sortedBoneData.length; i++) {
            data = sortedBoneData[i];
            bones.push(data.bone);
            boneInverses.push(data.boneInverse);
          }
          return new THREE.Skeleton(bones, boneInverses);
        }
        function buildBoneHierarchy(root, joints, boneData) {
          root.traverse(function(object) {
            if (object.isBone === true) {
              var boneInverse;
              for (var i = 0; i < joints.length; i++) {
                var joint = joints[i];
                if (joint.name === object.name) {
                  boneInverse = joint.boneInverse;
                  break;
                }
              }
              if (boneInverse === void 0) {
                boneInverse = new THREE.Matrix4();
              }
              boneData.push({ bone: object, boneInverse, processed: false });
            }
          });
        }
        function buildNode(data) {
          var objects = [];
          var matrix2 = data.matrix;
          var nodes = data.nodes;
          var type = data.type;
          var instanceCameras = data.instanceCameras;
          var instanceControllers = data.instanceControllers;
          var instanceLights = data.instanceLights;
          var instanceGeometries = data.instanceGeometries;
          var instanceNodes = data.instanceNodes;
          for (var i = 0, l = nodes.length; i < l; i++) {
            objects.push(getNode(nodes[i]));
          }
          for (var i = 0, l = instanceCameras.length; i < l; i++) {
            var instanceCamera = getCamera(instanceCameras[i]);
            if (instanceCamera !== null) {
              objects.push(instanceCamera.clone());
            }
          }
          for (var i = 0, l = instanceControllers.length; i < l; i++) {
            var instance = instanceControllers[i];
            var controller = getController(instance.id);
            var geometries = getGeometry(controller.id);
            var newObjects = buildObjects(geometries, instance.materials);
            var skeletons = instance.skeletons;
            var joints = controller.skin.joints;
            var skeleton = buildSkeleton(skeletons, joints);
            for (var j = 0, jl = newObjects.length; j < jl; j++) {
              var object = newObjects[j];
              if (object.isSkinnedMesh) {
                object.bind(skeleton, controller.skin.bindMatrix);
                object.normalizeSkinWeights();
              }
              objects.push(object);
            }
          }
          for (var i = 0, l = instanceLights.length; i < l; i++) {
            var instanceLight = getLight(instanceLights[i]);
            if (instanceLight !== null) {
              objects.push(instanceLight.clone());
            }
          }
          for (var i = 0, l = instanceGeometries.length; i < l; i++) {
            var instance = instanceGeometries[i];
            var geometries = getGeometry(instance.id);
            var newObjects = buildObjects(geometries, instance.materials);
            for (var j = 0, jl = newObjects.length; j < jl; j++) {
              objects.push(newObjects[j]);
            }
          }
          for (var i = 0, l = instanceNodes.length; i < l; i++) {
            objects.push(getNode(instanceNodes[i]).clone());
          }
          var object;
          if (nodes.length === 0 && objects.length === 1) {
            object = objects[0];
          } else {
            object = type === "JOINT" ? new THREE.Bone() : new THREE.Group();
            for (var i = 0; i < objects.length; i++) {
              object.add(objects[i]);
            }
          }
          if (object.name === "") {
            object.name = type === "JOINT" ? data.sid : data.name;
          }
          object.matrix.copy(matrix2);
          object.matrix.decompose(object.position, object.quaternion, object.scale);
          return object;
        }
        var fallbackMaterial = new THREE.MeshBasicMaterial({ color: 16711935 });
        function resolveMaterialBinding(keys, instanceMaterials) {
          var materials = [];
          for (var i = 0, l = keys.length; i < l; i++) {
            var id = instanceMaterials[keys[i]];
            if (id === void 0) {
              console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", keys[i]);
              materials.push(fallbackMaterial);
            } else {
              materials.push(getMaterial(id));
            }
          }
          return materials;
        }
        function buildObjects(geometries, instanceMaterials) {
          var objects = [];
          for (var type in geometries) {
            var geometry = geometries[type];
            var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);
            if (materials.length === 0) {
              if (type === "lines" || type === "linestrips") {
                materials.push(new THREE.LineBasicMaterial());
              } else {
                materials.push(new THREE.MeshPhongMaterial());
              }
            }
            var skinning = geometry.data.attributes.skinIndex !== void 0;
            if (skinning) {
              for (var i = 0, l = materials.length; i < l; i++) {
                materials[i].skinning = true;
              }
            }
            var material = materials.length === 1 ? materials[0] : materials;
            var object;
            switch (type) {
              case "lines":
                object = new THREE.LineSegments(geometry.data, material);
                break;
              case "linestrips":
                object = new THREE.Line(geometry.data, material);
                break;
              case "triangles":
              case "polylist":
                if (skinning) {
                  object = new THREE.SkinnedMesh(geometry.data, material);
                } else {
                  object = new THREE.Mesh(geometry.data, material);
                }
                break;
            }
            objects.push(object);
          }
          return objects;
        }
        function hasNode(id) {
          return library.nodes[id] !== void 0;
        }
        function getNode(id) {
          return getBuild(library.nodes[id], buildNode);
        }
        function parseVisualScene(xml2) {
          var data = {
            name: xml2.getAttribute("name"),
            children: []
          };
          prepareNodes(xml2);
          var elements = getElementsByTagName(xml2, "node");
          for (var i = 0; i < elements.length; i++) {
            data.children.push(parseNode(elements[i]));
          }
          library.visualScenes[xml2.getAttribute("id")] = data;
        }
        function buildVisualScene(data) {
          var group = new THREE.Group();
          group.name = data.name;
          var children = data.children;
          for (var i = 0; i < children.length; i++) {
            var child = children[i];
            group.add(getNode(child.id));
          }
          return group;
        }
        function hasVisualScene(id) {
          return library.visualScenes[id] !== void 0;
        }
        function getVisualScene(id) {
          return getBuild(library.visualScenes[id], buildVisualScene);
        }
        function parseScene(xml2) {
          var instance = getElementsByTagName(xml2, "instance_visual_scene")[0];
          return getVisualScene(parseId(instance.getAttribute("url")));
        }
        function setupAnimations() {
          var clips = library.clips;
          if (isEmpty(clips) === true) {
            if (isEmpty(library.animations) === false) {
              var tracks = [];
              for (var id in library.animations) {
                var animationTracks = getAnimation(id);
                for (var i = 0, l = animationTracks.length; i < l; i++) {
                  tracks.push(animationTracks[i]);
                }
              }
              animations.push(new THREE.AnimationClip("default", -1, tracks));
            }
          } else {
            for (var id in clips) {
              animations.push(getAnimationClip(id));
            }
          }
        }
        if (text.length === 0) {
          return { scene: new THREE.Scene() };
        }
        var xml = new DOMParser().parseFromString(text, "application/xml");
        var collada = getElementsByTagName(xml, "COLLADA")[0];
        var version = collada.getAttribute("version");
        console.log("THREE.ColladaLoader: File version", version);
        var asset = parseAsset(getElementsByTagName(collada, "asset")[0]);
        var textureLoader = new THREE.TextureLoader(this.manager);
        textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        var tgaLoader;
        if (THREE.TGALoader) {
          tgaLoader = new THREE.TGALoader(this.manager);
          tgaLoader.setPath(this.resourcePath || path);
        }
        var animations = [];
        var kinematics = {};
        var count = 0;
        var library = {
          animations: {},
          clips: {},
          controllers: {},
          images: {},
          effects: {},
          materials: {},
          cameras: {},
          lights: {},
          geometries: {},
          nodes: {},
          visualScenes: {},
          kinematicsModels: {},
          physicsModels: {},
          kinematicsScenes: {}
        };
        parseLibrary(collada, "library_animations", "animation", parseAnimation);
        parseLibrary(collada, "library_animation_clips", "animation_clip", parseAnimationClip);
        parseLibrary(collada, "library_controllers", "controller", parseController);
        parseLibrary(collada, "library_images", "image", parseImage);
        parseLibrary(collada, "library_effects", "effect", parseEffect);
        parseLibrary(collada, "library_materials", "material", parseMaterial);
        parseLibrary(collada, "library_cameras", "camera", parseCamera);
        parseLibrary(collada, "library_lights", "light", parseLight);
        parseLibrary(collada, "library_geometries", "geometry", parseGeometry);
        parseLibrary(collada, "library_nodes", "node", parseNode);
        parseLibrary(collada, "library_visual_scenes", "visual_scene", parseVisualScene);
        parseLibrary(collada, "library_kinematics_models", "kinematics_model", parseKinematicsModel);
        parseLibrary(collada, "library_physics_models", "physics_model", parsePhysicsModel);
        parseLibrary(collada, "scene", "instance_kinematics_scene", parseKinematicsScene);
        buildLibrary(library.animations, buildAnimation);
        buildLibrary(library.clips, buildAnimationClip);
        buildLibrary(library.controllers, buildController);
        buildLibrary(library.images, buildImage);
        buildLibrary(library.effects, buildEffect);
        buildLibrary(library.materials, buildMaterial);
        buildLibrary(library.cameras, buildCamera);
        buildLibrary(library.lights, buildLight);
        buildLibrary(library.geometries, buildGeometry);
        buildLibrary(library.visualScenes, buildVisualScene);
        setupAnimations();
        setupKinematics();
        var scene = parseScene(getElementsByTagName(collada, "scene")[0]);
        if (asset.upAxis === "Z_UP") {
          scene.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));
        }
        scene.scale.multiplyScalar(asset.unit);
        return {
          animations,
          kinematics,
          library,
          scene
        };
      }
    };
  }
});

// node_modules/aframe-extras/src/loaders/collada-model-legacy.js
var require_collada_model_legacy = __commonJS({
  "node_modules/aframe-extras/src/loaders/collada-model-legacy.js"(exports, module) {
    THREE.ColladaLoader = require_ColladaLoader();
    module.exports.Component = AFRAME.registerComponent("collada-model-legacy", {
      schema: { type: "asset" },
      init: function() {
        this.model = null;
        this.loader = new THREE.ColladaLoader();
      },
      update: function() {
        var self = this;
        var el = this.el;
        var src = this.data;
        var rendererSystem = this.el.sceneEl.systems.renderer;
        if (!src) {
          return;
        }
        this.remove();
        this.loader.load(src, function(colladaModel) {
          self.model = colladaModel.scene;
          self.model.traverse(function(object) {
            if (object.isMesh) {
              var material = object.material;
              if (material.color) rendererSystem.applyColorCorrection(material.color);
              if (material.map) rendererSystem.applyColorCorrection(material.map);
              if (material.emissive) rendererSystem.applyColorCorrection(material.emissive);
              if (material.emissiveMap) rendererSystem.applyColorCorrection(material.emissiveMap);
            }
          });
          el.setObject3D("mesh", self.model);
          el.emit("model-loaded", { format: "collada", model: self.model });
        });
      },
      remove: function() {
        if (!this.model) {
          return;
        }
        this.el.removeObject3D("mesh");
      }
    });
  }
});

// node_modules/three/examples/jsm/libs/fflate.module.js
function StrmOpt(opts, cb) {
  if (typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i = 0; i < str.length; ++i)
      ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v2) {
    ar[ai++] = v2;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
    if (r.length)
      err(8);
    return s;
  }
}
var ch2, wk, u8, u16, i32, fleb, fdeb, clim, freb, _a, fl, revfl, _b, fd, revfd, rev, x, i, hMap, flt, i, i, i, i, fdt, i, flm, flrm, fdm, fdrm, max, bits, bits16, shft, slc, ec, err, inflt, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, deo, et, dflt, crct, crc, adler, dopt, mrg, wcln, ch, cbfs, wrkr, bInflt, bDflt, guze, zule, pbf, gopt, astrm, astrmify, b2, b4, b8, wbytes, gzh, gzs, gzl, gzhl, zlh, zls, Deflate, AsyncDeflate, Inflate, AsyncInflate, Gzip, Gunzip, AsyncGunzip, Zlib, Unzlib, AsyncUnzlib, Decompress, AsyncDecompress, te, td, tds, dutf8, DecodeUTF8, EncodeUTF8, dbf, z64e, exfl, wzh, wzf, ZipPassThrough, ZipDeflate, AsyncZipDeflate, Zip, UnzipPassThrough, UnzipInflate, AsyncUnzipInflate, Unzip;
var init_fflate_module = __esm({
  "node_modules/three/examples/jsm/libs/fflate.module.js"() {
    ch2 = {};
    wk = function(c, id, msg, transfer, cb) {
      var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
        c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
      ], { type: "text/javascript" }))));
      w.onmessage = function(e) {
        var d2 = e.data, ed = d2.$e$;
        if (ed) {
          var err2 = new Error(ed[0]);
          err2["code"] = ed[1];
          err2.stack = ed[2];
          cb(err2, null);
        } else
          cb(null, d2);
      };
      w.postMessage(msg, transfer);
      return w;
    };
    u8 = Uint8Array;
    u16 = Uint16Array;
    i32 = Int32Array;
    fleb = new u8([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      /* unused */
      0,
      0,
      /* impossible */
      0
    ]);
    fdeb = new u8([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
      /* unused */
      0,
      0
    ]);
    clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    freb = function(eb, start) {
      var b = new u16(31);
      for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
      }
      var r = new i32(b[30]);
      for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
          r[j] = j - b[i] << 5 | i;
        }
      }
      return { b, r };
    };
    _a = freb(fleb, 2);
    fl = _a.b;
    revfl = _a.r;
    fl[28] = 258, revfl[258] = 28;
    _b = freb(fdeb, 0);
    fd = _b.b;
    revfd = _b.r;
    rev = new u16(32768);
    for (i = 0; i < 32768; ++i) {
      x = (i & 43690) >> 1 | (i & 21845) << 1;
      x = (x & 52428) >> 2 | (x & 13107) << 2;
      x = (x & 61680) >> 4 | (x & 3855) << 4;
      rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
    }
    hMap = function(cd, mb, r) {
      var s = cd.length;
      var i = 0;
      var l = new u16(mb);
      for (; i < s; ++i) {
        if (cd[i])
          ++l[cd[i] - 1];
      }
      var le = new u16(mb);
      for (i = 1; i < mb; ++i) {
        le[i] = le[i - 1] + l[i - 1] << 1;
      }
      var co;
      if (r) {
        co = new u16(1 << mb);
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
          if (cd[i]) {
            var sv = i << 4 | cd[i];
            var r_1 = mb - cd[i];
            var v2 = le[cd[i] - 1]++ << r_1;
            for (var m = v2 | (1 << r_1) - 1; v2 <= m; ++v2) {
              co[rev[v2] >> rvb] = sv;
            }
          }
        }
      } else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
          if (cd[i]) {
            co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
          }
        }
      }
      return co;
    };
    flt = new u8(288);
    for (i = 0; i < 144; ++i)
      flt[i] = 8;
    for (i = 144; i < 256; ++i)
      flt[i] = 9;
    for (i = 256; i < 280; ++i)
      flt[i] = 7;
    for (i = 280; i < 288; ++i)
      flt[i] = 8;
    fdt = new u8(32);
    for (i = 0; i < 32; ++i)
      fdt[i] = 5;
    flm = hMap(flt, 9, 0);
    flrm = hMap(flt, 9, 1);
    fdm = hMap(fdt, 5, 0);
    fdrm = hMap(fdt, 5, 1);
    max = function(a) {
      var m = a[0];
      for (var i = 1; i < a.length; ++i) {
        if (a[i] > m)
          m = a[i];
      }
      return m;
    };
    bits = function(d2, p2, m) {
      var o = p2 / 8 | 0;
      return (d2[o] | d2[o + 1] << 8) >> (p2 & 7) & m;
    };
    bits16 = function(d2, p2) {
      var o = p2 / 8 | 0;
      return (d2[o] | d2[o + 1] << 8 | d2[o + 2] << 16) >> (p2 & 7);
    };
    shft = function(p2) {
      return (p2 + 7) / 8 | 0;
    };
    slc = function(v2, s, e) {
      if (s == null || s < 0)
        s = 0;
      if (e == null || e > v2.length)
        e = v2.length;
      return new u8(v2.subarray(s, e));
    };
    ec = [
      "unexpected EOF",
      "invalid block type",
      "invalid length/literal",
      "invalid distance",
      "stream finished",
      "no stream handler",
      ,
      "no callback",
      "invalid UTF-8 data",
      "extra field too long",
      "date not in range 1980-2099",
      "filename too long",
      "stream finishing",
      "invalid zip data"
      // determined by unknown compression method
    ];
    err = function(ind, msg, nt) {
      var e = new Error(msg || ec[ind]);
      e.code = ind;
      if (Error.captureStackTrace)
        Error.captureStackTrace(e, err);
      if (!nt)
        throw e;
      return e;
    };
    inflt = function(dat, st, buf, dict) {
      var sl = dat.length, dl = dict ? dict.length : 0;
      if (!sl || st.f && !st.l)
        return buf || new u8(0);
      var noBuf = !buf;
      var resize = noBuf || st.i != 2;
      var noSt = st.i;
      if (noBuf)
        buf = new u8(sl * 3);
      var cbuf = function(l2) {
        var bl = buf.length;
        if (l2 > bl) {
          var nbuf = new u8(Math.max(bl * 2, l2));
          nbuf.set(buf);
          buf = nbuf;
        }
      };
      var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
      var tbts = sl * 8;
      do {
        if (!lm) {
          final = bits(dat, pos, 1);
          var type = bits(dat, pos + 1, 3);
          pos += 3;
          if (!type) {
            var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
            if (t > sl) {
              if (noSt)
                err(0);
              break;
            }
            if (resize)
              cbuf(bt + l);
            buf.set(dat.subarray(s, t), bt);
            st.b = bt += l, st.p = pos = t * 8, st.f = final;
            continue;
          } else if (type == 1)
            lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
          else if (type == 2) {
            var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
            var tl = hLit + bits(dat, pos + 5, 31) + 1;
            pos += 14;
            var ldt = new u8(tl);
            var clt = new u8(19);
            for (var i = 0; i < hcLen; ++i) {
              clt[clim[i]] = bits(dat, pos + i * 3, 7);
            }
            pos += hcLen * 3;
            var clb = max(clt), clbmsk = (1 << clb) - 1;
            var clm = hMap(clt, clb, 1);
            for (var i = 0; i < tl; ) {
              var r = clm[bits(dat, pos, clbmsk)];
              pos += r & 15;
              var s = r >> 4;
              if (s < 16) {
                ldt[i++] = s;
              } else {
                var c = 0, n = 0;
                if (s == 16)
                  n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                else if (s == 17)
                  n = 3 + bits(dat, pos, 7), pos += 3;
                else if (s == 18)
                  n = 11 + bits(dat, pos, 127), pos += 7;
                while (n--)
                  ldt[i++] = c;
              }
            }
            var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
            lbt = max(lt);
            dbt = max(dt);
            lm = hMap(lt, lbt, 1);
            dm = hMap(dt, dbt, 1);
          } else
            err(1);
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
        }
        if (resize)
          cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (; ; lpos = pos) {
          var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
          pos += c & 15;
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (!c)
            err(2);
          if (sym < 256)
            buf[bt++] = sym;
          else if (sym == 256) {
            lpos = pos, lm = null;
            break;
          } else {
            var add = sym - 254;
            if (sym > 264) {
              var i = sym - 257, b = fleb[i];
              add = bits(dat, pos, (1 << b) - 1) + fl[i];
              pos += b;
            }
            var d2 = dm[bits16(dat, pos) & dms], dsym = d2 >> 4;
            if (!d2)
              err(3);
            pos += d2 & 15;
            var dt = fd[dsym];
            if (dsym > 3) {
              var b = fdeb[dsym];
              dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
            }
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
            if (resize)
              cbuf(bt + 131072);
            var end = bt + add;
            if (bt < dt) {
              var shift = dl - dt, dend = Math.min(dt, end);
              if (shift + bt < 0)
                err(3);
              for (; bt < dend; ++bt)
                buf[bt] = dict[shift + bt];
            }
            for (; bt < end; ++bt)
              buf[bt] = buf[bt - dt];
          }
        }
        st.l = lm, st.p = lpos, st.b = bt, st.f = final;
        if (lm)
          final = 1, st.m = lbt, st.d = dm, st.n = dbt;
      } while (!final);
      return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
    };
    wbits = function(d2, p2, v2) {
      v2 <<= p2 & 7;
      var o = p2 / 8 | 0;
      d2[o] |= v2;
      d2[o + 1] |= v2 >> 8;
    };
    wbits16 = function(d2, p2, v2) {
      v2 <<= p2 & 7;
      var o = p2 / 8 | 0;
      d2[o] |= v2;
      d2[o + 1] |= v2 >> 8;
      d2[o + 2] |= v2 >> 16;
    };
    hTree = function(d2, mb) {
      var t = [];
      for (var i = 0; i < d2.length; ++i) {
        if (d2[i])
          t.push({ s: i, f: d2[i] });
      }
      var s = t.length;
      var t2 = t.slice();
      if (!s)
        return { t: et, l: 0 };
      if (s == 1) {
        var v2 = new u8(t[0].s + 1);
        v2[t[0].s] = 1;
        return { t: v2, l: 1 };
      }
      t.sort(function(a, b) {
        return a.f - b.f;
      });
      t.push({ s: -1, f: 25001 });
      var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
      t[0] = { s: -1, f: l.f + r.f, l, r };
      while (i1 != s - 1) {
        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
        t[i1++] = { s: -1, f: l.f + r.f, l, r };
      }
      var maxSym = t2[0].s;
      for (var i = 1; i < s; ++i) {
        if (t2[i].s > maxSym)
          maxSym = t2[i].s;
      }
      var tr = new u16(maxSym + 1);
      var mbt = ln(t[i1 - 1], tr, 0);
      if (mbt > mb) {
        var i = 0, dt = 0;
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function(a, b) {
          return tr[b.s] - tr[a.s] || a.f - b.f;
        });
        for (; i < s; ++i) {
          var i2_1 = t2[i].s;
          if (tr[i2_1] > mb) {
            dt += cst - (1 << mbt - tr[i2_1]);
            tr[i2_1] = mb;
          } else
            break;
        }
        dt >>= lft;
        while (dt > 0) {
          var i2_2 = t2[i].s;
          if (tr[i2_2] < mb)
            dt -= 1 << mb - tr[i2_2]++ - 1;
          else
            ++i;
        }
        for (; i >= 0 && dt; --i) {
          var i2_3 = t2[i].s;
          if (tr[i2_3] == mb) {
            --tr[i2_3];
            ++dt;
          }
        }
        mbt = mb;
      }
      return { t: new u8(tr), l: mbt };
    };
    ln = function(n, l, d2) {
      return n.s == -1 ? Math.max(ln(n.l, l, d2 + 1), ln(n.r, l, d2 + 1)) : l[n.s] = d2;
    };
    lc = function(c) {
      var s = c.length;
      while (s && !c[--s])
        ;
      var cl = new u16(++s);
      var cli = 0, cln = c[0], cls = 1;
      var w = function(v2) {
        cl[cli++] = v2;
      };
      for (var i = 1; i <= s; ++i) {
        if (c[i] == cln && i != s)
          ++cls;
        else {
          if (!cln && cls > 2) {
            for (; cls > 138; cls -= 138)
              w(32754);
            if (cls > 2) {
              w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
              cls = 0;
            }
          } else if (cls > 3) {
            w(cln), --cls;
            for (; cls > 6; cls -= 6)
              w(8304);
            if (cls > 2)
              w(cls - 3 << 5 | 8208), cls = 0;
          }
          while (cls--)
            w(cln);
          cls = 1;
          cln = c[i];
        }
      }
      return { c: cl.subarray(0, cli), n: s };
    };
    clen = function(cf, cl) {
      var l = 0;
      for (var i = 0; i < cl.length; ++i)
        l += cf[i] * cl[i];
      return l;
    };
    wfblk = function(out, pos, dat) {
      var s = dat.length;
      var o = shft(pos + 2);
      out[o] = s & 255;
      out[o + 1] = s >> 8;
      out[o + 2] = out[o] ^ 255;
      out[o + 3] = out[o + 1] ^ 255;
      for (var i = 0; i < s; ++i)
        out[o + i + 4] = dat[i];
      return (o + 4 + s) * 8;
    };
    wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
      wbits(out, p2++, final);
      ++lf[256];
      var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
      var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
      var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
      var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
      var lcfreq = new u16(19);
      for (var i = 0; i < lclt.length; ++i)
        ++lcfreq[lclt[i] & 31];
      for (var i = 0; i < lcdt.length; ++i)
        ++lcfreq[lcdt[i] & 31];
      var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
      var nlcc = 19;
      for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
      var flen = bl + 5 << 3;
      var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
      var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
      if (bs >= 0 && flen <= ftlen && flen <= dtlen)
        return wfblk(out, p2, dat.subarray(bs, bs + bl));
      var lm, ll, dm, dl;
      wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
      if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p2, nlc - 257);
        wbits(out, p2 + 5, ndc - 1);
        wbits(out, p2 + 10, nlcc - 4);
        p2 += 14;
        for (var i = 0; i < nlcc; ++i)
          wbits(out, p2 + 3 * i, lct[clim[i]]);
        p2 += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it = 0; it < 2; ++it) {
          var clct = lcts[it];
          for (var i = 0; i < clct.length; ++i) {
            var len = clct[i] & 31;
            wbits(out, p2, llm[len]), p2 += lct[len];
            if (len > 15)
              wbits(out, p2, clct[i] >> 5 & 127), p2 += clct[i] >> 12;
          }
        }
      } else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
      }
      for (var i = 0; i < li; ++i) {
        var sym = syms[i];
        if (sym > 255) {
          var len = sym >> 18 & 31;
          wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
          if (len > 7)
            wbits(out, p2, sym >> 23 & 31), p2 += fleb[len];
          var dst = sym & 31;
          wbits16(out, p2, dm[dst]), p2 += dl[dst];
          if (dst > 3)
            wbits16(out, p2, sym >> 5 & 8191), p2 += fdeb[dst];
        } else {
          wbits16(out, p2, lm[sym]), p2 += ll[sym];
        }
      }
      wbits16(out, p2, lm[256]);
      return p2 + ll[256];
    };
    deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
    et = new u8(0);
    dflt = function(dat, lvl, plvl, pre, post, st) {
      var s = st.z || dat.length;
      var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
      var w = o.subarray(pre, o.length - post);
      var lst = st.l;
      var pos = (st.r || 0) & 7;
      if (lvl) {
        if (pos)
          w[0] = st.r >> 3;
        var opt = deo[lvl - 1];
        var n = opt >> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function(i2) {
          return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
        };
        var syms = new i32(25e3);
        var lf = new u16(288), df = new u16(32);
        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
        for (; i + 2 < s; ++i) {
          var hv = hsh(i);
          var imod = i & 32767, pimod = head[hv];
          prev[imod] = pimod;
          head[hv] = imod;
          if (wi <= i) {
            var rem = s - i;
            if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
              pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
              li = lc_1 = eb = 0, bs = i;
              for (var j = 0; j < 286; ++j)
                lf[j] = 0;
              for (var j = 0; j < 30; ++j)
                df[j] = 0;
            }
            var l = 2, d2 = 0, ch_1 = c, dif = imod - pimod & 32767;
            if (rem > 2 && hv == hsh(i - dif)) {
              var maxn = Math.min(n, rem) - 1;
              var maxd = Math.min(32767, i);
              var ml = Math.min(258, rem);
              while (dif <= maxd && --ch_1 && imod != pimod) {
                if (dat[i + l] == dat[i + l - dif]) {
                  var nl = 0;
                  for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                    ;
                  if (nl > l) {
                    l = nl, d2 = dif;
                    if (nl > maxn)
                      break;
                    var mmd = Math.min(dif, nl - 2);
                    var md = 0;
                    for (var j = 0; j < mmd; ++j) {
                      var ti = i - dif + j & 32767;
                      var pti = prev[ti];
                      var cd = ti - pti & 32767;
                      if (cd > md)
                        md = cd, pimod = ti;
                    }
                  }
                }
                imod = pimod, pimod = prev[imod];
                dif += imod - pimod & 32767;
              }
            }
            if (d2) {
              syms[li++] = 268435456 | revfl[l] << 18 | revfd[d2];
              var lin = revfl[l] & 31, din = revfd[d2] & 31;
              eb += fleb[lin] + fdeb[din];
              ++lf[257 + lin];
              ++df[din];
              wi = i + l;
              ++lc_1;
            } else {
              syms[li++] = dat[i];
              ++lf[dat[i]];
            }
          }
        }
        for (i = Math.max(i, wi); i < s; ++i) {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
        if (!lst) {
          st.r = pos & 7 | w[pos / 8 | 0] << 3;
          pos -= 7;
          st.h = head, st.p = prev, st.i = i, st.w = wi;
        }
      } else {
        for (var i = st.w || 0; i < s + lst; i += 65535) {
          var e = i + 65535;
          if (e >= s) {
            w[pos / 8 | 0] = lst;
            e = s;
          }
          pos = wfblk(w, pos + 1, dat.subarray(i, e));
        }
        st.i = s;
      }
      return slc(o, 0, pre + shft(pos) + post);
    };
    crct = function() {
      var t = new Int32Array(256);
      for (var i = 0; i < 256; ++i) {
        var c = i, k = 9;
        while (--k)
          c = (c & 1 && -306674912) ^ c >>> 1;
        t[i] = c;
      }
      return t;
    }();
    crc = function() {
      var c = -1;
      return {
        p: function(d2) {
          var cr = c;
          for (var i = 0; i < d2.length; ++i)
            cr = crct[cr & 255 ^ d2[i]] ^ cr >>> 8;
          c = cr;
        },
        d: function() {
          return ~c;
        }
      };
    };
    adler = function() {
      var a = 1, b = 0;
      return {
        p: function(d2) {
          var n = a, m = b;
          var l = d2.length | 0;
          for (var i = 0; i != l; ) {
            var e = Math.min(i + 2655, l);
            for (; i < e; ++i)
              m += n += d2[i];
            n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
          }
          a = n, b = m;
        },
        d: function() {
          a %= 65521, b %= 65521;
          return (a & 255) << 24 | (a & 65280) << 8 | (b & 255) << 8 | b >> 8;
        }
      };
    };
    dopt = function(dat, opt, pre, post, st) {
      if (!st) {
        st = { l: 1 };
        if (opt.dictionary) {
          var dict = opt.dictionary.subarray(-32768);
          var newDat = new u8(dict.length + dat.length);
          newDat.set(dict);
          newDat.set(dat, dict.length);
          dat = newDat;
          st.w = dict.length;
        }
      }
      return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
    };
    mrg = function(a, b) {
      var o = {};
      for (var k in a)
        o[k] = a[k];
      for (var k in b)
        o[k] = b[k];
      return o;
    };
    wcln = function(fn, fnStr, td2) {
      var dt = fn();
      var st = fn.toString();
      var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
      for (var i = 0; i < dt.length; ++i) {
        var v2 = dt[i], k = ks[i];
        if (typeof v2 == "function") {
          fnStr += ";" + k + "=";
          var st_1 = v2.toString();
          if (v2.prototype) {
            if (st_1.indexOf("[native code]") != -1) {
              var spInd = st_1.indexOf(" ", 8) + 1;
              fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
            } else {
              fnStr += st_1;
              for (var t in v2.prototype)
                fnStr += ";" + k + ".prototype." + t + "=" + v2.prototype[t].toString();
            }
          } else
            fnStr += st_1;
        } else
          td2[k] = v2;
      }
      return fnStr;
    };
    ch = [];
    cbfs = function(v2) {
      var tl = [];
      for (var k in v2) {
        if (v2[k].buffer) {
          tl.push((v2[k] = new v2[k].constructor(v2[k])).buffer);
        }
      }
      return tl;
    };
    wrkr = function(fns, init, id, cb) {
      if (!ch[id]) {
        var fnStr = "", td_1 = {}, m = fns.length - 1;
        for (var i = 0; i < m; ++i)
          fnStr = wcln(fns[i], fnStr, td_1);
        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
      }
      var td2 = mrg({}, ch[id].e);
      return wk(ch[id].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init.toString() + "}", id, td2, cbfs(td2), cb);
    };
    bInflt = function() {
      return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
    };
    bDflt = function() {
      return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
    };
    guze = function() {
      return [gzs, gzl];
    };
    zule = function() {
      return [zls];
    };
    pbf = function(msg) {
      return postMessage(msg, [msg.buffer]);
    };
    gopt = function(o) {
      return o && {
        out: o.size && new u8(o.size),
        dictionary: o.dictionary
      };
    };
    astrm = function(strm) {
      strm.ondata = function(dat, final) {
        return postMessage([dat, final], [dat.buffer]);
      };
      return function(ev) {
        if (ev.data.length) {
          strm.push(ev.data[0], ev.data[1]);
          postMessage([ev.data[0].length]);
        } else
          strm.flush();
      };
    };
    astrmify = function(fns, strm, opts, init, id, flush, ext) {
      var t;
      var w = wrkr(fns, init, id, function(err2, dat) {
        if (err2)
          w.terminate(), strm.ondata.call(strm, err2);
        else if (!Array.isArray(dat))
          ext(dat);
        else if (dat.length == 1) {
          strm.queuedSize -= dat[0];
          if (strm.ondrain)
            strm.ondrain(dat[0]);
        } else {
          if (dat[1])
            w.terminate();
          strm.ondata.call(strm, err2, dat[0], dat[1]);
        }
      });
      w.postMessage(opts);
      strm.queuedSize = 0;
      strm.push = function(d2, f2) {
        if (!strm.ondata)
          err(5);
        if (t)
          strm.ondata(err(4, 0, 1), null, !!f2);
        strm.queuedSize += d2.length;
        w.postMessage([d2, t = f2], [d2.buffer]);
      };
      strm.terminate = function() {
        w.terminate();
      };
      if (flush) {
        strm.flush = function() {
          w.postMessage([]);
        };
      }
    };
    b2 = function(d2, b) {
      return d2[b] | d2[b + 1] << 8;
    };
    b4 = function(d2, b) {
      return (d2[b] | d2[b + 1] << 8 | d2[b + 2] << 16 | d2[b + 3] << 24) >>> 0;
    };
    b8 = function(d2, b) {
      return b4(d2, b) + b4(d2, b + 4) * 4294967296;
    };
    wbytes = function(d2, b, v2) {
      for (; v2; ++b)
        d2[b] = v2, v2 >>>= 8;
    };
    gzh = function(c, o) {
      var fn = o.filename;
      c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
      if (o.mtime != 0)
        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
      if (fn) {
        c[3] = 8;
        for (var i = 0; i <= fn.length; ++i)
          c[i + 10] = fn.charCodeAt(i);
      }
    };
    gzs = function(d2) {
      if (d2[0] != 31 || d2[1] != 139 || d2[2] != 8)
        err(6, "invalid gzip data");
      var flg = d2[3];
      var st = 10;
      if (flg & 4)
        st += (d2[10] | d2[11] << 8) + 2;
      for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d2[st++])
        ;
      return st + (flg & 2);
    };
    gzl = function(d2) {
      var l = d2.length;
      return (d2[l - 4] | d2[l - 3] << 8 | d2[l - 2] << 16 | d2[l - 1] << 24) >>> 0;
    };
    gzhl = function(o) {
      return 10 + (o.filename ? o.filename.length + 1 : 0);
    };
    zlh = function(c, o) {
      var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
      c[0] = 120, c[1] = fl2 << 6 | (o.dictionary && 32);
      c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
      if (o.dictionary) {
        var h = adler();
        h.p(o.dictionary);
        wbytes(c, 2, h.d());
      }
    };
    zls = function(d2, dict) {
      if ((d2[0] & 15) != 8 || d2[0] >> 4 > 7 || (d2[0] << 8 | d2[1]) % 31)
        err(6, "invalid zlib data");
      if ((d2[1] >> 5 & 1) == +!dict)
        err(6, "invalid zlib data: " + (d2[1] & 32 ? "need" : "unexpected") + " dictionary");
      return (d2[1] >> 3 & 4) + 2;
    };
    Deflate = function() {
      function Deflate2(opts, cb) {
        if (typeof opts == "function")
          cb = opts, opts = {};
        this.ondata = cb;
        this.o = opts || {};
        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
        this.b = new u8(98304);
        if (this.o.dictionary) {
          var dict = this.o.dictionary.subarray(-32768);
          this.b.set(dict, 32768 - dict.length);
          this.s.i = 32768 - dict.length;
        }
      }
      Deflate2.prototype.p = function(c, f2) {
        this.ondata(dopt(c, this.o, 0, 0, this.s), f2);
      };
      Deflate2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        if (this.s.l)
          err(4);
        var endLen = chunk.length + this.s.z;
        if (endLen > this.b.length) {
          if (endLen > 2 * this.b.length - 32768) {
            var newBuf = new u8(endLen & -32768);
            newBuf.set(this.b.subarray(0, this.s.z));
            this.b = newBuf;
          }
          var split = this.b.length - this.s.z;
          this.b.set(chunk.subarray(0, split), this.s.z);
          this.s.z = this.b.length;
          this.p(this.b, false);
          this.b.set(this.b.subarray(-32768));
          this.b.set(chunk.subarray(split), 32768);
          this.s.z = chunk.length - split + 32768;
          this.s.i = 32766, this.s.w = 32768;
        } else {
          this.b.set(chunk, this.s.z);
          this.s.z += chunk.length;
        }
        this.s.l = final & 1;
        if (this.s.z > this.s.w + 8191 || final) {
          this.p(this.b, final || false);
          this.s.w = this.s.i, this.s.i -= 2;
        }
      };
      Deflate2.prototype.flush = function() {
        if (!this.ondata)
          err(5);
        if (this.s.l)
          err(4);
        this.p(this.b, false);
        this.s.w = this.s.i, this.s.i -= 2;
      };
      return Deflate2;
    }();
    AsyncDeflate = /* @__PURE__ */ function() {
      function AsyncDeflate2(opts, cb) {
        astrmify([
          bDflt,
          function() {
            return [astrm, Deflate];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Deflate(ev.data);
          onmessage = astrm(strm);
        }, 6, 1);
      }
      return AsyncDeflate2;
    }();
    Inflate = function() {
      function Inflate2(opts, cb) {
        if (typeof opts == "function")
          cb = opts, opts = {};
        this.ondata = cb;
        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
        this.s = { i: 0, b: dict ? dict.length : 0 };
        this.o = new u8(32768);
        this.p = new u8(0);
        if (dict)
          this.o.set(dict);
      }
      Inflate2.prototype.e = function(c) {
        if (!this.ondata)
          err(5);
        if (this.d)
          err(4);
        if (!this.p.length)
          this.p = c;
        else if (c.length) {
          var n = new u8(this.p.length + c.length);
          n.set(this.p), n.set(c, this.p.length), this.p = n;
        }
      };
      Inflate2.prototype.c = function(final) {
        this.s.i = +(this.d = final || false);
        var bts = this.s.b;
        var dt = inflt(this.p, this.s, this.o);
        this.ondata(slc(dt, bts, this.s.b), this.d);
        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
      };
      Inflate2.prototype.push = function(chunk, final) {
        this.e(chunk), this.c(final);
      };
      return Inflate2;
    }();
    AsyncInflate = /* @__PURE__ */ function() {
      function AsyncInflate2(opts, cb) {
        astrmify([
          bInflt,
          function() {
            return [astrm, Inflate];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Inflate(ev.data);
          onmessage = astrm(strm);
        }, 7, 0);
      }
      return AsyncInflate2;
    }();
    Gzip = function() {
      function Gzip2(opts, cb) {
        this.c = crc();
        this.l = 0;
        this.v = 1;
        Deflate.call(this, opts, cb);
      }
      Gzip2.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        this.l += chunk.length;
        Deflate.prototype.push.call(this, chunk, final);
      };
      Gzip2.prototype.p = function(c, f2) {
        var raw = dopt(c, this.o, this.v && gzhl(this.o), f2 && 8, this.s);
        if (this.v)
          gzh(raw, this.o), this.v = 0;
        if (f2)
          wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
        this.ondata(raw, f2);
      };
      Gzip2.prototype.flush = function() {
        Deflate.prototype.flush.call(this);
      };
      return Gzip2;
    }();
    Gunzip = function() {
      function Gunzip2(opts, cb) {
        this.v = 1;
        this.r = 0;
        Inflate.call(this, opts, cb);
      }
      Gunzip2.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        this.r += chunk.length;
        if (this.v) {
          var p2 = this.p.subarray(this.v - 1);
          var s = p2.length > 3 ? gzs(p2) : 4;
          if (s > p2.length) {
            if (!final)
              return;
          } else if (this.v > 1 && this.onmember) {
            this.onmember(this.r - p2.length);
          }
          this.p = p2.subarray(s), this.v = 0;
        }
        Inflate.prototype.c.call(this, final);
        if (this.s.f && !this.s.l && !final) {
          this.v = shft(this.s.p) + 9;
          this.s = { i: 0 };
          this.o = new u8(0);
          this.push(new u8(0), final);
        }
      };
      return Gunzip2;
    }();
    AsyncGunzip = /* @__PURE__ */ function() {
      function AsyncGunzip2(opts, cb) {
        var _this = this;
        astrmify([
          bInflt,
          guze,
          function() {
            return [astrm, Inflate, Gunzip];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Gunzip(ev.data);
          strm.onmember = function(offset) {
            return postMessage(offset);
          };
          onmessage = astrm(strm);
        }, 9, 0, function(offset) {
          return _this.onmember && _this.onmember(offset);
        });
      }
      return AsyncGunzip2;
    }();
    Zlib = function() {
      function Zlib2(opts, cb) {
        this.c = adler();
        this.v = 1;
        Deflate.call(this, opts, cb);
      }
      Zlib2.prototype.push = function(chunk, final) {
        this.c.p(chunk);
        Deflate.prototype.push.call(this, chunk, final);
      };
      Zlib2.prototype.p = function(c, f2) {
        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f2 && 4, this.s);
        if (this.v)
          zlh(raw, this.o), this.v = 0;
        if (f2)
          wbytes(raw, raw.length - 4, this.c.d());
        this.ondata(raw, f2);
      };
      Zlib2.prototype.flush = function() {
        Deflate.prototype.flush.call(this);
      };
      return Zlib2;
    }();
    Unzlib = function() {
      function Unzlib2(opts, cb) {
        Inflate.call(this, opts, cb);
        this.v = opts && opts.dictionary ? 2 : 1;
      }
      Unzlib2.prototype.push = function(chunk, final) {
        Inflate.prototype.e.call(this, chunk);
        if (this.v) {
          if (this.p.length < 6 && !final)
            return;
          this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
        }
        if (final) {
          if (this.p.length < 4)
            err(6, "invalid zlib data");
          this.p = this.p.subarray(0, -4);
        }
        Inflate.prototype.c.call(this, final);
      };
      return Unzlib2;
    }();
    AsyncUnzlib = /* @__PURE__ */ function() {
      function AsyncUnzlib2(opts, cb) {
        astrmify([
          bInflt,
          zule,
          function() {
            return [astrm, Inflate, Unzlib];
          }
        ], this, StrmOpt.call(this, opts, cb), function(ev) {
          var strm = new Unzlib(ev.data);
          onmessage = astrm(strm);
        }, 11, 0);
      }
      return AsyncUnzlib2;
    }();
    Decompress = function() {
      function Decompress2(opts, cb) {
        this.o = StrmOpt.call(this, opts, cb) || {};
        this.G = Gunzip;
        this.I = Inflate;
        this.Z = Unzlib;
      }
      Decompress2.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(dat, final) {
          _this.ondata(dat, final);
        };
      };
      Decompress2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        if (!this.s) {
          if (this.p && this.p.length) {
            var n = new u8(this.p.length + chunk.length);
            n.set(this.p), n.set(chunk, this.p.length);
          } else
            this.p = chunk;
          if (this.p.length > 2) {
            this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
            this.i();
            this.s.push(this.p, final);
            this.p = null;
          }
        } else
          this.s.push(chunk, final);
      };
      return Decompress2;
    }();
    AsyncDecompress = function() {
      function AsyncDecompress2(opts, cb) {
        Decompress.call(this, opts, cb);
        this.queuedSize = 0;
        this.G = AsyncGunzip;
        this.I = AsyncInflate;
        this.Z = AsyncUnzlib;
      }
      AsyncDecompress2.prototype.i = function() {
        var _this = this;
        this.s.ondata = function(err2, dat, final) {
          _this.ondata(err2, dat, final);
        };
        this.s.ondrain = function(size) {
          _this.queuedSize -= size;
          if (_this.ondrain)
            _this.ondrain(size);
        };
      };
      AsyncDecompress2.prototype.push = function(chunk, final) {
        this.queuedSize += chunk.length;
        Decompress.prototype.push.call(this, chunk, final);
      };
      return AsyncDecompress2;
    }();
    te = typeof TextEncoder != "undefined" && new TextEncoder();
    td = typeof TextDecoder != "undefined" && new TextDecoder();
    tds = 0;
    try {
      td.decode(et, { stream: true });
      tds = 1;
    } catch (e) {
    }
    dutf8 = function(d2) {
      for (var r = "", i = 0; ; ) {
        var c = d2[i++];
        var eb = (c > 127) + (c > 223) + (c > 239);
        if (i + eb > d2.length)
          return { s: r, r: slc(d2, i - 1) };
        if (!eb)
          r += String.fromCharCode(c);
        else if (eb == 3) {
          c = ((c & 15) << 18 | (d2[i++] & 63) << 12 | (d2[i++] & 63) << 6 | d2[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
        } else if (eb & 1)
          r += String.fromCharCode((c & 31) << 6 | d2[i++] & 63);
        else
          r += String.fromCharCode((c & 15) << 12 | (d2[i++] & 63) << 6 | d2[i++] & 63);
      }
    };
    DecodeUTF8 = function() {
      function DecodeUTF82(cb) {
        this.ondata = cb;
        if (tds)
          this.t = new TextDecoder();
        else
          this.p = et;
      }
      DecodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        final = !!final;
        if (this.t) {
          this.ondata(this.t.decode(chunk, { stream: true }), final);
          if (final) {
            if (this.t.decode().length)
              err(8);
            this.t = null;
          }
          return;
        }
        if (!this.p)
          err(4);
        var dat = new u8(this.p.length + chunk.length);
        dat.set(this.p);
        dat.set(chunk, this.p.length);
        var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
        if (final) {
          if (r.length)
            err(8);
          this.p = null;
        } else
          this.p = r;
        this.ondata(s, final);
      };
      return DecodeUTF82;
    }();
    EncodeUTF8 = function() {
      function EncodeUTF82(cb) {
        this.ondata = cb;
      }
      EncodeUTF82.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        if (this.d)
          err(4);
        this.ondata(strToU8(chunk), this.d = final || false);
      };
      return EncodeUTF82;
    }();
    dbf = function(l) {
      return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
    };
    z64e = function(d2, b) {
      for (; b2(d2, b) != 1; b += 4 + b2(d2, b + 2))
        ;
      return [b8(d2, b + 12), b8(d2, b + 4), b8(d2, b + 20)];
    };
    exfl = function(ex) {
      var le = 0;
      if (ex) {
        for (var k in ex) {
          var l = ex[k].length;
          if (l > 65535)
            err(9);
          le += l + 4;
        }
      }
      return le;
    };
    wzh = function(d2, b, f2, fn, u, c, ce, co) {
      var fl2 = fn.length, ex = f2.extra, col = co && co.length;
      var exl = exfl(ex);
      wbytes(d2, b, ce != null ? 33639248 : 67324752), b += 4;
      if (ce != null)
        d2[b++] = 20, d2[b++] = f2.os;
      d2[b] = 20, b += 2;
      d2[b++] = f2.flag << 1 | (c < 0 && 8), d2[b++] = u && 8;
      d2[b++] = f2.compression & 255, d2[b++] = f2.compression >> 8;
      var dt = new Date(f2.mtime == null ? Date.now() : f2.mtime), y = dt.getFullYear() - 1980;
      if (y < 0 || y > 119)
        err(10);
      wbytes(d2, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
      if (c != -1) {
        wbytes(d2, b, f2.crc);
        wbytes(d2, b + 4, c < 0 ? -c - 2 : c);
        wbytes(d2, b + 8, f2.size);
      }
      wbytes(d2, b + 12, fl2);
      wbytes(d2, b + 14, exl), b += 16;
      if (ce != null) {
        wbytes(d2, b, col);
        wbytes(d2, b + 6, f2.attrs);
        wbytes(d2, b + 10, ce), b += 14;
      }
      d2.set(fn, b);
      b += fl2;
      if (exl) {
        for (var k in ex) {
          var exf = ex[k], l = exf.length;
          wbytes(d2, b, +k);
          wbytes(d2, b + 2, l);
          d2.set(exf, b + 4), b += 4 + l;
        }
      }
      if (col)
        d2.set(co, b), b += col;
      return b;
    };
    wzf = function(o, b, c, d2, e) {
      wbytes(o, b, 101010256);
      wbytes(o, b + 8, c);
      wbytes(o, b + 10, c);
      wbytes(o, b + 12, d2);
      wbytes(o, b + 16, e);
    };
    ZipPassThrough = function() {
      function ZipPassThrough2(filename) {
        this.filename = filename;
        this.c = crc();
        this.size = 0;
        this.compression = 0;
      }
      ZipPassThrough2.prototype.process = function(chunk, final) {
        this.ondata(null, chunk, final);
      };
      ZipPassThrough2.prototype.push = function(chunk, final) {
        if (!this.ondata)
          err(5);
        this.c.p(chunk);
        this.size += chunk.length;
        if (final)
          this.crc = this.c.d();
        this.process(chunk, final || false);
      };
      return ZipPassThrough2;
    }();
    ZipDeflate = function() {
      function ZipDeflate2(filename, opts) {
        var _this = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new Deflate(opts, function(dat, final) {
          _this.ondata(null, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
      }
      ZipDeflate2.prototype.process = function(chunk, final) {
        try {
          this.d.push(chunk, final);
        } catch (e) {
          this.ondata(e, null, final);
        }
      };
      ZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return ZipDeflate2;
    }();
    AsyncZipDeflate = function() {
      function AsyncZipDeflate2(filename, opts) {
        var _this = this;
        if (!opts)
          opts = {};
        ZipPassThrough.call(this, filename);
        this.d = new AsyncDeflate(opts, function(err2, dat, final) {
          _this.ondata(err2, dat, final);
        });
        this.compression = 8;
        this.flag = dbf(opts.level);
        this.terminate = this.d.terminate;
      }
      AsyncZipDeflate2.prototype.process = function(chunk, final) {
        this.d.push(chunk, final);
      };
      AsyncZipDeflate2.prototype.push = function(chunk, final) {
        ZipPassThrough.prototype.push.call(this, chunk, final);
      };
      return AsyncZipDeflate2;
    }();
    Zip = function() {
      function Zip2(cb) {
        this.ondata = cb;
        this.u = [];
        this.d = 1;
      }
      Zip2.prototype.add = function(file) {
        var _this = this;
        if (!this.ondata)
          err(5);
        if (this.d & 2)
          this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
        else {
          var f2 = strToU8(file.filename), fl_1 = f2.length;
          var com = file.comment, o = com && strToU8(com);
          var u = fl_1 != file.filename.length || o && com.length != o.length;
          var hl_1 = fl_1 + exfl(file.extra) + 30;
          if (fl_1 > 65535)
            this.ondata(err(11, 0, 1), null, false);
          var header = new u8(hl_1);
          wzh(header, 0, file, f2, u, -1);
          var chks_1 = [header];
          var pAll_1 = function() {
            for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
              var chk = chks_2[_i];
              _this.ondata(null, chk, false);
            }
            chks_1 = [];
          };
          var tr_1 = this.d;
          this.d = 0;
          var ind_1 = this.u.length;
          var uf_1 = mrg(file, {
            f: f2,
            u,
            o,
            t: function() {
              if (file.terminate)
                file.terminate();
            },
            r: function() {
              pAll_1();
              if (tr_1) {
                var nxt = _this.u[ind_1 + 1];
                if (nxt)
                  nxt.r();
                else
                  _this.d = 1;
              }
              tr_1 = 1;
            }
          });
          var cl_1 = 0;
          file.ondata = function(err2, dat, final) {
            if (err2) {
              _this.ondata(err2, dat, final);
              _this.terminate();
            } else {
              cl_1 += dat.length;
              chks_1.push(dat);
              if (final) {
                var dd = new u8(16);
                wbytes(dd, 0, 134695760);
                wbytes(dd, 4, file.crc);
                wbytes(dd, 8, cl_1);
                wbytes(dd, 12, file.size);
                chks_1.push(dd);
                uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
                if (tr_1)
                  uf_1.r();
                tr_1 = 1;
              } else if (tr_1)
                pAll_1();
            }
          };
          this.u.push(uf_1);
        }
      };
      Zip2.prototype.end = function() {
        var _this = this;
        if (this.d & 2) {
          this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
          return;
        }
        if (this.d)
          this.e();
        else
          this.u.push({
            r: function() {
              if (!(_this.d & 1))
                return;
              _this.u.splice(-1, 1);
              _this.e();
            },
            t: function() {
            }
          });
        this.d = 3;
      };
      Zip2.prototype.e = function() {
        var bt = 0, l = 0, tl = 0;
        for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
          var f2 = _a2[_i];
          tl += 46 + f2.f.length + exfl(f2.extra) + (f2.o ? f2.o.length : 0);
        }
        var out = new u8(tl + 22);
        for (var _b2 = 0, _c = this.u; _b2 < _c.length; _b2++) {
          var f2 = _c[_b2];
          wzh(out, bt, f2, f2.f, f2.u, -f2.c - 2, l, f2.o);
          bt += 46 + f2.f.length + exfl(f2.extra) + (f2.o ? f2.o.length : 0), l += f2.b;
        }
        wzf(out, bt, this.u.length, tl, l);
        this.ondata(null, out, true);
        this.d = 2;
      };
      Zip2.prototype.terminate = function() {
        for (var _i = 0, _a2 = this.u; _i < _a2.length; _i++) {
          var f2 = _a2[_i];
          f2.t();
        }
        this.d = 2;
      };
      return Zip2;
    }();
    UnzipPassThrough = function() {
      function UnzipPassThrough2() {
      }
      UnzipPassThrough2.prototype.push = function(data, final) {
        this.ondata(null, data, final);
      };
      UnzipPassThrough2.compression = 0;
      return UnzipPassThrough2;
    }();
    UnzipInflate = function() {
      function UnzipInflate2() {
        var _this = this;
        this.i = new Inflate(function(dat, final) {
          _this.ondata(null, dat, final);
        });
      }
      UnzipInflate2.prototype.push = function(data, final) {
        try {
          this.i.push(data, final);
        } catch (e) {
          this.ondata(e, null, final);
        }
      };
      UnzipInflate2.compression = 8;
      return UnzipInflate2;
    }();
    AsyncUnzipInflate = function() {
      function AsyncUnzipInflate2(_, sz) {
        var _this = this;
        if (sz < 32e4) {
          this.i = new Inflate(function(dat, final) {
            _this.ondata(null, dat, final);
          });
        } else {
          this.i = new AsyncInflate(function(err2, dat, final) {
            _this.ondata(err2, dat, final);
          });
          this.terminate = this.i.terminate;
        }
      }
      AsyncUnzipInflate2.prototype.push = function(data, final) {
        if (this.i.terminate)
          data = slc(data, 0);
        this.i.push(data, final);
      };
      AsyncUnzipInflate2.compression = 8;
      return AsyncUnzipInflate2;
    }();
    Unzip = function() {
      function Unzip2(cb) {
        this.onfile = cb;
        this.k = [];
        this.o = {
          0: UnzipPassThrough
        };
        this.p = et;
      }
      Unzip2.prototype.push = function(chunk, final) {
        var _this = this;
        if (!this.onfile)
          err(5);
        if (!this.p)
          err(4);
        if (this.c > 0) {
          var len = Math.min(this.c, chunk.length);
          var toAdd = chunk.subarray(0, len);
          this.c -= len;
          if (this.d)
            this.d.push(toAdd, !this.c);
          else
            this.k[0].push(toAdd);
          chunk = chunk.subarray(len);
          if (chunk.length)
            return this.push(chunk, final);
        } else {
          var f2 = 0, i = 0, is = void 0, buf = void 0;
          if (!this.p.length)
            buf = chunk;
          else if (!chunk.length)
            buf = this.p;
          else {
            buf = new u8(this.p.length + chunk.length);
            buf.set(this.p), buf.set(chunk, this.p.length);
          }
          var l = buf.length, oc = this.c, add = oc && this.d;
          var _loop_2 = function() {
            var _a2;
            var sig = b4(buf, i);
            if (sig == 67324752) {
              f2 = 1, is = i;
              this_1.d = null;
              this_1.c = 0;
              var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
              if (l > i + 30 + fnl + es) {
                var chks_3 = [];
                this_1.k.unshift(chks_3);
                f2 = 2;
                var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
                var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
                if (sc_1 == 4294967295) {
                  _a2 = dd ? [-2] : z64e(buf, i), sc_1 = _a2[0], su_1 = _a2[1];
                } else if (dd)
                  sc_1 = -1;
                i += es;
                this_1.c = sc_1;
                var d_1;
                var file_1 = {
                  name: fn_1,
                  compression: cmp_1,
                  start: function() {
                    if (!file_1.ondata)
                      err(5);
                    if (!sc_1)
                      file_1.ondata(null, et, true);
                    else {
                      var ctr = _this.o[cmp_1];
                      if (!ctr)
                        file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                      d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);
                      d_1.ondata = function(err2, dat3, final2) {
                        file_1.ondata(err2, dat3, final2);
                      };
                      for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                        var dat2 = chks_4[_i];
                        d_1.push(dat2, false);
                      }
                      if (_this.k[0] == chks_3 && _this.c)
                        _this.d = d_1;
                      else
                        d_1.push(et, true);
                    }
                  },
                  terminate: function() {
                    if (d_1 && d_1.terminate)
                      d_1.terminate();
                  }
                };
                if (sc_1 >= 0)
                  file_1.size = sc_1, file_1.originalSize = su_1;
                this_1.onfile(file_1);
              }
              return "break";
            } else if (oc) {
              if (sig == 134695760) {
                is = i += 12 + (oc == -2 && 8), f2 = 3, this_1.c = 0;
                return "break";
              } else if (sig == 33639248) {
                is = i -= 4, f2 = 3, this_1.c = 0;
                return "break";
              }
            }
          };
          var this_1 = this;
          for (; i < l - 4; ++i) {
            var state_1 = _loop_2();
            if (state_1 === "break")
              break;
          }
          this.p = et;
          if (oc < 0) {
            var dat = f2 ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 134695760 && 4)) : buf.subarray(0, i);
            if (add)
              add.push(dat, !!f2);
            else
              this.k[+(f2 == 2)].push(dat);
          }
          if (f2 & 2)
            return this.push(buf.subarray(i), final);
          this.p = buf.subarray(i);
        }
        if (final) {
          if (this.c)
            err(13);
          this.p = null;
        }
      };
      Unzip2.prototype.register = function(decoder) {
        this.o[decoder.compression] = decoder;
      };
      return Unzip2;
    }();
  }
});

// node_modules/three/examples/jsm/curves/NURBSUtils.js
function findSpan(p2, u, U) {
  const n = U.length - p2 - 1;
  if (u >= U[n]) {
    return n - 1;
  }
  if (u <= U[p2]) {
    return p2;
  }
  let low = p2;
  let high = n;
  let mid = Math.floor((low + high) / 2);
  while (u < U[mid] || u >= U[mid + 1]) {
    if (u < U[mid]) {
      high = mid;
    } else {
      low = mid;
    }
    mid = Math.floor((low + high) / 2);
  }
  return mid;
}
function calcBasisFunctions(span, u, p2, U) {
  const N = [];
  const left = [];
  const right = [];
  N[0] = 1;
  for (let j = 1; j <= p2; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r = 0; r < j; ++r) {
      const rv = right[r + 1];
      const lv = left[j - r];
      const temp = N[r] / (rv + lv);
      N[r] = saved + rv * temp;
      saved = lv * temp;
    }
    N[j] = saved;
  }
  return N;
}
function calcBSplinePoint(p2, U, P, u) {
  const span = findSpan(p2, u, U);
  const N = calcBasisFunctions(span, u, p2, U);
  const C = new Vector4(0, 0, 0, 0);
  for (let j = 0; j <= p2; ++j) {
    const point = P[span - p2 + j];
    const Nj = N[j];
    const wNj = point.w * Nj;
    C.x += point.x * wNj;
    C.y += point.y * wNj;
    C.z += point.z * wNj;
    C.w += point.w * Nj;
  }
  return C;
}
function calcBasisFunctionDerivatives(span, u, p2, n, U) {
  const zeroArr = [];
  for (let i = 0; i <= p2; ++i)
    zeroArr[i] = 0;
  const ders = [];
  for (let i = 0; i <= n; ++i)
    ders[i] = zeroArr.slice(0);
  const ndu = [];
  for (let i = 0; i <= p2; ++i)
    ndu[i] = zeroArr.slice(0);
  ndu[0][0] = 1;
  const left = zeroArr.slice(0);
  const right = zeroArr.slice(0);
  for (let j = 1; j <= p2; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    let saved = 0;
    for (let r2 = 0; r2 < j; ++r2) {
      const rv = right[r2 + 1];
      const lv = left[j - r2];
      ndu[j][r2] = rv + lv;
      const temp = ndu[r2][j - 1] / ndu[j][r2];
      ndu[r2][j] = saved + rv * temp;
      saved = lv * temp;
    }
    ndu[j][j] = saved;
  }
  for (let j = 0; j <= p2; ++j) {
    ders[0][j] = ndu[j][p2];
  }
  for (let r2 = 0; r2 <= p2; ++r2) {
    let s1 = 0;
    let s2 = 1;
    const a = [];
    for (let i = 0; i <= p2; ++i) {
      a[i] = zeroArr.slice(0);
    }
    a[0][0] = 1;
    for (let k = 1; k <= n; ++k) {
      let d2 = 0;
      const rk = r2 - k;
      const pk = p2 - k;
      if (r2 >= k) {
        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
        d2 = a[s2][0] * ndu[rk][pk];
      }
      const j1 = rk >= -1 ? 1 : -rk;
      const j2 = r2 - 1 <= pk ? k - 1 : p2 - r2;
      for (let j3 = j1; j3 <= j2; ++j3) {
        a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];
        d2 += a[s2][j3] * ndu[rk + j3][pk];
      }
      if (r2 <= pk) {
        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];
        d2 += a[s2][k] * ndu[r2][pk];
      }
      ders[k][r2] = d2;
      const j = s1;
      s1 = s2;
      s2 = j;
    }
  }
  let r = p2;
  for (let k = 1; k <= n; ++k) {
    for (let j = 0; j <= p2; ++j) {
      ders[k][j] *= r;
    }
    r *= p2 - k;
  }
  return ders;
}
function calcBSplineDerivatives(p2, U, P, u, nd) {
  const du = nd < p2 ? nd : p2;
  const CK = [];
  const span = findSpan(p2, u, U);
  const nders = calcBasisFunctionDerivatives(span, u, p2, du, U);
  const Pw = [];
  for (let i = 0; i < P.length; ++i) {
    const point = P[i].clone();
    const w = point.w;
    point.x *= w;
    point.y *= w;
    point.z *= w;
    Pw[i] = point;
  }
  for (let k = 0; k <= du; ++k) {
    const point = Pw[span - p2].clone().multiplyScalar(nders[k][0]);
    for (let j = 1; j <= p2; ++j) {
      point.add(Pw[span - p2 + j].clone().multiplyScalar(nders[k][j]));
    }
    CK[k] = point;
  }
  for (let k = du + 1; k <= nd + 1; ++k) {
    CK[k] = new Vector4(0, 0, 0);
  }
  return CK;
}
function calcKoverI(k, i) {
  let nom = 1;
  for (let j = 2; j <= k; ++j) {
    nom *= j;
  }
  let denom = 1;
  for (let j = 2; j <= i; ++j) {
    denom *= j;
  }
  for (let j = 2; j <= k - i; ++j) {
    denom *= j;
  }
  return nom / denom;
}
function calcRationalCurveDerivatives(Pders) {
  const nd = Pders.length;
  const Aders = [];
  const wders = [];
  for (let i = 0; i < nd; ++i) {
    const point = Pders[i];
    Aders[i] = new Vector3(point.x, point.y, point.z);
    wders[i] = point.w;
  }
  const CK = [];
  for (let k = 0; k < nd; ++k) {
    const v2 = Aders[k].clone();
    for (let i = 1; i <= k; ++i) {
      v2.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));
    }
    CK[k] = v2.divideScalar(wders[0]);
  }
  return CK;
}
function calcNURBSDerivatives(p2, U, P, u, nd) {
  const Pders = calcBSplineDerivatives(p2, U, P, u, nd);
  return calcRationalCurveDerivatives(Pders);
}
var init_NURBSUtils = __esm({
  "node_modules/three/examples/jsm/curves/NURBSUtils.js"() {
    init_three_module();
  }
});

// node_modules/three/examples/jsm/curves/NURBSCurve.js
var NURBSCurve;
var init_NURBSCurve = __esm({
  "node_modules/three/examples/jsm/curves/NURBSCurve.js"() {
    init_three_module();
    init_NURBSUtils();
    NURBSCurve = class extends Curve {
      constructor(degree, knots, controlPoints, startKnot, endKnot) {
        super();
        this.degree = degree;
        this.knots = knots;
        this.controlPoints = [];
        this.startKnot = startKnot || 0;
        this.endKnot = endKnot || this.knots.length - 1;
        for (let i = 0; i < controlPoints.length; ++i) {
          const point = controlPoints[i];
          this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);
        }
      }
      getPoint(t, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]);
        const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);
        if (hpoint.w !== 1) {
          hpoint.divideScalar(hpoint.w);
        }
        return point.set(hpoint.x, hpoint.y, hpoint.z);
      }
      getTangent(t, optionalTarget = new Vector3()) {
        const tangent = optionalTarget;
        const u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);
        const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
        tangent.copy(ders[1]).normalize();
        return tangent;
      }
    };
  }
});

// node_modules/three/examples/jsm/loaders/FBXLoader.js
function isFbxFormatBinary(buffer) {
  const CORRECT = "Kaydara FBX Binary  \0";
  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
}
function isFbxFormatASCII(text) {
  const CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let cursor = 0;
  function read(offset) {
    const result = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result;
  }
  for (let i = 0; i < CORRECT.length; ++i) {
    const num = read(1);
    if (num === CORRECT[i]) {
      return false;
    }
  }
  return true;
}
function getFbxVersion(text) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match(versionRegExp);
  if (match) {
    const version = parseInt(match[1]);
    return version;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(time) {
  return time / 46186158e3;
}
function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  let index;
  switch (infoObject.mappingType) {
    case "ByPolygonVertex":
      index = polygonVertexIndex;
      break;
    case "ByPolygon":
      index = polygonIndex;
      break;
    case "ByVertice":
      index = vertexIndex;
      break;
    case "AllSame":
      index = infoObject.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
  }
  if (infoObject.referenceType === "IndexToDirect") index = infoObject.indices[index];
  const from = index * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}
function generateTransform(transformData) {
  const lTranslationM = new Matrix4();
  const lPreRotationM = new Matrix4();
  const lRotationM = new Matrix4();
  const lPostRotationM = new Matrix4();
  const lScalingM = new Matrix4();
  const lScalingPivotM = new Matrix4();
  const lScalingOffsetM = new Matrix4();
  const lRotationOffsetM = new Matrix4();
  const lRotationPivotM = new Matrix4();
  const lParentGX = new Matrix4();
  const lParentLX = new Matrix4();
  const lGlobalT = new Matrix4();
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
  if (transformData.preRotation) {
    const array = transformData.preRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || Euler.DEFAULT_ORDER);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.rotation) {
    const array = transformData.rotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || Euler.DEFAULT_ORDER);
    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.postRotation) {
    const array = transformData.postRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || Euler.DEFAULT_ORDER);
    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    lPostRotationM.invert();
  }
  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale));
  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }
  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
  const lParentGRM = new Matrix4();
  lParentGRM.extractRotation(lParentGX);
  const lParentTM = new Matrix4();
  lParentTM.copyPosition(lParentGX);
  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix4();
  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }
  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS);
  lTransform.premultiply(lParentGX.invert());
  return lTransform;
}
function getEulerOrder(order) {
  order = order || 0;
  const enums = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  if (order === 6) {
    console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
    return enums[0];
  }
  return enums[order];
}
function parseNumberArray(value) {
  const array = value.split(",").map(function(val) {
    return parseFloat(val);
  });
  return array;
}
function convertArrayBufferToString(buffer, from, to) {
  if (from === void 0) from = 0;
  if (to === void 0) to = buffer.byteLength;
  return new TextDecoder().decode(new Uint8Array(buffer, from, to));
}
function append(a, b) {
  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {
    a[j] = b[i];
  }
}
function slice(a, b, from, to) {
  for (let i = from, j = 0; i < to; i++, j++) {
    a[j] = b[i];
  }
  return a;
}
var fbxTree, connections, sceneGraph, FBXLoader, FBXTreeParser, GeometryParser, AnimationParser, TextParser, BinaryParser, BinaryReader, FBXTree, dataArray, tempEuler, tempVec;
var init_FBXLoader = __esm({
  "node_modules/three/examples/jsm/loaders/FBXLoader.js"() {
    init_three_module();
    init_fflate_module();
    init_NURBSCurve();
    FBXLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
        const loader = new FileLoader(this.manager);
        loader.setPath(scope.path);
        loader.setResponseType("arraybuffer");
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function(buffer) {
          try {
            onLoad(scope.parse(buffer, path));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      parse(FBXBuffer, path) {
        if (isFbxFormatBinary(FBXBuffer)) {
          fbxTree = new BinaryParser().parse(FBXBuffer);
        } else {
          const FBXText = convertArrayBufferToString(FBXBuffer);
          if (!isFbxFormatASCII(FBXText)) {
            throw new Error("THREE.FBXLoader: Unknown format.");
          }
          if (getFbxVersion(FBXText) < 7e3) {
            throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
          }
          fbxTree = new TextParser().parse(FBXText);
        }
        const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
        return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
      }
    };
    FBXTreeParser = class {
      constructor(textureLoader, manager) {
        this.textureLoader = textureLoader;
        this.manager = manager;
      }
      parse() {
        connections = this.parseConnections();
        const images = this.parseImages();
        const textures = this.parseTextures(images);
        const materials = this.parseMaterials(textures);
        const deformers = this.parseDeformers();
        const geometryMap = new GeometryParser().parse(deformers);
        this.parseScene(deformers, geometryMap, materials);
        return sceneGraph;
      }
      // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
      // and details the connection type
      parseConnections() {
        const connectionMap = /* @__PURE__ */ new Map();
        if ("Connections" in fbxTree) {
          const rawConnections = fbxTree.Connections.connections;
          rawConnections.forEach(function(rawConnection) {
            const fromID = rawConnection[0];
            const toID = rawConnection[1];
            const relationship = rawConnection[2];
            if (!connectionMap.has(fromID)) {
              connectionMap.set(fromID, {
                parents: [],
                children: []
              });
            }
            const parentRelationship = { ID: toID, relationship };
            connectionMap.get(fromID).parents.push(parentRelationship);
            if (!connectionMap.has(toID)) {
              connectionMap.set(toID, {
                parents: [],
                children: []
              });
            }
            const childRelationship = { ID: fromID, relationship };
            connectionMap.get(toID).children.push(childRelationship);
          });
        }
        return connectionMap;
      }
      // Parse FBXTree.Objects.Video for embedded image data
      // These images are connected to textures in FBXTree.Objects.Textures
      // via FBXTree.Connections.
      parseImages() {
        const images = {};
        const blobs = {};
        if ("Video" in fbxTree.Objects) {
          const videoNodes = fbxTree.Objects.Video;
          for (const nodeID in videoNodes) {
            const videoNode = videoNodes[nodeID];
            const id = parseInt(nodeID);
            images[id] = videoNode.RelativeFilename || videoNode.Filename;
            if ("Content" in videoNode) {
              const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
              const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
              if (arrayBufferContent || base64Content) {
                const image = this.parseImage(videoNodes[nodeID]);
                blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
              }
            }
          }
        }
        for (const id in images) {
          const filename = images[id];
          if (blobs[filename] !== void 0) images[id] = blobs[filename];
          else images[id] = images[id].split("\\").pop();
        }
        return images;
      }
      // Parse embedded image data in FBXTree.Video.Content
      parseImage(videoNode) {
        const content = videoNode.Content;
        const fileName = videoNode.RelativeFilename || videoNode.Filename;
        const extension = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
        let type;
        switch (extension) {
          case "bmp":
            type = "image/bmp";
            break;
          case "jpg":
          case "jpeg":
            type = "image/jpeg";
            break;
          case "png":
            type = "image/png";
            break;
          case "tif":
            type = "image/tiff";
            break;
          case "tga":
            if (this.manager.getHandler(".tga") === null) {
              console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
            }
            type = "image/tga";
            break;
          default:
            console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
            return;
        }
        if (typeof content === "string") {
          return "data:" + type + ";base64," + content;
        } else {
          const array = new Uint8Array(content);
          return window.URL.createObjectURL(new Blob([array], { type }));
        }
      }
      // Parse nodes in FBXTree.Objects.Texture
      // These contain details such as UV scaling, cropping, rotation etc and are connected
      // to images in FBXTree.Objects.Video
      parseTextures(images) {
        const textureMap = /* @__PURE__ */ new Map();
        if ("Texture" in fbxTree.Objects) {
          const textureNodes = fbxTree.Objects.Texture;
          for (const nodeID in textureNodes) {
            const texture = this.parseTexture(textureNodes[nodeID], images);
            textureMap.set(parseInt(nodeID), texture);
          }
        }
        return textureMap;
      }
      // Parse individual node in FBXTree.Objects.Texture
      parseTexture(textureNode, images) {
        const texture = this.loadTexture(textureNode, images);
        texture.ID = textureNode.id;
        texture.name = textureNode.attrName;
        const wrapModeU = textureNode.WrapModeU;
        const wrapModeV = textureNode.WrapModeV;
        const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
        const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
        texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
        texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
        if ("Scaling" in textureNode) {
          const values = textureNode.Scaling.value;
          texture.repeat.x = values[0];
          texture.repeat.y = values[1];
        }
        if ("Translation" in textureNode) {
          const values = textureNode.Translation.value;
          texture.offset.x = values[0];
          texture.offset.y = values[1];
        }
        return texture;
      }
      // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
      loadTexture(textureNode, images) {
        let fileName;
        const currentPath = this.textureLoader.path;
        const children = connections.get(textureNode.id).children;
        if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
          fileName = images[children[0].ID];
          if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
            this.textureLoader.setPath(void 0);
          }
        }
        let texture;
        const extension = textureNode.FileName.slice(-3).toLowerCase();
        if (extension === "tga") {
          const loader = this.manager.getHandler(".tga");
          if (loader === null) {
            console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", textureNode.RelativeFilename);
            texture = new Texture();
          } else {
            loader.setPath(this.textureLoader.path);
            texture = loader.load(fileName);
          }
        } else if (extension === "dds") {
          const loader = this.manager.getHandler(".dds");
          if (loader === null) {
            console.warn("FBXLoader: DDS loader not found, creating placeholder texture for", textureNode.RelativeFilename);
            texture = new Texture();
          } else {
            loader.setPath(this.textureLoader.path);
            texture = loader.load(fileName);
          }
        } else if (extension === "psd") {
          console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", textureNode.RelativeFilename);
          texture = new Texture();
        } else {
          texture = this.textureLoader.load(fileName);
        }
        this.textureLoader.setPath(currentPath);
        return texture;
      }
      // Parse nodes in FBXTree.Objects.Material
      parseMaterials(textureMap) {
        const materialMap = /* @__PURE__ */ new Map();
        if ("Material" in fbxTree.Objects) {
          const materialNodes = fbxTree.Objects.Material;
          for (const nodeID in materialNodes) {
            const material = this.parseMaterial(materialNodes[nodeID], textureMap);
            if (material !== null) materialMap.set(parseInt(nodeID), material);
          }
        }
        return materialMap;
      }
      // Parse single node in FBXTree.Objects.Material
      // Materials are connected to texture maps in FBXTree.Objects.Textures
      // FBX format currently only supports Lambert and Phong shading models
      parseMaterial(materialNode, textureMap) {
        const ID = materialNode.id;
        const name = materialNode.attrName;
        let type = materialNode.ShadingModel;
        if (typeof type === "object") {
          type = type.value;
        }
        if (!connections.has(ID)) return null;
        const parameters = this.parseParameters(materialNode, textureMap, ID);
        let material;
        switch (type.toLowerCase()) {
          case "phong":
            material = new MeshPhongMaterial();
            break;
          case "lambert":
            material = new MeshLambertMaterial();
            break;
          default:
            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
            material = new MeshPhongMaterial();
            break;
        }
        material.setValues(parameters);
        material.name = name;
        return material;
      }
      // Parse FBX material and return parameters suitable for a three.js material
      // Also parse the texture map and return any textures associated with the material
      parseParameters(materialNode, textureMap, ID) {
        const parameters = {};
        if (materialNode.BumpFactor) {
          parameters.bumpScale = materialNode.BumpFactor.value;
        }
        if (materialNode.Diffuse) {
          parameters.color = new Color().fromArray(materialNode.Diffuse.value).convertSRGBToLinear();
        } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
          parameters.color = new Color().fromArray(materialNode.DiffuseColor.value).convertSRGBToLinear();
        }
        if (materialNode.DisplacementFactor) {
          parameters.displacementScale = materialNode.DisplacementFactor.value;
        }
        if (materialNode.Emissive) {
          parameters.emissive = new Color().fromArray(materialNode.Emissive.value).convertSRGBToLinear();
        } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
          parameters.emissive = new Color().fromArray(materialNode.EmissiveColor.value).convertSRGBToLinear();
        }
        if (materialNode.EmissiveFactor) {
          parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
        }
        if (materialNode.Opacity) {
          parameters.opacity = parseFloat(materialNode.Opacity.value);
        }
        if (parameters.opacity < 1) {
          parameters.transparent = true;
        }
        if (materialNode.ReflectionFactor) {
          parameters.reflectivity = materialNode.ReflectionFactor.value;
        }
        if (materialNode.Shininess) {
          parameters.shininess = materialNode.Shininess.value;
        }
        if (materialNode.Specular) {
          parameters.specular = new Color().fromArray(materialNode.Specular.value).convertSRGBToLinear();
        } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
          parameters.specular = new Color().fromArray(materialNode.SpecularColor.value).convertSRGBToLinear();
        }
        const scope = this;
        connections.get(ID).children.forEach(function(child) {
          const type = child.relationship;
          switch (type) {
            case "Bump":
              parameters.bumpMap = scope.getTexture(textureMap, child.ID);
              break;
            case "Maya|TEX_ao_map":
              parameters.aoMap = scope.getTexture(textureMap, child.ID);
              break;
            case "DiffuseColor":
            case "Maya|TEX_color_map":
              parameters.map = scope.getTexture(textureMap, child.ID);
              if (parameters.map !== void 0) {
                parameters.map.colorSpace = SRGBColorSpace;
              }
              break;
            case "DisplacementColor":
              parameters.displacementMap = scope.getTexture(textureMap, child.ID);
              break;
            case "EmissiveColor":
              parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
              if (parameters.emissiveMap !== void 0) {
                parameters.emissiveMap.colorSpace = SRGBColorSpace;
              }
              break;
            case "NormalMap":
            case "Maya|TEX_normal_map":
              parameters.normalMap = scope.getTexture(textureMap, child.ID);
              break;
            case "ReflectionColor":
              parameters.envMap = scope.getTexture(textureMap, child.ID);
              if (parameters.envMap !== void 0) {
                parameters.envMap.mapping = EquirectangularReflectionMapping;
                parameters.envMap.colorSpace = SRGBColorSpace;
              }
              break;
            case "SpecularColor":
              parameters.specularMap = scope.getTexture(textureMap, child.ID);
              if (parameters.specularMap !== void 0) {
                parameters.specularMap.colorSpace = SRGBColorSpace;
              }
              break;
            case "TransparentColor":
            case "TransparencyFactor":
              parameters.alphaMap = scope.getTexture(textureMap, child.ID);
              parameters.transparent = true;
              break;
            case "AmbientColor":
            case "ShininessExponent":
            case "SpecularFactor":
            case "VectorDisplacementColor":
            default:
              console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
              break;
          }
        });
        return parameters;
      }
      // get a texture from the textureMap for use by a material.
      getTexture(textureMap, id) {
        if ("LayeredTexture" in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
          console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
          id = connections.get(id).children[0].ID;
        }
        return textureMap.get(id);
      }
      // Parse nodes in FBXTree.Objects.Deformer
      // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
      // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
      parseDeformers() {
        const skeletons = {};
        const morphTargets = {};
        if ("Deformer" in fbxTree.Objects) {
          const DeformerNodes = fbxTree.Objects.Deformer;
          for (const nodeID in DeformerNodes) {
            const deformerNode = DeformerNodes[nodeID];
            const relationships = connections.get(parseInt(nodeID));
            if (deformerNode.attrType === "Skin") {
              const skeleton = this.parseSkeleton(relationships, DeformerNodes);
              skeleton.ID = nodeID;
              if (relationships.parents.length > 1) console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
              skeleton.geometryID = relationships.parents[0].ID;
              skeletons[nodeID] = skeleton;
            } else if (deformerNode.attrType === "BlendShape") {
              const morphTarget = {
                id: nodeID
              };
              morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
              morphTarget.id = nodeID;
              if (relationships.parents.length > 1) console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
              morphTargets[nodeID] = morphTarget;
            }
          }
        }
        return {
          skeletons,
          morphTargets
        };
      }
      // Parse single nodes in FBXTree.Objects.Deformer
      // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
      // Each skin node represents a skeleton and each cluster node represents a bone
      parseSkeleton(relationships, deformerNodes) {
        const rawBones = [];
        relationships.children.forEach(function(child) {
          const boneNode = deformerNodes[child.ID];
          if (boneNode.attrType !== "Cluster") return;
          const rawBone = {
            ID: child.ID,
            indices: [],
            weights: [],
            transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
            // transform: new Matrix4().fromArray( boneNode.Transform.a ),
            // linkMode: boneNode.Mode,
          };
          if ("Indexes" in boneNode) {
            rawBone.indices = boneNode.Indexes.a;
            rawBone.weights = boneNode.Weights.a;
          }
          rawBones.push(rawBone);
        });
        return {
          rawBones,
          bones: []
        };
      }
      // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
      parseMorphTargets(relationships, deformerNodes) {
        const rawMorphTargets = [];
        for (let i = 0; i < relationships.children.length; i++) {
          const child = relationships.children[i];
          const morphTargetNode = deformerNodes[child.ID];
          const rawMorphTarget = {
            name: morphTargetNode.attrName,
            initialWeight: morphTargetNode.DeformPercent,
            id: morphTargetNode.id,
            fullWeights: morphTargetNode.FullWeights.a
          };
          if (morphTargetNode.attrType !== "BlendShapeChannel") return;
          rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
            return child2.relationship === void 0;
          })[0].ID;
          rawMorphTargets.push(rawMorphTarget);
        }
        return rawMorphTargets;
      }
      // create the main Group() to be returned by the loader
      parseScene(deformers, geometryMap, materialMap) {
        sceneGraph = new Group();
        const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
        const modelNodes = fbxTree.Objects.Model;
        const scope = this;
        modelMap.forEach(function(model) {
          const modelNode = modelNodes[model.ID];
          scope.setLookAtProperties(model, modelNode);
          const parentConnections = connections.get(model.ID).parents;
          parentConnections.forEach(function(connection) {
            const parent = modelMap.get(connection.ID);
            if (parent !== void 0) parent.add(model);
          });
          if (model.parent === null) {
            sceneGraph.add(model);
          }
        });
        this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
        this.addGlobalSceneSettings();
        sceneGraph.traverse(function(node) {
          if (node.userData.transformData) {
            if (node.parent) {
              node.userData.transformData.parentMatrix = node.parent.matrix;
              node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
            }
            const transform = generateTransform(node.userData.transformData);
            node.applyMatrix4(transform);
            node.updateWorldMatrix();
          }
        });
        const animations = new AnimationParser().parse();
        if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
          sceneGraph.children[0].animations = animations;
          sceneGraph = sceneGraph.children[0];
        }
        sceneGraph.animations = animations;
      }
      // parse nodes in FBXTree.Objects.Model
      parseModels(skeletons, geometryMap, materialMap) {
        const modelMap = /* @__PURE__ */ new Map();
        const modelNodes = fbxTree.Objects.Model;
        for (const nodeID in modelNodes) {
          const id = parseInt(nodeID);
          const node = modelNodes[nodeID];
          const relationships = connections.get(id);
          let model = this.buildSkeleton(relationships, skeletons, id, node.attrName);
          if (!model) {
            switch (node.attrType) {
              case "Camera":
                model = this.createCamera(relationships);
                break;
              case "Light":
                model = this.createLight(relationships);
                break;
              case "Mesh":
                model = this.createMesh(relationships, geometryMap, materialMap);
                break;
              case "NurbsCurve":
                model = this.createCurve(relationships, geometryMap);
                break;
              case "LimbNode":
              case "Root":
                model = new Bone();
                break;
              case "Null":
              default:
                model = new Group();
                break;
            }
            model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : "";
            model.userData.originalName = node.attrName;
            model.ID = id;
          }
          this.getTransformData(model, node);
          modelMap.set(id, model);
        }
        return modelMap;
      }
      buildSkeleton(relationships, skeletons, id, name) {
        let bone = null;
        relationships.parents.forEach(function(parent) {
          for (const ID in skeletons) {
            const skeleton = skeletons[ID];
            skeleton.rawBones.forEach(function(rawBone, i) {
              if (rawBone.ID === parent.ID) {
                const subBone = bone;
                bone = new Bone();
                bone.matrixWorld.copy(rawBone.transformLink);
                bone.name = name ? PropertyBinding.sanitizeNodeName(name) : "";
                bone.userData.originalName = name;
                bone.ID = id;
                skeleton.bones[i] = bone;
                if (subBone !== null) {
                  bone.add(subBone);
                }
              }
            });
          }
        });
        return bone;
      }
      // create a PerspectiveCamera or OrthographicCamera
      createCamera(relationships) {
        let model;
        let cameraAttribute;
        relationships.children.forEach(function(child) {
          const attr = fbxTree.Objects.NodeAttribute[child.ID];
          if (attr !== void 0) {
            cameraAttribute = attr;
          }
        });
        if (cameraAttribute === void 0) {
          model = new Object3D();
        } else {
          let type = 0;
          if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
            type = 1;
          }
          let nearClippingPlane = 1;
          if (cameraAttribute.NearPlane !== void 0) {
            nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
          }
          let farClippingPlane = 1e3;
          if (cameraAttribute.FarPlane !== void 0) {
            farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
          }
          let width = window.innerWidth;
          let height = window.innerHeight;
          if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
            width = cameraAttribute.AspectWidth.value;
            height = cameraAttribute.AspectHeight.value;
          }
          const aspect = width / height;
          let fov = 45;
          if (cameraAttribute.FieldOfView !== void 0) {
            fov = cameraAttribute.FieldOfView.value;
          }
          const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
          switch (type) {
            case 0:
              model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
              if (focalLength !== null) model.setFocalLength(focalLength);
              break;
            case 1:
              model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
              break;
            default:
              console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
              model = new Object3D();
              break;
          }
        }
        return model;
      }
      // Create a DirectionalLight, PointLight or SpotLight
      createLight(relationships) {
        let model;
        let lightAttribute;
        relationships.children.forEach(function(child) {
          const attr = fbxTree.Objects.NodeAttribute[child.ID];
          if (attr !== void 0) {
            lightAttribute = attr;
          }
        });
        if (lightAttribute === void 0) {
          model = new Object3D();
        } else {
          let type;
          if (lightAttribute.LightType === void 0) {
            type = 0;
          } else {
            type = lightAttribute.LightType.value;
          }
          let color = 16777215;
          if (lightAttribute.Color !== void 0) {
            color = new Color().fromArray(lightAttribute.Color.value).convertSRGBToLinear();
          }
          let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
          if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
            intensity = 0;
          }
          let distance2 = 0;
          if (lightAttribute.FarAttenuationEnd !== void 0) {
            if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
              distance2 = 0;
            } else {
              distance2 = lightAttribute.FarAttenuationEnd.value;
            }
          }
          const decay = 1;
          switch (type) {
            case 0:
              model = new PointLight(color, intensity, distance2, decay);
              break;
            case 1:
              model = new DirectionalLight(color, intensity);
              break;
            case 2:
              let angle2 = Math.PI / 3;
              if (lightAttribute.InnerAngle !== void 0) {
                angle2 = MathUtils.degToRad(lightAttribute.InnerAngle.value);
              }
              let penumbra = 0;
              if (lightAttribute.OuterAngle !== void 0) {
                penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
                penumbra = Math.max(penumbra, 1);
              }
              model = new SpotLight(color, intensity, distance2, angle2, penumbra, decay);
              break;
            default:
              console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
              model = new PointLight(color, intensity);
              break;
          }
          if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
            model.castShadow = true;
          }
        }
        return model;
      }
      createMesh(relationships, geometryMap, materialMap) {
        let model;
        let geometry = null;
        let material = null;
        const materials = [];
        relationships.children.forEach(function(child) {
          if (geometryMap.has(child.ID)) {
            geometry = geometryMap.get(child.ID);
          }
          if (materialMap.has(child.ID)) {
            materials.push(materialMap.get(child.ID));
          }
        });
        if (materials.length > 1) {
          material = materials;
        } else if (materials.length > 0) {
          material = materials[0];
        } else {
          material = new MeshPhongMaterial({
            name: Loader.DEFAULT_MATERIAL_NAME,
            color: 13421772
          });
          materials.push(material);
        }
        if ("color" in geometry.attributes) {
          materials.forEach(function(material2) {
            material2.vertexColors = true;
          });
        }
        if (geometry.FBX_Deformer) {
          model = new SkinnedMesh(geometry, material);
          model.normalizeSkinWeights();
        } else {
          model = new Mesh(geometry, material);
        }
        return model;
      }
      createCurve(relationships, geometryMap) {
        const geometry = relationships.children.reduce(function(geo, child) {
          if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);
          return geo;
        }, null);
        const material = new LineBasicMaterial({
          name: Loader.DEFAULT_MATERIAL_NAME,
          color: 3342591,
          linewidth: 1
        });
        return new Line(geometry, material);
      }
      // parse the model node for transform data
      getTransformData(model, modelNode) {
        const transformData = {};
        if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
        else transformData.eulerOrder = "ZYX";
        if ("Lcl_Translation" in modelNode) transformData.translation = modelNode.Lcl_Translation.value;
        if ("PreRotation" in modelNode) transformData.preRotation = modelNode.PreRotation.value;
        if ("Lcl_Rotation" in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;
        if ("PostRotation" in modelNode) transformData.postRotation = modelNode.PostRotation.value;
        if ("Lcl_Scaling" in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;
        if ("ScalingOffset" in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;
        if ("ScalingPivot" in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;
        if ("RotationOffset" in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;
        if ("RotationPivot" in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;
        model.userData.transformData = transformData;
      }
      setLookAtProperties(model, modelNode) {
        if ("LookAtProperty" in modelNode) {
          const children = connections.get(model.ID).children;
          children.forEach(function(child) {
            if (child.relationship === "LookAtProperty") {
              const lookAtTarget = fbxTree.Objects.Model[child.ID];
              if ("Lcl_Translation" in lookAtTarget) {
                const pos = lookAtTarget.Lcl_Translation.value;
                if (model.target !== void 0) {
                  model.target.position.fromArray(pos);
                  sceneGraph.add(model.target);
                } else {
                  model.lookAt(new Vector3().fromArray(pos));
                }
              }
            }
          });
        }
      }
      bindSkeleton(skeletons, geometryMap, modelMap) {
        const bindMatrices = this.parsePoseNodes();
        for (const ID in skeletons) {
          const skeleton = skeletons[ID];
          const parents = connections.get(parseInt(skeleton.ID)).parents;
          parents.forEach(function(parent) {
            if (geometryMap.has(parent.ID)) {
              const geoID = parent.ID;
              const geoRelationships = connections.get(geoID);
              geoRelationships.parents.forEach(function(geoConnParent) {
                if (modelMap.has(geoConnParent.ID)) {
                  const model = modelMap.get(geoConnParent.ID);
                  model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
                }
              });
            }
          });
        }
      }
      parsePoseNodes() {
        const bindMatrices = {};
        if ("Pose" in fbxTree.Objects) {
          const BindPoseNode = fbxTree.Objects.Pose;
          for (const nodeID in BindPoseNode) {
            if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
              const poseNodes = BindPoseNode[nodeID].PoseNode;
              if (Array.isArray(poseNodes)) {
                poseNodes.forEach(function(poseNode) {
                  bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
                });
              } else {
                bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
              }
            }
          }
        }
        return bindMatrices;
      }
      addGlobalSceneSettings() {
        if ("GlobalSettings" in fbxTree) {
          if ("AmbientColor" in fbxTree.GlobalSettings) {
            const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
            const r = ambientColor[0];
            const g2 = ambientColor[1];
            const b = ambientColor[2];
            if (r !== 0 || g2 !== 0 || b !== 0) {
              const color = new Color(r, g2, b).convertSRGBToLinear();
              sceneGraph.add(new AmbientLight(color, 1));
            }
          }
          if ("UnitScaleFactor" in fbxTree.GlobalSettings) {
            sceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;
          }
        }
      }
    };
    GeometryParser = class {
      constructor() {
        this.negativeMaterialIndices = false;
      }
      // Parse nodes in FBXTree.Objects.Geometry
      parse(deformers) {
        const geometryMap = /* @__PURE__ */ new Map();
        if ("Geometry" in fbxTree.Objects) {
          const geoNodes = fbxTree.Objects.Geometry;
          for (const nodeID in geoNodes) {
            const relationships = connections.get(parseInt(nodeID));
            const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
            geometryMap.set(parseInt(nodeID), geo);
          }
        }
        if (this.negativeMaterialIndices === true) {
          console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.");
        }
        return geometryMap;
      }
      // Parse single node in FBXTree.Objects.Geometry
      parseGeometry(relationships, geoNode, deformers) {
        switch (geoNode.attrType) {
          case "Mesh":
            return this.parseMeshGeometry(relationships, geoNode, deformers);
            break;
          case "NurbsCurve":
            return this.parseNurbsGeometry(geoNode);
            break;
        }
      }
      // Parse single node mesh geometry in FBXTree.Objects.Geometry
      parseMeshGeometry(relationships, geoNode, deformers) {
        const skeletons = deformers.skeletons;
        const morphTargets = [];
        const modelNodes = relationships.parents.map(function(parent) {
          return fbxTree.Objects.Model[parent.ID];
        });
        if (modelNodes.length === 0) return;
        const skeleton = relationships.children.reduce(function(skeleton2, child) {
          if (skeletons[child.ID] !== void 0) skeleton2 = skeletons[child.ID];
          return skeleton2;
        }, null);
        relationships.children.forEach(function(child) {
          if (deformers.morphTargets[child.ID] !== void 0) {
            morphTargets.push(deformers.morphTargets[child.ID]);
          }
        });
        const modelNode = modelNodes[0];
        const transformData = {};
        if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
        if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
        if ("GeometricTranslation" in modelNode) transformData.translation = modelNode.GeometricTranslation.value;
        if ("GeometricRotation" in modelNode) transformData.rotation = modelNode.GeometricRotation.value;
        if ("GeometricScaling" in modelNode) transformData.scale = modelNode.GeometricScaling.value;
        const transform = generateTransform(transformData);
        return this.genGeometry(geoNode, skeleton, morphTargets, transform);
      }
      // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
      genGeometry(geoNode, skeleton, morphTargets, preTransform) {
        const geo = new BufferGeometry();
        if (geoNode.attrName) geo.name = geoNode.attrName;
        const geoInfo = this.parseGeoNode(geoNode, skeleton);
        const buffers = this.genBuffers(geoInfo);
        const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
        positionAttribute.applyMatrix4(preTransform);
        geo.setAttribute("position", positionAttribute);
        if (buffers.colors.length > 0) {
          geo.setAttribute("color", new Float32BufferAttribute(buffers.colors, 3));
        }
        if (skeleton) {
          geo.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
          geo.setAttribute("skinWeight", new Float32BufferAttribute(buffers.vertexWeights, 4));
          geo.FBX_Deformer = skeleton;
        }
        if (buffers.normal.length > 0) {
          const normalMatrix = new Matrix3().getNormalMatrix(preTransform);
          const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
          normalAttribute.applyNormalMatrix(normalMatrix);
          geo.setAttribute("normal", normalAttribute);
        }
        buffers.uvs.forEach(function(uvBuffer, i) {
          const name = i === 0 ? "uv" : `uv${i}`;
          geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));
        });
        if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
          let prevMaterialIndex = buffers.materialIndex[0];
          let startIndex = 0;
          buffers.materialIndex.forEach(function(currentIndex, i) {
            if (currentIndex !== prevMaterialIndex) {
              geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);
              prevMaterialIndex = currentIndex;
              startIndex = i;
            }
          });
          if (geo.groups.length > 0) {
            const lastGroup = geo.groups[geo.groups.length - 1];
            const lastIndex = lastGroup.start + lastGroup.count;
            if (lastIndex !== buffers.materialIndex.length) {
              geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
            }
          }
          if (geo.groups.length === 0) {
            geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
          }
        }
        this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
        return geo;
      }
      parseGeoNode(geoNode, skeleton) {
        const geoInfo = {};
        geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
        geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
        if (geoNode.LayerElementColor) {
          geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
        }
        if (geoNode.LayerElementMaterial) {
          geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
        }
        if (geoNode.LayerElementNormal) {
          geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
        }
        if (geoNode.LayerElementUV) {
          geoInfo.uv = [];
          let i = 0;
          while (geoNode.LayerElementUV[i]) {
            if (geoNode.LayerElementUV[i].UV) {
              geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
            }
            i++;
          }
        }
        geoInfo.weightTable = {};
        if (skeleton !== null) {
          geoInfo.skeleton = skeleton;
          skeleton.rawBones.forEach(function(rawBone, i) {
            rawBone.indices.forEach(function(index, j) {
              if (geoInfo.weightTable[index] === void 0) geoInfo.weightTable[index] = [];
              geoInfo.weightTable[index].push({
                id: i,
                weight: rawBone.weights[j]
              });
            });
          });
        }
        return geoInfo;
      }
      genBuffers(geoInfo) {
        const buffers = {
          vertex: [],
          normal: [],
          colors: [],
          uvs: [],
          materialIndex: [],
          vertexWeights: [],
          weightsIndices: []
        };
        let polygonIndex = 0;
        let faceLength = 0;
        let displayedWeightsWarning = false;
        let facePositionIndexes = [];
        let faceNormals = [];
        let faceColors = [];
        let faceUVs = [];
        let faceWeights = [];
        let faceWeightIndices = [];
        const scope = this;
        geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
          let materialIndex;
          let endOfFace = false;
          if (vertexIndex < 0) {
            vertexIndex = vertexIndex ^ -1;
            endOfFace = true;
          }
          let weightIndices = [];
          let weights = [];
          facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
          if (geoInfo.color) {
            const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
            faceColors.push(data[0], data[1], data[2]);
          }
          if (geoInfo.skeleton) {
            if (geoInfo.weightTable[vertexIndex] !== void 0) {
              geoInfo.weightTable[vertexIndex].forEach(function(wt) {
                weights.push(wt.weight);
                weightIndices.push(wt.id);
              });
            }
            if (weights.length > 4) {
              if (!displayedWeightsWarning) {
                console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
                displayedWeightsWarning = true;
              }
              const wIndex = [0, 0, 0, 0];
              const Weight = [0, 0, 0, 0];
              weights.forEach(function(weight, weightIndex) {
                let currentWeight = weight;
                let currentIndex = weightIndices[weightIndex];
                Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
                  if (currentWeight > comparedWeight) {
                    comparedWeightArray[comparedWeightIndex] = currentWeight;
                    currentWeight = comparedWeight;
                    const tmp = wIndex[comparedWeightIndex];
                    wIndex[comparedWeightIndex] = currentIndex;
                    currentIndex = tmp;
                  }
                });
              });
              weightIndices = wIndex;
              weights = Weight;
            }
            while (weights.length < 4) {
              weights.push(0);
              weightIndices.push(0);
            }
            for (let i = 0; i < 4; ++i) {
              faceWeights.push(weights[i]);
              faceWeightIndices.push(weightIndices[i]);
            }
          }
          if (geoInfo.normal) {
            const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
            faceNormals.push(data[0], data[1], data[2]);
          }
          if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
            materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
            if (materialIndex < 0) {
              scope.negativeMaterialIndices = true;
              materialIndex = 0;
            }
          }
          if (geoInfo.uv) {
            geoInfo.uv.forEach(function(uv, i) {
              const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
              if (faceUVs[i] === void 0) {
                faceUVs[i] = [];
              }
              faceUVs[i].push(data[0]);
              faceUVs[i].push(data[1]);
            });
          }
          faceLength++;
          if (endOfFace) {
            scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
            polygonIndex++;
            faceLength = 0;
            facePositionIndexes = [];
            faceNormals = [];
            faceColors = [];
            faceUVs = [];
            faceWeights = [];
            faceWeightIndices = [];
          }
        });
        return buffers;
      }
      // See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
      getNormalNewell(vertices) {
        const normal = new Vector3(0, 0, 0);
        for (let i = 0; i < vertices.length; i++) {
          const current = vertices[i];
          const next = vertices[(i + 1) % vertices.length];
          normal.x += (current.y - next.y) * (current.z + next.z);
          normal.y += (current.z - next.z) * (current.x + next.x);
          normal.z += (current.x - next.x) * (current.y + next.y);
        }
        normal.normalize();
        return normal;
      }
      getNormalTangentAndBitangent(vertices) {
        const normalVector = this.getNormalNewell(vertices);
        const up = Math.abs(normalVector.z) > 0.5 ? new Vector3(0, 1, 0) : new Vector3(0, 0, 1);
        const tangent = up.cross(normalVector).normalize();
        const bitangent = normalVector.clone().cross(tangent).normalize();
        return {
          normal: normalVector,
          tangent,
          bitangent
        };
      }
      flattenVertex(vertex, normalTangent, normalBitangent) {
        return new Vector2(
          vertex.dot(normalTangent),
          vertex.dot(normalBitangent)
        );
      }
      // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
      genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
        let triangles;
        if (faceLength > 3) {
          const vertices = [];
          for (let i = 0; i < facePositionIndexes.length; i += 3) {
            vertices.push(new Vector3(
              geoInfo.vertexPositions[facePositionIndexes[i]],
              geoInfo.vertexPositions[facePositionIndexes[i + 1]],
              geoInfo.vertexPositions[facePositionIndexes[i + 2]]
            ));
          }
          const { tangent, bitangent } = this.getNormalTangentAndBitangent(vertices);
          const triangulationInput = [];
          for (const vertex of vertices) {
            triangulationInput.push(this.flattenVertex(vertex, tangent, bitangent));
          }
          triangles = ShapeUtils.triangulateShape(triangulationInput, []);
        } else {
          triangles = [[0, 1, 2]];
        }
        for (const [i0, i1, i2] of triangles) {
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 2]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 2]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 1]]);
          buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 2]]);
          if (geoInfo.skeleton) {
            buffers.vertexWeights.push(faceWeights[i0 * 4]);
            buffers.vertexWeights.push(faceWeights[i0 * 4 + 1]);
            buffers.vertexWeights.push(faceWeights[i0 * 4 + 2]);
            buffers.vertexWeights.push(faceWeights[i0 * 4 + 3]);
            buffers.vertexWeights.push(faceWeights[i1 * 4]);
            buffers.vertexWeights.push(faceWeights[i1 * 4 + 1]);
            buffers.vertexWeights.push(faceWeights[i1 * 4 + 2]);
            buffers.vertexWeights.push(faceWeights[i1 * 4 + 3]);
            buffers.vertexWeights.push(faceWeights[i2 * 4]);
            buffers.vertexWeights.push(faceWeights[i2 * 4 + 1]);
            buffers.vertexWeights.push(faceWeights[i2 * 4 + 2]);
            buffers.vertexWeights.push(faceWeights[i2 * 4 + 3]);
            buffers.weightsIndices.push(faceWeightIndices[i0 * 4]);
            buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 1]);
            buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 2]);
            buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 3]);
            buffers.weightsIndices.push(faceWeightIndices[i1 * 4]);
            buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 1]);
            buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 2]);
            buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 3]);
            buffers.weightsIndices.push(faceWeightIndices[i2 * 4]);
            buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 1]);
            buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 2]);
            buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 3]);
          }
          if (geoInfo.color) {
            buffers.colors.push(faceColors[i0 * 3]);
            buffers.colors.push(faceColors[i0 * 3 + 1]);
            buffers.colors.push(faceColors[i0 * 3 + 2]);
            buffers.colors.push(faceColors[i1 * 3]);
            buffers.colors.push(faceColors[i1 * 3 + 1]);
            buffers.colors.push(faceColors[i1 * 3 + 2]);
            buffers.colors.push(faceColors[i2 * 3]);
            buffers.colors.push(faceColors[i2 * 3 + 1]);
            buffers.colors.push(faceColors[i2 * 3 + 2]);
          }
          if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
            buffers.materialIndex.push(materialIndex);
            buffers.materialIndex.push(materialIndex);
            buffers.materialIndex.push(materialIndex);
          }
          if (geoInfo.normal) {
            buffers.normal.push(faceNormals[i0 * 3]);
            buffers.normal.push(faceNormals[i0 * 3 + 1]);
            buffers.normal.push(faceNormals[i0 * 3 + 2]);
            buffers.normal.push(faceNormals[i1 * 3]);
            buffers.normal.push(faceNormals[i1 * 3 + 1]);
            buffers.normal.push(faceNormals[i1 * 3 + 2]);
            buffers.normal.push(faceNormals[i2 * 3]);
            buffers.normal.push(faceNormals[i2 * 3 + 1]);
            buffers.normal.push(faceNormals[i2 * 3 + 2]);
          }
          if (geoInfo.uv) {
            geoInfo.uv.forEach(function(uv, j) {
              if (buffers.uvs[j] === void 0) buffers.uvs[j] = [];
              buffers.uvs[j].push(faceUVs[j][i0 * 2]);
              buffers.uvs[j].push(faceUVs[j][i0 * 2 + 1]);
              buffers.uvs[j].push(faceUVs[j][i1 * 2]);
              buffers.uvs[j].push(faceUVs[j][i1 * 2 + 1]);
              buffers.uvs[j].push(faceUVs[j][i2 * 2]);
              buffers.uvs[j].push(faceUVs[j][i2 * 2 + 1]);
            });
          }
        }
      }
      addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
        if (morphTargets.length === 0) return;
        parentGeo.morphTargetsRelative = true;
        parentGeo.morphAttributes.position = [];
        const scope = this;
        morphTargets.forEach(function(morphTarget) {
          morphTarget.rawTargets.forEach(function(rawTarget) {
            const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
            if (morphGeoNode !== void 0) {
              scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
            }
          });
        });
      }
      // a morph geometry node is similar to a standard  node, and the node is also contained
      // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
      // and a special attribute Index defining which vertices of the original geometry are affected
      // Normal and position attributes only have data for the vertices that are affected by the morph
      genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
        const vertexIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
        const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
        const indices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
        const length = parentGeo.attributes.position.count * 3;
        const morphPositions = new Float32Array(length);
        for (let i = 0; i < indices.length; i++) {
          const morphIndex = indices[i] * 3;
          morphPositions[morphIndex] = morphPositionsSparse[i * 3];
          morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
          morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
        }
        const morphGeoInfo = {
          vertexIndices,
          vertexPositions: morphPositions
        };
        const morphBuffers = this.genBuffers(morphGeoInfo);
        const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
        positionAttribute.name = name || morphGeoNode.attrName;
        positionAttribute.applyMatrix4(preTransform);
        parentGeo.morphAttributes.position.push(positionAttribute);
      }
      // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
      parseNormals(NormalNode) {
        const mappingType = NormalNode.MappingInformationType;
        const referenceType = NormalNode.ReferenceInformationType;
        const buffer = NormalNode.Normals.a;
        let indexBuffer = [];
        if (referenceType === "IndexToDirect") {
          if ("NormalIndex" in NormalNode) {
            indexBuffer = NormalNode.NormalIndex.a;
          } else if ("NormalsIndex" in NormalNode) {
            indexBuffer = NormalNode.NormalsIndex.a;
          }
        }
        return {
          dataSize: 3,
          buffer,
          indices: indexBuffer,
          mappingType,
          referenceType
        };
      }
      // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
      parseUVs(UVNode) {
        const mappingType = UVNode.MappingInformationType;
        const referenceType = UVNode.ReferenceInformationType;
        const buffer = UVNode.UV.a;
        let indexBuffer = [];
        if (referenceType === "IndexToDirect") {
          indexBuffer = UVNode.UVIndex.a;
        }
        return {
          dataSize: 2,
          buffer,
          indices: indexBuffer,
          mappingType,
          referenceType
        };
      }
      // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
      parseVertexColors(ColorNode) {
        const mappingType = ColorNode.MappingInformationType;
        const referenceType = ColorNode.ReferenceInformationType;
        const buffer = ColorNode.Colors.a;
        let indexBuffer = [];
        if (referenceType === "IndexToDirect") {
          indexBuffer = ColorNode.ColorIndex.a;
        }
        for (let i = 0, c = new Color(); i < buffer.length; i += 4) {
          c.fromArray(buffer, i).convertSRGBToLinear().toArray(buffer, i);
        }
        return {
          dataSize: 4,
          buffer,
          indices: indexBuffer,
          mappingType,
          referenceType
        };
      }
      // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
      parseMaterialIndices(MaterialNode) {
        const mappingType = MaterialNode.MappingInformationType;
        const referenceType = MaterialNode.ReferenceInformationType;
        if (mappingType === "NoMappingInformation") {
          return {
            dataSize: 1,
            buffer: [0],
            indices: [0],
            mappingType: "AllSame",
            referenceType
          };
        }
        const materialIndexBuffer = MaterialNode.Materials.a;
        const materialIndices = [];
        for (let i = 0; i < materialIndexBuffer.length; ++i) {
          materialIndices.push(i);
        }
        return {
          dataSize: 1,
          buffer: materialIndexBuffer,
          indices: materialIndices,
          mappingType,
          referenceType
        };
      }
      // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
      parseNurbsGeometry(geoNode) {
        const order = parseInt(geoNode.Order);
        if (isNaN(order)) {
          console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
          return new BufferGeometry();
        }
        const degree = order - 1;
        const knots = geoNode.KnotVector.a;
        const controlPoints = [];
        const pointsValues = geoNode.Points.a;
        for (let i = 0, l = pointsValues.length; i < l; i += 4) {
          controlPoints.push(new Vector4().fromArray(pointsValues, i));
        }
        let startKnot, endKnot;
        if (geoNode.Form === "Closed") {
          controlPoints.push(controlPoints[0]);
        } else if (geoNode.Form === "Periodic") {
          startKnot = degree;
          endKnot = knots.length - 1 - startKnot;
          for (let i = 0; i < degree; ++i) {
            controlPoints.push(controlPoints[i]);
          }
        }
        const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
        const points = curve.getPoints(controlPoints.length * 12);
        return new BufferGeometry().setFromPoints(points);
      }
    };
    AnimationParser = class {
      // take raw animation clips and turn them into three.js animation clips
      parse() {
        const animationClips = [];
        const rawClips = this.parseClips();
        if (rawClips !== void 0) {
          for (const key in rawClips) {
            const rawClip = rawClips[key];
            const clip = this.addClip(rawClip);
            animationClips.push(clip);
          }
        }
        return animationClips;
      }
      parseClips() {
        if (fbxTree.Objects.AnimationCurve === void 0) return void 0;
        const curveNodesMap = this.parseAnimationCurveNodes();
        this.parseAnimationCurves(curveNodesMap);
        const layersMap = this.parseAnimationLayers(curveNodesMap);
        const rawClips = this.parseAnimStacks(layersMap);
        return rawClips;
      }
      // parse nodes in FBXTree.Objects.AnimationCurveNode
      // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
      // and is referenced by an AnimationLayer
      parseAnimationCurveNodes() {
        const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
        const curveNodesMap = /* @__PURE__ */ new Map();
        for (const nodeID in rawCurveNodes) {
          const rawCurveNode = rawCurveNodes[nodeID];
          if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
            const curveNode = {
              id: rawCurveNode.id,
              attr: rawCurveNode.attrName,
              curves: {}
            };
            curveNodesMap.set(curveNode.id, curveNode);
          }
        }
        return curveNodesMap;
      }
      // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
      // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
      // axis ( e.g. times and values of x rotation)
      parseAnimationCurves(curveNodesMap) {
        const rawCurves = fbxTree.Objects.AnimationCurve;
        for (const nodeID in rawCurves) {
          const animationCurve = {
            id: rawCurves[nodeID].id,
            times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
            values: rawCurves[nodeID].KeyValueFloat.a
          };
          const relationships = connections.get(animationCurve.id);
          if (relationships !== void 0) {
            const animationCurveID = relationships.parents[0].ID;
            const animationCurveRelationship = relationships.parents[0].relationship;
            if (animationCurveRelationship.match(/X/)) {
              curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
            } else if (animationCurveRelationship.match(/Y/)) {
              curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
            } else if (animationCurveRelationship.match(/Z/)) {
              curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
            } else if (animationCurveRelationship.match(/DeformPercent/) && curveNodesMap.has(animationCurveID)) {
              curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
            }
          }
        }
      }
      // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
      // to various AnimationCurveNodes and is referenced by an AnimationStack node
      // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
      parseAnimationLayers(curveNodesMap) {
        const rawLayers = fbxTree.Objects.AnimationLayer;
        const layersMap = /* @__PURE__ */ new Map();
        for (const nodeID in rawLayers) {
          const layerCurveNodes = [];
          const connection = connections.get(parseInt(nodeID));
          if (connection !== void 0) {
            const children = connection.children;
            children.forEach(function(child, i) {
              if (curveNodesMap.has(child.ID)) {
                const curveNode = curveNodesMap.get(child.ID);
                if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
                  if (layerCurveNodes[i] === void 0) {
                    const modelID = connections.get(child.ID).parents.filter(function(parent) {
                      return parent.relationship !== void 0;
                    })[0].ID;
                    if (modelID !== void 0) {
                      const rawModel = fbxTree.Objects.Model[modelID.toString()];
                      if (rawModel === void 0) {
                        console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                        return;
                      }
                      const node = {
                        modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                        ID: rawModel.id,
                        initialPosition: [0, 0, 0],
                        initialRotation: [0, 0, 0],
                        initialScale: [1, 1, 1]
                      };
                      sceneGraph.traverse(function(child2) {
                        if (child2.ID === rawModel.id) {
                          node.transform = child2.matrix;
                          if (child2.userData.transformData) node.eulerOrder = child2.userData.transformData.eulerOrder;
                        }
                      });
                      if (!node.transform) node.transform = new Matrix4();
                      if ("PreRotation" in rawModel) node.preRotation = rawModel.PreRotation.value;
                      if ("PostRotation" in rawModel) node.postRotation = rawModel.PostRotation.value;
                      layerCurveNodes[i] = node;
                    }
                  }
                  if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;
                } else if (curveNode.curves.morph !== void 0) {
                  if (layerCurveNodes[i] === void 0) {
                    const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                      return parent.relationship !== void 0;
                    })[0].ID;
                    const morpherID = connections.get(deformerID).parents[0].ID;
                    const geoID = connections.get(morpherID).parents[0].ID;
                    const modelID = connections.get(geoID).parents[0].ID;
                    const rawModel = fbxTree.Objects.Model[modelID];
                    const node = {
                      modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                      morphName: fbxTree.Objects.Deformer[deformerID].attrName
                    };
                    layerCurveNodes[i] = node;
                  }
                  layerCurveNodes[i][curveNode.attr] = curveNode;
                }
              }
            });
            layersMap.set(parseInt(nodeID), layerCurveNodes);
          }
        }
        return layersMap;
      }
      // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
      // hierarchy. Each Stack node will be used to create a AnimationClip
      parseAnimStacks(layersMap) {
        const rawStacks = fbxTree.Objects.AnimationStack;
        const rawClips = {};
        for (const nodeID in rawStacks) {
          const children = connections.get(parseInt(nodeID)).children;
          if (children.length > 1) {
            console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
          }
          const layer = layersMap.get(children[0].ID);
          rawClips[nodeID] = {
            name: rawStacks[nodeID].attrName,
            layer
          };
        }
        return rawClips;
      }
      addClip(rawClip) {
        let tracks = [];
        const scope = this;
        rawClip.layer.forEach(function(rawTracks) {
          tracks = tracks.concat(scope.generateTracks(rawTracks));
        });
        return new AnimationClip(rawClip.name, -1, tracks);
      }
      generateTracks(rawTracks) {
        const tracks = [];
        let initialPosition = new Vector3();
        let initialScale = new Vector3();
        if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, new Quaternion(), initialScale);
        initialPosition = initialPosition.toArray();
        initialScale = initialScale.toArray();
        if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
          const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
          if (positionTrack !== void 0) tracks.push(positionTrack);
        }
        if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
          const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
          if (rotationTrack !== void 0) tracks.push(rotationTrack);
        }
        if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
          const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
          if (scaleTrack !== void 0) tracks.push(scaleTrack);
        }
        if (rawTracks.DeformPercent !== void 0) {
          const morphTrack = this.generateMorphTrack(rawTracks);
          if (morphTrack !== void 0) tracks.push(morphTrack);
        }
        return tracks;
      }
      generateVectorTrack(modelName, curves, initialValue, type) {
        const times = this.getTimesForAllAxes(curves);
        const values = this.getKeyframeTrackValues(times, curves, initialValue);
        return new VectorKeyframeTrack(modelName + "." + type, times, values);
      }
      generateRotationTrack(modelName, curves, preRotation, postRotation, eulerOrder) {
        let times;
        let values;
        if (curves.x !== void 0 && curves.y !== void 0 && curves.z !== void 0) {
          const result = this.interpolateRotations(curves.x, curves.y, curves.z, eulerOrder);
          times = result[0];
          values = result[1];
        }
        if (preRotation !== void 0) {
          preRotation = preRotation.map(MathUtils.degToRad);
          preRotation.push(eulerOrder);
          preRotation = new Euler().fromArray(preRotation);
          preRotation = new Quaternion().setFromEuler(preRotation);
        }
        if (postRotation !== void 0) {
          postRotation = postRotation.map(MathUtils.degToRad);
          postRotation.push(eulerOrder);
          postRotation = new Euler().fromArray(postRotation);
          postRotation = new Quaternion().setFromEuler(postRotation).invert();
        }
        const quaternion = new Quaternion();
        const euler = new Euler();
        const quaternionValues = [];
        if (!values || !times) return new QuaternionKeyframeTrack(modelName + ".quaternion", [0], [0]);
        for (let i = 0; i < values.length; i += 3) {
          euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);
          quaternion.setFromEuler(euler);
          if (preRotation !== void 0) quaternion.premultiply(preRotation);
          if (postRotation !== void 0) quaternion.multiply(postRotation);
          if (i > 2) {
            const prevQuat = new Quaternion().fromArray(
              quaternionValues,
              (i - 3) / 3 * 4
            );
            if (prevQuat.dot(quaternion) < 0) {
              quaternion.set(-quaternion.x, -quaternion.y, -quaternion.z, -quaternion.w);
            }
          }
          quaternion.toArray(quaternionValues, i / 3 * 4);
        }
        return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
      }
      generateMorphTrack(rawTracks) {
        const curves = rawTracks.DeformPercent.curves.morph;
        const values = curves.values.map(function(val) {
          return val / 100;
        });
        const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
        return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
      }
      // For all animated objects, times are defined separately for each axis
      // Here we'll combine the times into one sorted array without duplicates
      getTimesForAllAxes(curves) {
        let times = [];
        if (curves.x !== void 0) times = times.concat(curves.x.times);
        if (curves.y !== void 0) times = times.concat(curves.y.times);
        if (curves.z !== void 0) times = times.concat(curves.z.times);
        times = times.sort(function(a, b) {
          return a - b;
        });
        if (times.length > 1) {
          let targetIndex = 1;
          let lastValue = times[0];
          for (let i = 1; i < times.length; i++) {
            const currentValue = times[i];
            if (currentValue !== lastValue) {
              times[targetIndex] = currentValue;
              lastValue = currentValue;
              targetIndex++;
            }
          }
          times = times.slice(0, targetIndex);
        }
        return times;
      }
      getKeyframeTrackValues(times, curves, initialValue) {
        const prevValue = initialValue;
        const values = [];
        let xIndex = -1;
        let yIndex = -1;
        let zIndex = -1;
        times.forEach(function(time) {
          if (curves.x) xIndex = curves.x.times.indexOf(time);
          if (curves.y) yIndex = curves.y.times.indexOf(time);
          if (curves.z) zIndex = curves.z.times.indexOf(time);
          if (xIndex !== -1) {
            const xValue = curves.x.values[xIndex];
            values.push(xValue);
            prevValue[0] = xValue;
          } else {
            values.push(prevValue[0]);
          }
          if (yIndex !== -1) {
            const yValue = curves.y.values[yIndex];
            values.push(yValue);
            prevValue[1] = yValue;
          } else {
            values.push(prevValue[1]);
          }
          if (zIndex !== -1) {
            const zValue = curves.z.values[zIndex];
            values.push(zValue);
            prevValue[2] = zValue;
          } else {
            values.push(prevValue[2]);
          }
        });
        return values;
      }
      // Rotations are defined as Euler angles which can have values  of any size
      // These will be converted to quaternions which don't support values greater than
      // PI, so we'll interpolate large rotations
      interpolateRotations(curvex, curvey, curvez, eulerOrder) {
        const times = [];
        const values = [];
        times.push(curvex.times[0]);
        values.push(MathUtils.degToRad(curvex.values[0]));
        values.push(MathUtils.degToRad(curvey.values[0]));
        values.push(MathUtils.degToRad(curvez.values[0]));
        for (let i = 1; i < curvex.values.length; i++) {
          const initialValue = [
            curvex.values[i - 1],
            curvey.values[i - 1],
            curvez.values[i - 1]
          ];
          if (isNaN(initialValue[0]) || isNaN(initialValue[1]) || isNaN(initialValue[2])) {
            continue;
          }
          const initialValueRad = initialValue.map(MathUtils.degToRad);
          const currentValue = [
            curvex.values[i],
            curvey.values[i],
            curvez.values[i]
          ];
          if (isNaN(currentValue[0]) || isNaN(currentValue[1]) || isNaN(currentValue[2])) {
            continue;
          }
          const currentValueRad = currentValue.map(MathUtils.degToRad);
          const valuesSpan = [
            currentValue[0] - initialValue[0],
            currentValue[1] - initialValue[1],
            currentValue[2] - initialValue[2]
          ];
          const absoluteSpan = [
            Math.abs(valuesSpan[0]),
            Math.abs(valuesSpan[1]),
            Math.abs(valuesSpan[2])
          ];
          if (absoluteSpan[0] >= 180 || absoluteSpan[1] >= 180 || absoluteSpan[2] >= 180) {
            const maxAbsSpan = Math.max(...absoluteSpan);
            const numSubIntervals = maxAbsSpan / 180;
            const E1 = new Euler(...initialValueRad, eulerOrder);
            const E2 = new Euler(...currentValueRad, eulerOrder);
            const Q1 = new Quaternion().setFromEuler(E1);
            const Q2 = new Quaternion().setFromEuler(E2);
            if (Q1.dot(Q2)) {
              Q2.set(-Q2.x, -Q2.y, -Q2.z, -Q2.w);
            }
            const initialTime = curvex.times[i - 1];
            const timeSpan = curvex.times[i] - initialTime;
            const Q = new Quaternion();
            const E = new Euler();
            for (let t = 0; t < 1; t += 1 / numSubIntervals) {
              Q.copy(Q1.clone().slerp(Q2.clone(), t));
              times.push(initialTime + t * timeSpan);
              E.setFromQuaternion(Q, eulerOrder);
              values.push(E.x);
              values.push(E.y);
              values.push(E.z);
            }
          } else {
            times.push(curvex.times[i]);
            values.push(MathUtils.degToRad(curvex.values[i]));
            values.push(MathUtils.degToRad(curvey.values[i]));
            values.push(MathUtils.degToRad(curvez.values[i]));
          }
        }
        return [times, values];
      }
    };
    TextParser = class {
      getPrevNode() {
        return this.nodeStack[this.currentIndent - 2];
      }
      getCurrentNode() {
        return this.nodeStack[this.currentIndent - 1];
      }
      getCurrentProp() {
        return this.currentProp;
      }
      pushStack(node) {
        this.nodeStack.push(node);
        this.currentIndent += 1;
      }
      popStack() {
        this.nodeStack.pop();
        this.currentIndent -= 1;
      }
      setCurrentProp(val, name) {
        this.currentProp = val;
        this.currentPropName = name;
      }
      parse(text) {
        this.currentIndent = 0;
        this.allNodes = new FBXTree();
        this.nodeStack = [];
        this.currentProp = [];
        this.currentPropName = "";
        const scope = this;
        const split = text.split(/[\r\n]+/);
        split.forEach(function(line, i) {
          const matchComment = line.match(/^[\s\t]*;/);
          const matchEmpty = line.match(/^[\s\t]*$/);
          if (matchComment || matchEmpty) return;
          const matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
          const matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
          const matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
          if (matchBeginning) {
            scope.parseNodeBegin(line, matchBeginning);
          } else if (matchProperty) {
            scope.parseNodeProperty(line, matchProperty, split[++i]);
          } else if (matchEnd) {
            scope.popStack();
          } else if (line.match(/^[^\s\t}]/)) {
            scope.parseNodePropertyContinued(line);
          }
        });
        return this.allNodes;
      }
      parseNodeBegin(line, property) {
        const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
        const nodeAttrs = property[2].split(",").map(function(attr) {
          return attr.trim().replace(/^"/, "").replace(/"$/, "");
        });
        const node = { name: nodeName };
        const attrs = this.parseNodeAttr(nodeAttrs);
        const currentNode = this.getCurrentNode();
        if (this.currentIndent === 0) {
          this.allNodes.add(nodeName, node);
        } else {
          if (nodeName in currentNode) {
            if (nodeName === "PoseNode") {
              currentNode.PoseNode.push(node);
            } else if (currentNode[nodeName].id !== void 0) {
              currentNode[nodeName] = {};
              currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
            }
            if (attrs.id !== "") currentNode[nodeName][attrs.id] = node;
          } else if (typeof attrs.id === "number") {
            currentNode[nodeName] = {};
            currentNode[nodeName][attrs.id] = node;
          } else if (nodeName !== "Properties70") {
            if (nodeName === "PoseNode") currentNode[nodeName] = [node];
            else currentNode[nodeName] = node;
          }
        }
        if (typeof attrs.id === "number") node.id = attrs.id;
        if (attrs.name !== "") node.attrName = attrs.name;
        if (attrs.type !== "") node.attrType = attrs.type;
        this.pushStack(node);
      }
      parseNodeAttr(attrs) {
        let id = attrs[0];
        if (attrs[0] !== "") {
          id = parseInt(attrs[0]);
          if (isNaN(id)) {
            id = attrs[0];
          }
        }
        let name = "", type = "";
        if (attrs.length > 1) {
          name = attrs[1].replace(/^(\w+)::/, "");
          type = attrs[2];
        }
        return { id, name, type };
      }
      parseNodeProperty(line, property, contentLine) {
        let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
        let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
        if (propName === "Content" && propValue === ",") {
          propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
        }
        const currentNode = this.getCurrentNode();
        const parentName = currentNode.name;
        if (parentName === "Properties70") {
          this.parseNodeSpecialProperty(line, propName, propValue);
          return;
        }
        if (propName === "C") {
          const connProps = propValue.split(",").slice(1);
          const from = parseInt(connProps[0]);
          const to = parseInt(connProps[1]);
          let rest = propValue.split(",").slice(3);
          rest = rest.map(function(elem) {
            return elem.trim().replace(/^"/, "");
          });
          propName = "connections";
          propValue = [from, to];
          append(propValue, rest);
          if (currentNode[propName] === void 0) {
            currentNode[propName] = [];
          }
        }
        if (propName === "Node") currentNode.id = propValue;
        if (propName in currentNode && Array.isArray(currentNode[propName])) {
          currentNode[propName].push(propValue);
        } else {
          if (propName !== "a") currentNode[propName] = propValue;
          else currentNode.a = propValue;
        }
        this.setCurrentProp(currentNode, propName);
        if (propName === "a" && propValue.slice(-1) !== ",") {
          currentNode.a = parseNumberArray(propValue);
        }
      }
      parseNodePropertyContinued(line) {
        const currentNode = this.getCurrentNode();
        currentNode.a += line;
        if (line.slice(-1) !== ",") {
          currentNode.a = parseNumberArray(currentNode.a);
        }
      }
      // parse "Property70"
      parseNodeSpecialProperty(line, propName, propValue) {
        const props = propValue.split('",').map(function(prop) {
          return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
        });
        const innerPropName = props[0];
        const innerPropType1 = props[1];
        const innerPropType2 = props[2];
        const innerPropFlag = props[3];
        let innerPropValue = props[4];
        switch (innerPropType1) {
          case "int":
          case "enum":
          case "bool":
          case "ULongLong":
          case "double":
          case "Number":
          case "FieldOfView":
            innerPropValue = parseFloat(innerPropValue);
            break;
          case "Color":
          case "ColorRGB":
          case "Vector3D":
          case "Lcl_Translation":
          case "Lcl_Rotation":
          case "Lcl_Scaling":
            innerPropValue = parseNumberArray(innerPropValue);
            break;
        }
        this.getPrevNode()[innerPropName] = {
          "type": innerPropType1,
          "type2": innerPropType2,
          "flag": innerPropFlag,
          "value": innerPropValue
        };
        this.setCurrentProp(this.getPrevNode(), innerPropName);
      }
    };
    BinaryParser = class {
      parse(buffer) {
        const reader = new BinaryReader(buffer);
        reader.skip(23);
        const version = reader.getUint32();
        if (version < 6400) {
          throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version);
        }
        const allNodes = new FBXTree();
        while (!this.endOfContent(reader)) {
          const node = this.parseNode(reader, version);
          if (node !== null) allNodes.add(node.name, node);
        }
        return allNodes;
      }
      // Check if reader has reached the end of content.
      endOfContent(reader) {
        if (reader.size() % 16 === 0) {
          return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
        } else {
          return reader.getOffset() + 160 + 16 >= reader.size();
        }
      }
      // recursively parse nodes until the end of the file is reached
      parseNode(reader, version) {
        const node = {};
        const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
        const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
        version >= 7500 ? reader.getUint64() : reader.getUint32();
        const nameLen = reader.getUint8();
        const name = reader.getString(nameLen);
        if (endOffset === 0) return null;
        const propertyList = [];
        for (let i = 0; i < numProperties; i++) {
          propertyList.push(this.parseProperty(reader));
        }
        const id = propertyList.length > 0 ? propertyList[0] : "";
        const attrName = propertyList.length > 1 ? propertyList[1] : "";
        const attrType = propertyList.length > 2 ? propertyList[2] : "";
        node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
        while (endOffset > reader.getOffset()) {
          const subNode = this.parseNode(reader, version);
          if (subNode !== null) this.parseSubNode(name, node, subNode);
        }
        node.propertyList = propertyList;
        if (typeof id === "number") node.id = id;
        if (attrName !== "") node.attrName = attrName;
        if (attrType !== "") node.attrType = attrType;
        if (name !== "") node.name = name;
        return node;
      }
      parseSubNode(name, node, subNode) {
        if (subNode.singleProperty === true) {
          const value = subNode.propertyList[0];
          if (Array.isArray(value)) {
            node[subNode.name] = subNode;
            subNode.a = value;
          } else {
            node[subNode.name] = value;
          }
        } else if (name === "Connections" && subNode.name === "C") {
          const array = [];
          subNode.propertyList.forEach(function(property, i) {
            if (i !== 0) array.push(property);
          });
          if (node.connections === void 0) {
            node.connections = [];
          }
          node.connections.push(array);
        } else if (subNode.name === "Properties70") {
          const keys = Object.keys(subNode);
          keys.forEach(function(key) {
            node[key] = subNode[key];
          });
        } else if (name === "Properties70" && subNode.name === "P") {
          let innerPropName = subNode.propertyList[0];
          let innerPropType1 = subNode.propertyList[1];
          const innerPropType2 = subNode.propertyList[2];
          const innerPropFlag = subNode.propertyList[3];
          let innerPropValue;
          if (innerPropName.indexOf("Lcl ") === 0) innerPropName = innerPropName.replace("Lcl ", "Lcl_");
          if (innerPropType1.indexOf("Lcl ") === 0) innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
          if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
            innerPropValue = [
              subNode.propertyList[4],
              subNode.propertyList[5],
              subNode.propertyList[6]
            ];
          } else {
            innerPropValue = subNode.propertyList[4];
          }
          node[innerPropName] = {
            "type": innerPropType1,
            "type2": innerPropType2,
            "flag": innerPropFlag,
            "value": innerPropValue
          };
        } else if (node[subNode.name] === void 0) {
          if (typeof subNode.id === "number") {
            node[subNode.name] = {};
            node[subNode.name][subNode.id] = subNode;
          } else {
            node[subNode.name] = subNode;
          }
        } else {
          if (subNode.name === "PoseNode") {
            if (!Array.isArray(node[subNode.name])) {
              node[subNode.name] = [node[subNode.name]];
            }
            node[subNode.name].push(subNode);
          } else if (node[subNode.name][subNode.id] === void 0) {
            node[subNode.name][subNode.id] = subNode;
          }
        }
      }
      parseProperty(reader) {
        const type = reader.getString(1);
        let length;
        switch (type) {
          case "C":
            return reader.getBoolean();
          case "D":
            return reader.getFloat64();
          case "F":
            return reader.getFloat32();
          case "I":
            return reader.getInt32();
          case "L":
            return reader.getInt64();
          case "R":
            length = reader.getUint32();
            return reader.getArrayBuffer(length);
          case "S":
            length = reader.getUint32();
            return reader.getString(length);
          case "Y":
            return reader.getInt16();
          case "b":
          case "c":
          case "d":
          case "f":
          case "i":
          case "l":
            const arrayLength = reader.getUint32();
            const encoding = reader.getUint32();
            const compressedLength = reader.getUint32();
            if (encoding === 0) {
              switch (type) {
                case "b":
                case "c":
                  return reader.getBooleanArray(arrayLength);
                case "d":
                  return reader.getFloat64Array(arrayLength);
                case "f":
                  return reader.getFloat32Array(arrayLength);
                case "i":
                  return reader.getInt32Array(arrayLength);
                case "l":
                  return reader.getInt64Array(arrayLength);
              }
            }
            const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
            const reader2 = new BinaryReader(data.buffer);
            switch (type) {
              case "b":
              case "c":
                return reader2.getBooleanArray(arrayLength);
              case "d":
                return reader2.getFloat64Array(arrayLength);
              case "f":
                return reader2.getFloat32Array(arrayLength);
              case "i":
                return reader2.getInt32Array(arrayLength);
              case "l":
                return reader2.getInt64Array(arrayLength);
            }
            break;
          default:
            throw new Error("THREE.FBXLoader: Unknown property type " + type);
        }
      }
    };
    BinaryReader = class {
      constructor(buffer, littleEndian) {
        this.dv = new DataView(buffer);
        this.offset = 0;
        this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
        this._textDecoder = new TextDecoder();
      }
      getOffset() {
        return this.offset;
      }
      size() {
        return this.dv.buffer.byteLength;
      }
      skip(length) {
        this.offset += length;
      }
      // seems like true/false representation depends on exporter.
      // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
      // then sees LSB.
      getBoolean() {
        return (this.getUint8() & 1) === 1;
      }
      getBooleanArray(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getBoolean());
        }
        return a;
      }
      getUint8() {
        const value = this.dv.getUint8(this.offset);
        this.offset += 1;
        return value;
      }
      getInt16() {
        const value = this.dv.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      getInt32() {
        const value = this.dv.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      getInt32Array(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getInt32());
        }
        return a;
      }
      getUint32() {
        const value = this.dv.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      // JavaScript doesn't support 64-bit integer so calculate this here
      // 1 << 32 will return 1 so using multiply operation instead here.
      // There's a possibility that this method returns wrong value if the value
      // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
      // TODO: safely handle 64-bit integer
      getInt64() {
        let low, high;
        if (this.littleEndian) {
          low = this.getUint32();
          high = this.getUint32();
        } else {
          high = this.getUint32();
          low = this.getUint32();
        }
        if (high & 2147483648) {
          high = ~high & 4294967295;
          low = ~low & 4294967295;
          if (low === 4294967295) high = high + 1 & 4294967295;
          low = low + 1 & 4294967295;
          return -(high * 4294967296 + low);
        }
        return high * 4294967296 + low;
      }
      getInt64Array(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getInt64());
        }
        return a;
      }
      // Note: see getInt64() comment
      getUint64() {
        let low, high;
        if (this.littleEndian) {
          low = this.getUint32();
          high = this.getUint32();
        } else {
          high = this.getUint32();
          low = this.getUint32();
        }
        return high * 4294967296 + low;
      }
      getFloat32() {
        const value = this.dv.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      getFloat32Array(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getFloat32());
        }
        return a;
      }
      getFloat64() {
        const value = this.dv.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      getFloat64Array(size) {
        const a = [];
        for (let i = 0; i < size; i++) {
          a.push(this.getFloat64());
        }
        return a;
      }
      getArrayBuffer(size) {
        const value = this.dv.buffer.slice(this.offset, this.offset + size);
        this.offset += size;
        return value;
      }
      getString(size) {
        const start = this.offset;
        let a = new Uint8Array(this.dv.buffer, start, size);
        this.skip(size);
        const nullByte = a.indexOf(0);
        if (nullByte >= 0) a = new Uint8Array(this.dv.buffer, start, nullByte);
        return this._textDecoder.decode(a);
      }
    };
    FBXTree = class {
      add(key, val) {
        this[key] = val;
      }
    };
    dataArray = [];
    tempEuler = new Euler();
    tempVec = new Vector3();
  }
});

// node_modules/aframe-extras/src/loaders/fbx-model.js
var fbx_model_exports = {};
var init_fbx_model = __esm({
  "node_modules/aframe-extras/src/loaders/fbx-model.js"() {
    init_FBXLoader();
    THREE.FBXLoader = FBXLoader;
    AFRAME.registerComponent("fbx-model", {
      schema: {
        src: { type: "asset" },
        crossorigin: { default: "" }
      },
      init: function() {
        this.model = null;
      },
      update: function() {
        const data = this.data;
        if (!data.src) return;
        this.remove();
        const loader = new THREE.FBXLoader();
        if (data.crossorigin) loader.setCrossOrigin(data.crossorigin);
        loader.load(data.src, this.load.bind(this));
      },
      load: function(model) {
        this.model = model;
        this.el.setObject3D("mesh", model);
        this.el.emit("model-loaded", { format: "fbx", model });
      },
      remove: function() {
        if (this.model) this.el.removeObject3D("mesh");
      }
    });
  }
});

// node_modules/aframe-extras/lib/fetch-script.js
var require_fetch_script = __commonJS({
  "node_modules/aframe-extras/lib/fetch-script.js"(exports, module) {
    function getScriptId() {
      return "script_" + Date.now() + "_" + Math.ceil(Math.random() * 1e5);
    }
    function createScript(url, id) {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.async = true;
      script.id = id;
      script.src = url;
      return script;
    }
    function removeScript(id) {
      const script = document.getElementById(id);
      const parent = script.parentNode;
      try {
        parent && parent.removeChild(script);
      } catch (e) {
      }
    }
    function appendScript(script) {
      const firstScript = document.getElementsByTagName("script")[0];
      firstScript.parentNode.insertBefore(script, firstScript);
    }
    function fetchScriptInternal(url, options, Promise2) {
      return new Promise2(function(resolve, reject) {
        const timeout = options.timeout || 5e3;
        const scriptId = getScriptId();
        const script = createScript(url, scriptId);
        const timeoutId = setTimeout(function() {
          reject(new Error("Script request to " + url + " timed out"));
          removeScript(scriptId);
        }, timeout);
        const disableTimeout = function(timeoutId2) {
          clearTimeout(timeoutId2);
        };
        script.addEventListener("load", function(e) {
          resolve({ ok: true });
          disableTimeout(timeoutId);
          removeScript(scriptId);
        });
        script.addEventListener("error", function(e) {
          reject(new Error("Script request to " + url + " failed " + e));
          disableTimeout(timeoutId);
          removeScript(scriptId);
        });
        appendScript(script);
      });
    }
    function fetchScript(settings) {
      settings = settings || {};
      return function(url, options) {
        options = options || {};
        return fetchScriptInternal(url, options, settings.Promise || Promise);
      };
    }
    module.exports = fetchScript;
  }
});

// node_modules/aframe-extras/src/loaders/gltf-model-legacy.js
var require_gltf_model_legacy = __commonJS({
  "node_modules/aframe-extras/src/loaders/gltf-model-legacy.js"(exports, module) {
    var fetchScript = require_fetch_script()();
    var LOADER_SRC = "https://cdn.jsdelivr.net/gh/mrdoob/three.js@r86/examples/js/loaders/GLTFLoader.js";
    var loadLoader = /* @__PURE__ */ function() {
      let promise;
      return function() {
        promise = promise || fetchScript(LOADER_SRC);
        return promise;
      };
    }();
    module.exports = AFRAME.registerComponent("gltf-model-legacy", {
      schema: { type: "model" },
      init: function() {
        this.model = null;
        this.loader = null;
        this.loaderPromise = loadLoader().then(() => {
          this.loader = new THREE.GLTFLoader();
          this.loader.setCrossOrigin("Anonymous");
        });
      },
      update: function() {
        const self = this;
        const el = this.el;
        const src = this.data;
        if (!src) {
          return;
        }
        this.remove();
        this.loaderPromise.then(() => {
          this.loader.load(src, function gltfLoaded(gltfModel) {
            self.model = gltfModel.scene;
            self.model.animations = gltfModel.animations;
            el.setObject3D("mesh", self.model);
            el.emit("model-loaded", { format: "gltf", model: self.model });
          });
        });
      },
      remove: function() {
        if (!this.model) {
          return;
        }
        this.el.removeObject3D("mesh");
      }
    });
  }
});

// node_modules/aframe-extras/src/loaders/object-model.js
var require_object_model = __commonJS({
  "node_modules/aframe-extras/src/loaders/object-model.js"(exports, module) {
    module.exports = AFRAME.registerComponent("object-model", {
      schema: {
        src: { type: "asset" },
        crossorigin: { default: "" }
      },
      init: function() {
        this.model = null;
      },
      update: function() {
        let loader;
        const data = this.data;
        if (!data.src) return;
        this.remove();
        loader = new THREE.ObjectLoader();
        if (data.crossorigin) loader.setCrossOrigin(data.crossorigin);
        loader.load(data.src, (object) => {
          object.traverse((o) => {
            if (o instanceof THREE.SkinnedMesh && o.material) {
              o.material.skinning = !!(o.geometry && o.geometry.bones || []).length;
            }
          });
          this.load(object);
        });
      },
      load: function(model) {
        this.model = model;
        this.el.setObject3D("mesh", model);
        this.el.emit("model-loaded", { format: "json", model });
      },
      remove: function() {
        if (this.model) this.el.removeObject3D("mesh");
      }
    });
  }
});

// node_modules/aframe-extras/src/loaders/index.js
var require_loaders = __commonJS({
  "node_modules/aframe-extras/src/loaders/index.js"() {
    require_animation_mixer();
    require_collada_model_legacy();
    init_fbx_model();
    require_gltf_model_legacy();
    require_object_model();
  }
});

// node_modules/aframe-extras/src/misc/checkpoint.js
var require_checkpoint = __commonJS({
  "node_modules/aframe-extras/src/misc/checkpoint.js"(exports, module) {
    module.exports = AFRAME.registerComponent("checkpoint", {
      schema: {
        offset: { default: { x: 0, y: 0, z: 0 }, type: "vec3" }
      },
      init: function() {
        this.active = false;
        this.targetEl = null;
        this.fire = this.fire.bind(this);
        this.offset = new THREE.Vector3();
      },
      update: function() {
        this.offset.copy(this.data.offset);
      },
      play: function() {
        this.el.addEventListener("click", this.fire);
      },
      pause: function() {
        this.el.removeEventListener("click", this.fire);
      },
      remove: function() {
        this.pause();
      },
      fire: function() {
        const targetEl = this.el.sceneEl.querySelector("[checkpoint-controls]");
        if (!targetEl) {
          throw new Error("No `checkpoint-controls` component found.");
        }
        targetEl.components["checkpoint-controls"].setCheckpoint(this.el);
      },
      getOffset: function() {
        return this.offset.copy(this.data.offset);
      }
    });
  }
});

// node_modules/aframe-extras/src/misc/cube-env-map.js
var require_cube_env_map = __commonJS({
  "node_modules/aframe-extras/src/misc/cube-env-map.js"(exports, module) {
    function ensureMaterialArray(material) {
      if (!material) {
        return [];
      } else if (Array.isArray(material)) {
        return material;
      } else if (material.materials) {
        return material.materials;
      } else {
        return [material];
      }
    }
    function applyEnvMap(mesh, materialNames, envMap, reflectivity) {
      if (!mesh) return;
      materialNames = materialNames || [];
      mesh.traverse((node) => {
        if (!node.isMesh) return;
        const meshMaterials = ensureMaterialArray(node.material);
        meshMaterials.forEach((material) => {
          if (material && !("envMap" in material)) return;
          if (materialNames.length && materialNames.indexOf(material.name) === -1) return;
          material.envMap = envMap;
          material.reflectivity = reflectivity;
          material.needsUpdate = true;
        });
      });
    }
    module.exports = AFRAME.registerComponent("cube-env-map", {
      multiple: true,
      schema: {
        path: { default: "" },
        extension: { default: "jpg", oneOf: ["jpg", "png"] },
        enableBackground: { default: false },
        reflectivity: { default: 1, min: 0, max: 1 },
        materials: { default: [] }
      },
      init: function() {
        const data = this.data;
        this.texture = new THREE.CubeTextureLoader().load([
          data.path + "posx." + data.extension,
          data.path + "negx." + data.extension,
          data.path + "posy." + data.extension,
          data.path + "negy." + data.extension,
          data.path + "posz." + data.extension,
          data.path + "negz." + data.extension
        ]);
        this.texture.format = THREE.RGBAFormat;
        this.object3dsetHandler = () => {
          const mesh = this.el.getObject3D("mesh");
          const data2 = this.data;
          applyEnvMap(mesh, data2.materials, this.texture, data2.reflectivity);
        };
        this.object3dsetHandler();
        this.el.addEventListener("object3dset", this.object3dsetHandler);
      },
      update: function(oldData) {
        const data = this.data;
        const mesh = this.el.getObject3D("mesh");
        let addedMaterialNames = [];
        let removedMaterialNames = [];
        if (data.materials.length) {
          if (oldData.materials) {
            addedMaterialNames = data.materials.filter((name) => !oldData.materials.includes(name));
            removedMaterialNames = oldData.materials.filter((name) => !data.materials.includes(name));
          } else {
            addedMaterialNames = data.materials;
          }
        }
        if (addedMaterialNames.length) {
          applyEnvMap(mesh, addedMaterialNames, this.texture, data.reflectivity);
        }
        if (removedMaterialNames.length) {
          applyEnvMap(mesh, removedMaterialNames, null, 1);
        }
        if (oldData.materials && data.reflectivity !== oldData.reflectivity) {
          const maintainedMaterialNames = data.materials.filter((name) => oldData.materials.includes(name));
          if (maintainedMaterialNames.length) {
            applyEnvMap(mesh, maintainedMaterialNames, this.texture, data.reflectivity);
          }
        }
        if (this.data.enableBackground && !oldData.enableBackground) {
          this.setBackground(this.texture);
        } else if (!this.data.enableBackground && oldData.enableBackground) {
          this.setBackground(null);
        }
      },
      remove: function() {
        this.el.removeEventListener("object3dset", this.object3dsetHandler);
        const mesh = this.el.getObject3D("mesh");
        const data = this.data;
        applyEnvMap(mesh, data.materials, null, 1);
        if (data.enableBackground) this.setBackground(null);
      },
      setBackground: function(texture) {
        this.el.sceneEl.object3D.background = texture;
      }
    });
  }
});

// node_modules/aframe-extras/src/misc/grab.js
var require_grab = __commonJS({
  "node_modules/aframe-extras/src/misc/grab.js"(exports, module) {
    module.exports = AFRAME.registerComponent("grab", {
      init: function() {
        this.system = this.el.sceneEl.systems.physics;
        this.GRABBED_STATE = "grabbed";
        this.grabbing = false;
        this.hitEl = /** @type {AFRAME.Element}    */
        null;
        this.physics = /** @type {AFRAME.System}     */
        this.el.sceneEl.systems.physics;
        this.constraint = /** @type {CANNON.Constraint} */
        null;
        this.onHit = this.onHit.bind(this);
        this.onGripOpen = this.onGripOpen.bind(this);
        this.onGripClose = this.onGripClose.bind(this);
      },
      play: function() {
        const el = this.el;
        el.addEventListener("hit", this.onHit);
        el.addEventListener("gripdown", this.onGripClose);
        el.addEventListener("gripup", this.onGripOpen);
        el.addEventListener("trackpaddown", this.onGripClose);
        el.addEventListener("trackpadup", this.onGripOpen);
        el.addEventListener("triggerdown", this.onGripClose);
        el.addEventListener("triggerup", this.onGripOpen);
      },
      pause: function() {
        const el = this.el;
        el.removeEventListener("hit", this.onHit);
        el.removeEventListener("gripdown", this.onGripClose);
        el.removeEventListener("gripup", this.onGripOpen);
        el.removeEventListener("trackpaddown", this.onGripClose);
        el.removeEventListener("trackpadup", this.onGripOpen);
        el.removeEventListener("triggerdown", this.onGripClose);
        el.removeEventListener("triggerup", this.onGripOpen);
      },
      onGripClose: function() {
        this.grabbing = true;
      },
      onGripOpen: function() {
        const hitEl = this.hitEl;
        this.grabbing = false;
        if (!hitEl) {
          return;
        }
        hitEl.removeState(this.GRABBED_STATE);
        this.hitEl = void 0;
        this.system.removeConstraint(this.constraint);
        this.constraint = null;
      },
      onHit: function(evt) {
        const hitEl = evt.detail.el;
        if (hitEl.is(this.GRABBED_STATE) || !this.grabbing || this.hitEl) {
          return;
        }
        hitEl.addState(this.GRABBED_STATE);
        this.hitEl = hitEl;
        this.constraint = new CANNON.LockConstraint(this.el.body, hitEl.body);
        this.system.addConstraint(this.constraint);
      }
    });
  }
});

// node_modules/aframe-extras/src/misc/normal-material.js
var require_normal_material = __commonJS({
  "node_modules/aframe-extras/src/misc/normal-material.js"(exports, module) {
    module.exports = AFRAME.registerComponent("normal-material", {
      init: function() {
        this.material = new THREE.MeshNormalMaterial({ flatShading: true });
        this.applyMaterial = this.applyMaterial.bind(this);
        this.el.addEventListener("object3dset", this.applyMaterial);
        this.applyMaterial();
      },
      remove: function() {
        this.el.removeEventListener("object3dset", this.applyMaterial);
      },
      applyMaterial: function() {
        this.el.object3D.traverse((node) => {
          if (node.isMesh) node.material = this.material;
        });
      }
    });
  }
});

// node_modules/aframe-extras/src/misc/sphere-collider.js
var require_sphere_collider = __commonJS({
  "node_modules/aframe-extras/src/misc/sphere-collider.js"(exports, module) {
    module.exports = AFRAME.registerComponent("sphere-collider", {
      schema: {
        enabled: { default: true },
        interval: { default: 80 },
        objects: { default: "" },
        state: { default: "collided" },
        radius: { default: 0.05 },
        watch: { default: true }
      },
      init: function() {
        this.observer = null;
        this.els = [];
        this.collisions = [];
        this.prevCheckTime = void 0;
        this.eventDetail = {};
        this.handleHit = this.handleHit.bind(this);
        this.handleHitEnd = this.handleHitEnd.bind(this);
      },
      play: function() {
        const sceneEl = this.el.sceneEl;
        if (this.data.watch) {
          this.observer = new MutationObserver(this.update.bind(this, null));
          this.observer.observe(sceneEl, { childList: true, subtree: true });
        }
      },
      pause: function() {
        if (this.observer) {
          this.observer.disconnect();
          this.observer = null;
        }
      },
      /**
       * Update list of entities to test for collision.
       */
      update: function() {
        const data = this.data;
        let objectEls;
        if (data.objects) {
          objectEls = this.el.sceneEl.querySelectorAll(data.objects);
        } else {
          objectEls = this.el.sceneEl.children;
        }
        this.els = Array.prototype.slice.call(objectEls);
      },
      tick: function() {
        const position = new THREE.Vector3(), meshPosition = new THREE.Vector3(), colliderScale = new THREE.Vector3(), size = new THREE.Vector3(), box = new THREE.Box3(), collisions = [], distanceMap = /* @__PURE__ */ new Map();
        return function(time) {
          if (!this.data.enabled) {
            return;
          }
          const prevCheckTime = this.prevCheckTime;
          if (prevCheckTime && time - prevCheckTime < this.data.interval) {
            return;
          }
          this.prevCheckTime = time;
          const el = this.el, data = this.data, mesh = el.getObject3D("mesh");
          let colliderRadius;
          if (!mesh) {
            return;
          }
          collisions.length = 0;
          distanceMap.clear();
          el.object3D.getWorldPosition(position);
          el.object3D.getWorldScale(colliderScale);
          colliderRadius = data.radius * scaleFactor(colliderScale);
          this.els.forEach(intersect);
          collisions.sort((a, b) => distanceMap.get(a) > distanceMap.get(b) ? 1 : -1).forEach(this.handleHit);
          this.collisions.filter((el2) => !distanceMap.has(el2)).forEach(this.handleHitEnd);
          copyArray(this.collisions, collisions);
          function intersect(el2) {
            let radius, mesh2, distance2, extent;
            if (!el2.isEntity) {
              return;
            }
            mesh2 = el2.getObject3D("mesh");
            if (!mesh2) {
              return;
            }
            box.setFromObject(mesh2).getSize(size);
            extent = Math.max(size.x, size.y, size.z) / 2;
            radius = Math.sqrt(2 * extent * extent);
            box.getCenter(meshPosition);
            if (!radius) {
              return;
            }
            distance2 = position.distanceTo(meshPosition);
            if (distance2 < radius + colliderRadius) {
              collisions.push(el2);
              distanceMap.set(el2, distance2);
            }
          }
          function scaleFactor(scaleVec) {
            return Math.max(scaleVec.x, scaleVec.y, scaleVec.z);
          }
        };
      }(),
      handleHit: function(targetEl) {
        targetEl.emit("hit");
        targetEl.addState(this.data.state);
        this.eventDetail.el = targetEl;
        this.el.emit("hit", this.eventDetail);
      },
      handleHitEnd: function(targetEl) {
        targetEl.emit("hitend");
        targetEl.removeState(this.data.state);
        this.eventDetail.el = targetEl;
        this.el.emit("hitend", this.eventDetail);
      }
    });
    function copyArray(dest, source) {
      dest.length = 0;
      for (let i = 0; i < source.length; i++) {
        dest[i] = source[i];
      }
    }
  }
});

// node_modules/aframe-extras/src/misc/index.js
var require_misc = __commonJS({
  "node_modules/aframe-extras/src/misc/index.js"() {
    require_checkpoint();
    require_cube_env_map();
    require_grab();
    require_normal_material();
    require_sphere_collider();
  }
});

// node_modules/aframe-extras/src/pathfinding/nav-mesh.js
var require_nav_mesh = __commonJS({
  "node_modules/aframe-extras/src/pathfinding/nav-mesh.js"(exports, module) {
    module.exports = AFRAME.registerComponent("nav-mesh", {
      schema: {
        nodeName: { type: "string" }
      },
      init: function() {
        this.system = this.el.sceneEl.systems.nav;
        this.hasLoadedNavMesh = false;
        this.nodeName = this.data.nodeName;
        this.el.addEventListener("object3dset", this.loadNavMesh.bind(this));
      },
      play: function() {
        if (!this.hasLoadedNavMesh) this.loadNavMesh();
      },
      loadNavMesh: function() {
        var self = this;
        const object = this.el.getObject3D("mesh");
        const scene = this.el.sceneEl.object3D;
        if (!object) return;
        let navMesh;
        object.traverse((node) => {
          if (node.isMesh && (!self.nodeName || node.name === self.nodeName)) navMesh = node;
        });
        if (!navMesh) return;
        const navMeshGeometry = navMesh.geometry.clone();
        navMesh.updateWorldMatrix(true, false);
        navMeshGeometry.applyMatrix4(navMesh.matrixWorld);
        this.system.setNavMeshGeometry(navMeshGeometry);
        this.hasLoadedNavMesh = true;
      }
    });
  }
});

// node_modules/aframe-extras/src/pathfinding/nav-agent.js
var require_nav_agent = __commonJS({
  "node_modules/aframe-extras/src/pathfinding/nav-agent.js"(exports, module) {
    module.exports = AFRAME.registerComponent("nav-agent", {
      schema: {
        destination: { type: "vec3" },
        active: { default: false },
        speed: { default: 2 }
      },
      init: function() {
        this.system = this.el.sceneEl.systems.nav;
        this.system.addAgent(this);
        this.group = null;
        this.path = [];
        this.raycaster = new THREE.Raycaster();
      },
      remove: function() {
        this.system.removeAgent(this);
      },
      update: function() {
        this.path.length = 0;
      },
      updateNavLocation: function() {
        this.group = null;
        this.path = [];
      },
      tick: function() {
        const vDest = new THREE.Vector3();
        const vDelta = new THREE.Vector3();
        const vNext = new THREE.Vector3();
        return function(t, dt) {
          const el = this.el;
          const data = this.data;
          const raycaster = this.raycaster;
          const speed = data.speed * dt / 1e3;
          if (!data.active) return;
          if (!this.path.length) {
            const position = this.el.object3D.position;
            this.group = this.group || this.system.getGroup(position);
            this.path = this.system.getPath(position, vDest.copy(data.destination), this.group) || [];
            el.emit("navigation-start");
          }
          if (!this.path.length) {
            console.warn("[nav] Unable to find path to %o.", data.destination);
            this.el.setAttribute("nav-agent", { active: false });
            el.emit("navigation-end");
            return;
          }
          const vCurrent = el.object3D.position;
          const vWaypoint = this.path[0];
          vDelta.subVectors(vWaypoint, vCurrent);
          const distance2 = vDelta.length();
          let gazeTarget;
          if (distance2 < speed) {
            this.path.shift();
            if (!this.path.length) {
              this.el.setAttribute("nav-agent", { active: false });
              el.emit("navigation-end");
              return;
            }
            vNext.copy(vCurrent);
            gazeTarget = this.path[0];
          } else {
            vNext.copy(vDelta.setLength(speed)).add(vCurrent);
            gazeTarget = vWaypoint;
          }
          gazeTarget.y = vCurrent.y;
          el.object3D.lookAt(gazeTarget);
          raycaster.ray.origin.copy(vNext);
          raycaster.ray.origin.y += 1.5;
          raycaster.ray.direction = { x: 0, y: -1, z: 0 };
          const intersections = raycaster.intersectObject(this.system.getNavMesh());
          if (!intersections.length) {
            vCurrent.copy(vNext);
          } else {
            vDelta.subVectors(intersections[0].point, vCurrent);
            vCurrent.add(vDelta.setLength(speed));
          }
        };
      }()
    });
  }
});

// node_modules/three-pathfinding/dist/three-pathfinding.module.js
var three_pathfinding_module_exports = {};
__export(three_pathfinding_module_exports, {
  Pathfinding: () => f,
  PathfindingHelper: () => v
});
var d, p, g, f, v;
var init_three_pathfinding_module = __esm({
  "node_modules/three-pathfinding/dist/three-pathfinding.module.js"() {
    init_three_module();
    d = class {
      static roundNumber(t, e) {
        const s = Math.pow(10, e);
        return Math.round(t * s) / s;
      }
      static sample(t) {
        return t[Math.floor(Math.random() * t.length)];
      }
      static distanceToSquared(t, e) {
        var s = t.x - e.x, r = t.y - e.y, n = t.z - e.z;
        return s * s + r * r + n * n;
      }
      static isPointInPoly(t, e) {
        for (var s = false, r = -1, n = t.length, o = n - 1; ++r < n; o = r) (t[r].z <= e.z && e.z < t[o].z || t[o].z <= e.z && e.z < t[r].z) && e.x < (t[o].x - t[r].x) * (e.z - t[r].z) / (t[o].z - t[r].z) + t[r].x && (s = !s);
        return s;
      }
      static isVectorInPolygon(t, e, s) {
        var r = 1e5, n = -1e5, o = [];
        return e.vertexIds.forEach((t2) => {
          r = Math.min(s[t2].y, r), n = Math.max(s[t2].y, n), o.push(s[t2]);
        }), !!(t.y < n + 0.5 && t.y > r - 0.5 && this.isPointInPoly(o, t));
      }
      static triarea2(t, e, s) {
        return (s.x - t.x) * (e.z - t.z) - (e.x - t.x) * (s.z - t.z);
      }
      static vequal(t, e) {
        return this.distanceToSquared(t, e) < 1e-5;
      }
      static mergeVertices(s, r = 1e-4) {
        r = Math.max(r, Number.EPSILON);
        for (var n = {}, o = s.getIndex(), i = s.getAttribute("position"), h = o ? o.count : i.count, c = 0, a = [], u = [], l = Math.log10(1 / r), d2 = Math.pow(10, l), p2 = 0; p2 < h; p2++) {
          var g2 = o ? o.getX(p2) : p2, f2 = "";
          f2 += ~~(i.getX(g2) * d2) + ",", f2 += ~~(i.getY(g2) * d2) + ",", (f2 += ~~(i.getZ(g2) * d2) + ",") in n ? a.push(n[f2]) : (u.push(i.getX(g2)), u.push(i.getY(g2)), u.push(i.getZ(g2)), n[f2] = c, a.push(c), c++);
        }
        const v2 = new BufferAttribute(new Float32Array(u), i.itemSize, i.normalized), b = new BufferGeometry();
        return b.setAttribute("position", v2), b.setIndex(a), b;
      }
    };
    p = class {
      constructor(t) {
        this.content = [], this.scoreFunction = t;
      }
      push(t) {
        this.content.push(t), this.sinkDown(this.content.length - 1);
      }
      pop() {
        const t = this.content[0], e = this.content.pop();
        return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t;
      }
      remove(t) {
        const e = this.content.indexOf(t), s = this.content.pop();
        e !== this.content.length - 1 && (this.content[e] = s, this.scoreFunction(s) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e));
      }
      size() {
        return this.content.length;
      }
      rescoreElement(t) {
        this.sinkDown(this.content.indexOf(t));
      }
      sinkDown(t) {
        const e = this.content[t];
        for (; t > 0; ) {
          const s = (t + 1 >> 1) - 1, r = this.content[s];
          if (!(this.scoreFunction(e) < this.scoreFunction(r))) break;
          this.content[s] = e, this.content[t] = r, t = s;
        }
      }
      bubbleUp(t) {
        const e = this.content.length, s = this.content[t], r = this.scoreFunction(s);
        for (; ; ) {
          const n = t + 1 << 1, o = n - 1;
          let i, h = null;
          if (o < e && (i = this.scoreFunction(this.content[o]), i < r && (h = o)), n < e && this.scoreFunction(this.content[n]) < (null === h ? r : i) && (h = n), null === h) break;
          this.content[t] = this.content[h], this.content[h] = s, t = h;
        }
      }
    };
    g = class {
      constructor() {
        this.portals = [];
      }
      push(t, e) {
        void 0 === e && (e = t), this.portals.push({ left: t, right: e });
      }
      stringPull() {
        const t = this.portals, e = [];
        let s, r, n, o = 0, i = 0, h = 0;
        s = t[0].left, r = t[0].left, n = t[0].right, e.push(s);
        for (let c = 1; c < t.length; c++) {
          const a = t[c].left, u = t[c].right;
          if (d.triarea2(s, n, u) <= 0) {
            if (!(d.vequal(s, n) || d.triarea2(s, r, u) > 0)) {
              e.push(r), s = r, o = i, r = s, n = s, i = o, h = o, c = o;
              continue;
            }
            n = u, h = c;
          }
          if (d.triarea2(s, r, a) >= 0) {
            if (!(d.vequal(s, r) || d.triarea2(s, n, a) < 0)) {
              e.push(n), s = n, o = h, r = s, n = s, i = o, h = o, c = o;
              continue;
            }
            r = a, i = c;
          }
        }
        return 0 !== e.length && d.vequal(e[e.length - 1], t[t.length - 1].left) || e.push(t[t.length - 1].left), this.path = e, e;
      }
    };
    f = class {
      constructor() {
        this.zones = {};
      }
      static createZone(t, e = 1e-4) {
        return (class {
          static buildZone(t2, e2) {
            const r = this._buildNavigationMesh(t2, e2), n = {};
            r.vertices.forEach((t3) => {
              t3.x = d.roundNumber(t3.x, 2), t3.y = d.roundNumber(t3.y, 2), t3.z = d.roundNumber(t3.z, 2);
            }), n.vertices = r.vertices;
            const o = this._buildPolygonGroups(r);
            return n.groups = new Array(o.length), o.forEach((t3, e3) => {
              const r2 = /* @__PURE__ */ new Map();
              t3.forEach((t4, e4) => {
                r2.set(t4, e4);
              });
              const o2 = new Array(t3.length);
              t3.forEach((t4, e4) => {
                const i = [];
                t4.neighbours.forEach((t5) => i.push(r2.get(t5)));
                const h = [];
                t4.neighbours.forEach((e5) => h.push(this._getSharedVerticesInOrder(t4, e5)));
                const c = new Vector3(0, 0, 0);
                c.add(n.vertices[t4.vertexIds[0]]), c.add(n.vertices[t4.vertexIds[1]]), c.add(n.vertices[t4.vertexIds[2]]), c.divideScalar(3), c.x = d.roundNumber(c.x, 2), c.y = d.roundNumber(c.y, 2), c.z = d.roundNumber(c.z, 2), o2[e4] = { id: e4, neighbours: i, vertexIds: t4.vertexIds, centroid: c, portals: h };
              }), n.groups[e3] = o2;
            }), n;
          }
          static _buildNavigationMesh(t2, e2) {
            return t2 = d.mergeVertices(t2, e2), this._buildPolygonsFromGeometry(t2);
          }
          static _spreadGroupId(t2) {
            let e2 = /* @__PURE__ */ new Set([t2]);
            for (; e2.size > 0; ) {
              const s = e2;
              e2 = /* @__PURE__ */ new Set(), s.forEach((s2) => {
                s2.group = t2.group, s2.neighbours.forEach((t3) => {
                  void 0 === t3.group && e2.add(t3);
                });
              });
            }
          }
          static _buildPolygonGroups(t2) {
            const e2 = [];
            return t2.polygons.forEach((t3) => {
              void 0 !== t3.group ? e2[t3.group].push(t3) : (t3.group = e2.length, this._spreadGroupId(t3), e2.push([t3]));
            }), e2;
          }
          static _buildPolygonNeighbours(t2, e2) {
            const s = /* @__PURE__ */ new Set(), r = e2[t2.vertexIds[1]], n = e2[t2.vertexIds[2]];
            return e2[t2.vertexIds[0]].forEach((e3) => {
              e3 !== t2 && (r.includes(e3) || n.includes(e3)) && s.add(e3);
            }), r.forEach((e3) => {
              e3 !== t2 && n.includes(e3) && s.add(e3);
            }), s;
          }
          static _buildPolygonsFromGeometry(t2) {
            const e2 = [], r = [], n = t2.attributes.position, o = t2.index, i = [];
            for (let t3 = 0; t3 < n.count; t3++) r.push(new Vector3().fromBufferAttribute(n, t3)), i[t3] = [];
            for (let s = 0; s < t2.index.count; s += 3) {
              const t3 = o.getX(s), r2 = o.getX(s + 1), n2 = o.getX(s + 2), h = { vertexIds: [t3, r2, n2], neighbours: null };
              e2.push(h), i[t3].push(h), i[r2].push(h), i[n2].push(h);
            }
            return e2.forEach((t3) => {
              t3.neighbours = this._buildPolygonNeighbours(t3, i);
            }), { polygons: e2, vertices: r };
          }
          static _getSharedVerticesInOrder(t2, e2) {
            const s = t2.vertexIds, r = s[0], n = s[1], o = s[2], i = e2.vertexIds, h = i.includes(r), c = i.includes(n), a = i.includes(o);
            return h && c && a ? Array.from(s) : h && c ? [r, n] : c && a ? [n, o] : h && a ? [o, r] : (console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."), []);
          }
        }).buildZone(t, e);
      }
      setZoneData(t, e) {
        this.zones[t] = e;
      }
      getRandomNode(t, e, r, n) {
        if (!this.zones[t]) return new Vector3();
        r = r || null, n = n || 0;
        const o = [];
        return this.zones[t].groups[e].forEach((t2) => {
          r && n ? d.distanceToSquared(r, t2.centroid) < n * n && o.push(t2.centroid) : o.push(t2.centroid);
        }), d.sample(o) || new Vector3();
      }
      getClosestNode(t, e, s, r = false) {
        const n = this.zones[e].vertices;
        let o = null, i = Infinity;
        return this.zones[e].groups[s].forEach((e2) => {
          const s2 = d.distanceToSquared(e2.centroid, t);
          s2 < i && (!r || d.isVectorInPolygon(t, e2, n)) && (o = e2, i = s2);
        }), o;
      }
      findPath(t, e, r, n) {
        const o = this.zones[r].groups[n], i = this.zones[r].vertices, h = this.getClosestNode(t, r, n, true), c = this.getClosestNode(e, r, n, true);
        if (!h || !c) return null;
        const a = (class {
          static init(t2) {
            for (let e2 = 0; e2 < t2.length; e2++) {
              const s = t2[e2];
              s.f = 0, s.g = 0, s.h = 0, s.cost = 1, s.visited = false, s.closed = false, s.parent = null;
            }
          }
          static cleanUp(t2) {
            for (let e2 = 0; e2 < t2.length; e2++) {
              const s = t2[e2];
              delete s.f, delete s.g, delete s.h, delete s.cost, delete s.visited, delete s.closed, delete s.parent;
            }
          }
          static heap() {
            return new p(function(t2) {
              return t2.f;
            });
          }
          static search(t2, e2, s) {
            this.init(t2);
            const r2 = this.heap();
            for (r2.push(e2); r2.size() > 0; ) {
              const e3 = r2.pop();
              if (e3 === s) {
                let t3 = e3;
                const s2 = [];
                for (; t3.parent; ) s2.push(t3), t3 = t3.parent;
                return this.cleanUp(s2), s2.reverse();
              }
              e3.closed = true;
              const n2 = this.neighbours(t2, e3);
              for (let t3 = 0, o2 = n2.length; t3 < o2; t3++) {
                const o3 = n2[t3];
                if (o3.closed) continue;
                const i2 = e3.g + o3.cost, h2 = o3.visited;
                if (!h2 || i2 < o3.g) {
                  if (o3.visited = true, o3.parent = e3, !o3.centroid || !s.centroid) throw new Error("Unexpected state");
                  o3.h = o3.h || this.heuristic(o3.centroid, s.centroid), o3.g = i2, o3.f = o3.g + o3.h, h2 ? r2.rescoreElement(o3) : r2.push(o3);
                }
              }
            }
            return [];
          }
          static heuristic(t2, e2) {
            return d.distanceToSquared(t2, e2);
          }
          static neighbours(t2, e2) {
            const s = [];
            for (let r2 = 0; r2 < e2.neighbours.length; r2++) s.push(t2[e2.neighbours[r2]]);
            return s;
          }
        }).search(o, h, c), u = function(t2, e2) {
          for (var s = 0; s < t2.neighbours.length; s++) if (t2.neighbours[s] === e2.id) return t2.portals[s];
        }, l = new g();
        l.push(t);
        for (let t2 = 0; t2 < a.length; t2++) {
          const e2 = a[t2], s = a[t2 + 1];
          if (s) {
            const t3 = u(e2, s);
            l.push(i[t3[0]], i[t3[1]]);
          }
        }
        l.push(e), l.stringPull();
        const f2 = l.path.map((t2) => new Vector3(t2.x, t2.y, t2.z));
        return f2.shift(), f2;
      }
    };
    f.prototype.getGroup = function() {
      const t = new Plane();
      return function(e, s, r = false) {
        if (!this.zones[e]) return null;
        let n = null, o = Math.pow(50, 2);
        const i = this.zones[e];
        for (let e2 = 0; e2 < i.groups.length; e2++) {
          const h = i.groups[e2];
          for (const c of h) {
            if (r && (t.setFromCoplanarPoints(i.vertices[c.vertexIds[0]], i.vertices[c.vertexIds[1]], i.vertices[c.vertexIds[2]]), Math.abs(t.distanceToPoint(s)) < 0.01) && d.isPointInPoly([i.vertices[c.vertexIds[0]], i.vertices[c.vertexIds[1]], i.vertices[c.vertexIds[2]]], s)) return e2;
            const h2 = d.distanceToSquared(c.centroid, s);
            h2 < o && (n = e2, o = h2);
          }
        }
        return n;
      };
    }(), f.prototype.clampStep = function() {
      const t = new Vector3(), e = new Plane(), o = new Triangle(), i = new Vector3();
      let h, c, a = new Vector3();
      return function(s, r, n, u, l, d2) {
        const p2 = this.zones[u].vertices, g2 = this.zones[u].groups[l], f2 = [n], v2 = {};
        v2[n.id] = 0, h = void 0, a.set(0, 0, 0), c = Infinity, e.setFromCoplanarPoints(p2[n.vertexIds[0]], p2[n.vertexIds[1]], p2[n.vertexIds[2]]), e.projectPoint(r, t), i.copy(t);
        for (let e2 = f2.pop(); e2; e2 = f2.pop()) {
          o.set(p2[e2.vertexIds[0]], p2[e2.vertexIds[1]], p2[e2.vertexIds[2]]), o.closestPointToPoint(i, t), t.distanceToSquared(i) < c && (h = e2, a.copy(t), c = t.distanceToSquared(i));
          const s2 = v2[e2.id];
          if (!(s2 > 2)) for (let t2 = 0; t2 < e2.neighbours.length; t2++) {
            const r2 = g2[e2.neighbours[t2]];
            r2.id in v2 || (f2.push(r2), v2[r2.id] = s2 + 1);
          }
        }
        return d2.copy(a), h;
      };
    }();
    v = class extends Object3D {
      constructor() {
        super(), this._playerMarker = new Mesh(new SphereGeometry(0.25, 32, 32), new MeshBasicMaterial({ color: 15631215 })), this._targetMarker = new Mesh(new BoxGeometry(0.3, 0.3, 0.3), new MeshBasicMaterial({ color: 14469912 })), this._nodeMarker = new Mesh(new BoxGeometry(0.1, 0.8, 0.1), new MeshBasicMaterial({ color: 4417387 })), this._stepMarker = new Mesh(new BoxGeometry(0.1, 1, 0.1), new MeshBasicMaterial({ color: 14472114 })), this._pathMarker = new Object3D(), this._pathLineMaterial = new LineBasicMaterial({ color: 41903, linewidth: 2 }), this._pathPointMaterial = new MeshBasicMaterial({ color: 41903 }), this._pathPointGeometry = new SphereGeometry(0.08), this._markers = [this._playerMarker, this._targetMarker, this._nodeMarker, this._stepMarker, this._pathMarker], this._markers.forEach((t) => {
          t.visible = false, this.add(t);
        });
      }
      setPath(s) {
        for (; this._pathMarker.children.length; ) this._pathMarker.children[0].visible = false, this._pathMarker.remove(this._pathMarker.children[0]);
        s = [this._playerMarker.position].concat(s);
        const r = new BufferGeometry();
        r.setAttribute("position", new BufferAttribute(new Float32Array(3 * s.length), 3));
        for (let t = 0; t < s.length; t++) r.attributes.position.setXYZ(t, s[t].x, s[t].y + 0.2, s[t].z);
        this._pathMarker.add(new Line(r, this._pathLineMaterial));
        for (let t = 0; t < s.length - 1; t++) {
          const e = new Mesh(this._pathPointGeometry, this._pathPointMaterial);
          e.position.copy(s[t]), e.position.y += 0.2, this._pathMarker.add(e);
        }
        return this._pathMarker.visible = true, this;
      }
      setPlayerPosition(t) {
        return this._playerMarker.position.copy(t), this._playerMarker.visible = true, this;
      }
      setTargetPosition(t) {
        return this._targetMarker.position.copy(t), this._targetMarker.visible = true, this;
      }
      setNodePosition(t) {
        return this._nodeMarker.position.copy(t), this._nodeMarker.visible = true, this;
      }
      setStepPosition(t) {
        return this._stepMarker.position.copy(t), this._stepMarker.visible = true, this;
      }
      reset() {
        for (; this._pathMarker.children.length; ) this._pathMarker.children[0].visible = false, this._pathMarker.remove(this._pathMarker.children[0]);
        return this._markers.forEach((t) => {
          t.visible = false;
        }), this;
      }
    };
  }
});

// node_modules/aframe-extras/src/pathfinding/system.js
var require_system = __commonJS({
  "node_modules/aframe-extras/src/pathfinding/system.js"(exports, module) {
    var { Pathfinding } = (init_three_pathfinding_module(), __toCommonJS(three_pathfinding_module_exports));
    var pathfinder = new Pathfinding();
    var ZONE = "level";
    module.exports = AFRAME.registerSystem("nav", {
      init: function() {
        this.navMesh = null;
        this.agents = /* @__PURE__ */ new Set();
      },
      /**
       * @param {THREE.Geometry} geometry
       */
      setNavMeshGeometry: function(geometry) {
        this.navMesh = new THREE.Mesh(geometry);
        pathfinder.setZoneData(ZONE, Pathfinding.createZone(geometry));
        Array.from(this.agents).forEach((agent) => agent.updateNavLocation());
      },
      /**
       * @return {THREE.Mesh}
       */
      getNavMesh: function() {
        return this.navMesh;
      },
      /**
       * @param {NavAgent} ctrl
       */
      addAgent: function(ctrl) {
        this.agents.add(ctrl);
      },
      /**
       * @param {NavAgent} ctrl
       */
      removeAgent: function(ctrl) {
        this.agents.delete(ctrl);
      },
      /**
       * @param  {THREE.Vector3} start
       * @param  {THREE.Vector3} end
       * @param  {number} groupID
       * @return {Array<THREE.Vector3>}
       */
      getPath: function(start, end, groupID) {
        return this.navMesh ? pathfinder.findPath(start, end, ZONE, groupID) : null;
      },
      /**
       * @param {THREE.Vector3} position
       * @return {number}
       */
      getGroup: function(position) {
        return this.navMesh ? pathfinder.getGroup(ZONE, position) : null;
      },
      /**
       * @param  {THREE.Vector3} position
       * @param  {number} groupID
       * @return {Node}
       */
      getNode: function(position, groupID) {
        return this.navMesh ? pathfinder.getClosestNode(position, ZONE, groupID, true) : null;
      },
      /**
       * @param  {THREE.Vector3} start Starting position.
       * @param  {THREE.Vector3} end Desired ending position.
       * @param  {number} groupID
       * @param  {Node} node
       * @param  {THREE.Vector3} endTarget (Output) Adjusted step end position.
       * @return {Node} Current node, after step is taken.
       */
      clampStep: function(start, end, groupID, node, endTarget) {
        if (!this.navMesh) {
          endTarget.copy(end);
          return null;
        } else if (!node) {
          endTarget.copy(end);
          return this.getNode(end, groupID);
        }
        return pathfinder.clampStep(start, end, node, ZONE, groupID, endTarget);
      }
    });
  }
});

// node_modules/aframe-extras/src/pathfinding/index.js
var require_pathfinding = __commonJS({
  "node_modules/aframe-extras/src/pathfinding/index.js"() {
    require_nav_mesh();
    require_nav_agent();
    require_system();
  }
});

// node_modules/aframe-extras/src/primitives/a-grid.js
var require_a_grid = __commonJS({
  "node_modules/aframe-extras/src/primitives/a-grid.js"(exports, module) {
    module.exports = AFRAME.registerPrimitive("a-grid", {
      defaultComponents: {
        geometry: {
          primitive: "plane",
          width: 75,
          height: 75
        },
        rotation: { x: -90, y: 0, z: 0 },
        material: {
          src: "url(https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v1.16.3/assets/grid.png)",
          repeat: "75 75"
        }
      },
      mappings: {
        width: "geometry.width",
        height: "geometry.height",
        src: "material.src"
      }
    });
  }
});

// node_modules/aframe-extras/src/primitives/a-ocean.js
var require_a_ocean = __commonJS({
  "node_modules/aframe-extras/src/primitives/a-ocean.js"(exports, module) {
    module.exports.Primitive = AFRAME.registerPrimitive("a-ocean", {
      defaultComponents: {
        ocean: {},
        rotation: { x: -90, y: 0, z: 0 }
      },
      mappings: {
        width: "ocean.width",
        depth: "ocean.depth",
        density: "ocean.density",
        amplitude: "ocean.amplitude",
        amplitudeVariance: "ocean.amplitudeVariance",
        speed: "ocean.speed",
        speedVariance: "ocean.speedVariance",
        color: "ocean.color",
        opacity: "ocean.opacity"
      }
    });
    module.exports.Component = AFRAME.registerComponent("ocean", {
      schema: {
        // Dimensions of the ocean area.
        width: { default: 10, min: 0 },
        depth: { default: 10, min: 0 },
        // Density of waves.
        density: { default: 10 },
        // Wave amplitude and variance.
        amplitude: { default: 0.1 },
        amplitudeVariance: { default: 0.3 },
        // Wave speed and variance.
        speed: { default: 1 },
        speedVariance: { default: 2 },
        // Material.
        color: { default: "#7AD2F7", type: "color" },
        opacity: { default: 0.8 }
      },
      /**
       * Use play() instead of init(), because component mappings – unavailable as dependencies – are
       * not guaranteed to have parsed when this component is initialized.
       */
      play: function() {
        const el = this.el;
        const data = this.data;
        let material = el.components.material;
        const geometry = new THREE.PlaneGeometry(data.width, data.depth, data.density, data.density);
        this.waves = [];
        const posAttribute = geometry.getAttribute("position");
        for (let i = 0; i < posAttribute.count; i++) {
          this.waves.push({
            z: posAttribute.getZ(i),
            ang: Math.random() * Math.PI * 2,
            amp: data.amplitude + Math.random() * data.amplitudeVariance,
            speed: (data.speed + Math.random() * data.speedVariance) / 1e3
            // radians / frame
          });
        }
        if (!material) {
          material = {};
          material.material = new THREE.MeshPhongMaterial({
            color: data.color,
            transparent: data.opacity < 1,
            opacity: data.opacity,
            flatShading: true
          });
        }
        this.mesh = new THREE.Mesh(geometry, material.material);
        el.setObject3D("mesh", this.mesh);
      },
      remove: function() {
        this.el.removeObject3D("mesh");
      },
      tick: function(t, dt) {
        if (!dt) return;
        const posAttribute = this.mesh.geometry.getAttribute("position");
        for (let i = 0; i < posAttribute.count; i++) {
          const vprops = this.waves[i];
          const value = vprops.z + Math.sin(vprops.ang) * vprops.amp;
          posAttribute.setZ(i, value);
          vprops.ang += vprops.speed * dt;
        }
        posAttribute.needsUpdate = true;
      }
    });
  }
});

// node_modules/aframe-extras/src/primitives/a-tube.js
var require_a_tube = __commonJS({
  "node_modules/aframe-extras/src/primitives/a-tube.js"(exports, module) {
    module.exports.Primitive = AFRAME.registerPrimitive("a-tube", {
      defaultComponents: {
        tube: {}
      },
      mappings: {
        path: "tube.path",
        segments: "tube.segments",
        radius: "tube.radius",
        "radial-segments": "tube.radialSegments",
        closed: "tube.closed"
      }
    });
    module.exports.Component = AFRAME.registerComponent("tube", {
      schema: {
        path: { default: [] },
        segments: { default: 64 },
        radius: { default: 1 },
        radialSegments: { default: 8 },
        closed: { default: false }
      },
      init: function() {
        const el = this.el, data = this.data;
        let material = el.components.material;
        if (!data.path.length) {
          console.error("[a-tube] `path` property expected but not found.");
          return;
        }
        const curve = new THREE.CatmullRomCurve3(data.path.map(function(point) {
          point = point.split(" ");
          return new THREE.Vector3(Number(point[0]), Number(point[1]), Number(point[2]));
        }));
        const geometry = new THREE.TubeGeometry(
          curve,
          data.segments,
          data.radius,
          data.radialSegments,
          data.closed
        );
        if (!material) {
          material = {};
          material.material = new THREE.MeshPhongMaterial();
        }
        this.mesh = new THREE.Mesh(geometry, material.material);
        this.el.setObject3D("mesh", this.mesh);
      },
      update: function(prevData) {
        if (!Object.keys(prevData).length) return;
        this.remove();
        this.init();
      },
      remove: function() {
        if (this.mesh) this.el.removeObject3D("mesh");
      }
    });
  }
});

// node_modules/aframe-extras/src/primitives/index.js
var require_primitives = __commonJS({
  "node_modules/aframe-extras/src/primitives/index.js"() {
    require_a_grid();
    require_a_ocean();
    require_a_tube();
  }
});

// node_modules/aframe-extras/index.js
require_controls();
require_loaders();
require_misc();
require_pathfinding();
require_primitives();
/*! Bundled license information:

three/examples/jsm/libs/fflate.module.js:
  (*!
  fflate - fast JavaScript compression/decompression
  <https://101arrowz.github.io/fflate>
  Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
  version 0.8.2
  *)
*/
//# sourceMappingURL=aframe-extras.js.map
