{"version":3,"file":"three-to-cannon.js","sources":["../lib/ConvexHull.js","../index.js"],"sourcesContent":["import {\n\tLine3,\n\tPlane,\n\tTriangle,\n\tVector3\n} from 'three';\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nvar ConvexHull = ( function () {\n\n\tvar Visible = 0;\n\tvar Deleted = 1;\n\n\tvar v1 = new Vector3();\n\n\tfunction ConvexHull() {\n\n\t\tthis.tolerance = - 1;\n\n\t\tthis.faces = []; // the generated faces of the convex hull\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t\t// the vertex lists work as follows:\n\t\t//\n\t\t// let 'a' and 'b' be 'Face' instances\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\n\t\t//\n\t\t//     [v, v, ..., v, v, v, ...]\n\t\t//      ^             ^\n\t\t//      |             |\n\t\t//  a.outside     b.outside\n\t\t//\n\t\tthis.assigned = new VertexList();\n\t\tthis.unassigned = new VertexList();\n\n\t\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\n\n\t}\n\n\tObject.assign( ConvexHull.prototype, {\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tif ( Array.isArray( points ) !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.ConvexHull: Points parameter is not an array.' );\n\n\t\t\t}\n\n\t\t\tif ( points.length < 4 ) {\n\n\t\t\t\tconsole.error( 'THREE.ConvexHull: The algorithm needs at least four points.' );\n\n\t\t\t}\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.compute();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\tvar points = [];\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar i, l, point;\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tpoint = vertices[ i ].clone();\n\t\t\t\t\t\t\tpoint.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tpoint = new Vector3();\n\n\t\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.setFromPoints( points );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tvar faces = this.faces;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectRay: function ( ray, target ) {\n\n\t\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n\n\t\t\tvar faces = this.faces;\n\n\t\t\tvar tNear = - Infinity;\n\t\t\tvar tFar = Infinity;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// interpret faces as planes for the further computation\n\n\t\t\t\tvar vN = face.distanceToPoint( ray.origin );\n\t\t\t\tvar vD = face.normal.dot( ray.direction );\n\n\t\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\n\n\t\t\t\tvar t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t\t// lies \"behind\" the origin\n\n\t\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t\t//  plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// front-face\n\n\t\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// evaluate intersection point\n\n\t\t\t// always try tNear first since its the closer intersection point\n\n\t\t\tif ( tNear !== - Infinity ) {\n\n\t\t\t\tray.at( tNear, target );\n\n\t\t\t} else {\n\n\t\t\t\tray.at( tFar, target );\n\n\t\t\t}\n\n\t\t\treturn target;\n\n\t\t},\n\n\t\tintersectsRay: function ( ray ) {\n\n\t\t\treturn this.intersectRay( ray, v1 ) !== null;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.faces = [];\n\t\t\tthis.vertices = [];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\t\taddVertexToFace: function ( vertex, face ) {\n\n\t\t\tvertex.face = face;\n\n\t\t\tif ( face.outside === null ) {\n\n\t\t\t\tthis.assigned.append( vertex );\n\n\t\t\t} else {\n\n\t\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t\t}\n\n\t\t\tface.outside = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\t\tremoveVertexFromFace: function ( vertex, face ) {\n\n\t\t\tif ( vertex === face.outside ) {\n\n\t\t\t\t// fix face.outside link\n\n\t\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\t\tface.outside = vertex.next;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\t\tface.outside = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.assigned.remove( vertex );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\t\tremoveAllVerticesFromFace: function ( face ) {\n\n\t\t\tif ( face.outside !== null ) {\n\n\t\t\t\t// reference to the first and last vertex of this face\n\n\t\t\t\tvar start = face.outside;\n\t\t\t\tvar end = face.outside;\n\n\t\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\t\tend = end.next;\n\n\t\t\t\t}\n\n\t\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t\t// fix references\n\n\t\t\t\tstart.prev = end.next = null;\n\t\t\t\tface.outside = null;\n\n\t\t\t\treturn start;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Removes all the visible vertices that 'face' is able to see\n\n\t\tdeleteFaceVertices: function ( face, absorbingFace ) {\n\n\t\t\tvar faceVertices = this.removeAllVerticesFromFace( face );\n\n\t\t\tif ( faceVertices !== undefined ) {\n\n\t\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\t\tvar vertex = faceVertices;\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\t\tvar distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t\t} while ( vertex !== null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\t\tresolveUnassignedPoints: function ( newFaces ) {\n\n\t\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\t\tvar vertex = this.unassigned.first();\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\n\n\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\tvar maxDistance = this.tolerance;\n\n\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\tfor ( var i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\t\tvar face = newFaces[ i ];\n\n\t\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\t\tvar distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Computes the extremes of a simplex which will be the initial hull\n\n\t\tcomputeExtremes: function () {\n\n\t\t\tvar min = new Vector3();\n\t\t\tvar max = new Vector3();\n\n\t\t\tvar minVertices = [];\n\t\t\tvar maxVertices = [];\n\n\t\t\tvar i, l, j;\n\n\t\t\t// initially assume that the first vertex is the min/max\n\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t\t}\n\n\t\t\tmin.copy( this.vertices[ 0 ].point );\n\t\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t\t// compute the min/max vertex on all six directions\n\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvar point = vertex.point;\n\n\t\t\t\t// update the min coordinates\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the max coordinates\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t\t);\n\n\t\t\treturn { min: minVertices, max: maxVertices };\n\n\t\t},\n\n\t\t// Computes the initial simplex assigning to its faces all the points\n\t\t// that are candidates to form part of the hull\n\n\t\tcomputeInitialHull: function () {\n\n\t\t\tvar line3, plane, closestPoint;\n\n\t\t\treturn function computeInitialHull() {\n\n\t\t\t\tif ( line3 === undefined ) {\n\n\t\t\t\t\tline3 = new Line3();\n\t\t\t\t\tplane = new Plane();\n\t\t\t\t\tclosestPoint = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar vertex, vertices = this.vertices;\n\t\t\t\tvar extremes = this.computeExtremes();\n\t\t\t\tvar min = extremes.min;\n\t\t\t\tvar max = extremes.max;\n\n\t\t\t\tvar v0, v1, v2, v3;\n\t\t\t\tvar i, l, j;\n\n\t\t\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t\t\t// (max.x - min.x)\n\t\t\t\t// (max.y - min.y)\n\t\t\t\t// (max.z - min.z)\n\n\t\t\t\tvar distance, maxDistance = 0;\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tdistance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tindex = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tv0 = min[ index ];\n\t\t\t\tv1 = max[ index ];\n\n\t\t\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\t\t\tmaxDistance = 0;\n\t\t\t\tline3.set( v0.point, v1.point );\n\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t\t\tline3.closestPointToPoint( vertex.point, true, closestPoint );\n\n\t\t\t\t\t\tdistance = closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\t\t\tmaxDistance = - 1;\n\t\t\t\tplane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\t\t\tdistance = Math.abs( plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar faces = [];\n\n\t\t\t\tif ( plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// set the twin edge\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// set the twin edge\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// the initial hull is the tetrahedron\n\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\tdistance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\t// Removes inactive faces\n\n\t\treindexFaces: function () {\n\n\t\t\tvar activeFaces = [];\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\tactiveFaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.faces = activeFaces;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Finds the next vertex to create faces with the current hull\n\n\t\tnextVertexToAdd: function () {\n\n\t\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\t\tvar eyeVertex, maxDistance = 0;\n\n\t\t\t\t// grap the first available face and start with the first visible vertex of that face\n\n\t\t\t\tvar eyeFace = this.assigned.first().face;\n\t\t\t\tvar vertex = eyeFace.outside;\n\n\t\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvar distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertex = vertex.next;\n\n\t\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\t\treturn eyeVertex;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Computes a chain of half edges in CCW order called the 'horizon'.\n\t\t// For an edge to be part of the horizon it must join a face that can see\n\t\t// 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\t\tcomputeHorizon: function ( eyePoint, crossEdge, face, horizon ) {\n\n\t\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\t\tthis.deleteFaceVertices( face );\n\n\t\t\tface.mark = Deleted;\n\n\t\t\tvar edge;\n\n\t\t\tif ( crossEdge === null ) {\n\n\t\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\t\tedge = crossEdge.next;\n\n\t\t\t}\n\n\t\t\tdo {\n\n\t\t\t\tvar twinEdge = edge.twin;\n\t\t\t\tvar oppositeFace = twinEdge.face;\n\n\t\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\n\t\t\t} while ( edge !== crossEdge );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\t\taddAdjoiningFace: function ( eyeVertex, horizonEdge ) {\n\n\t\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\t\tvar face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\t\tthis.faces.push( face );\n\n\t\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t\t},\n\n\t\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\n\t\t//  horizon opposite face and the face on the left/right\n\n\t\taddNewFaces: function ( eyeVertex, horizon ) {\n\n\t\t\tthis.newFaces = [];\n\n\t\t\tvar firstSideEdge = null;\n\t\t\tvar previousSideEdge = null;\n\n\t\t\tfor ( var i = 0; i < horizon.length; i ++ ) {\n\n\t\t\t\tvar horizonEdge = horizon[ i ];\n\n\t\t\t\t// returns the right side edge\n\n\t\t\t\tvar sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t\t}\n\n\t\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t\t}\n\n\t\t\t// perform final join of new faces\n\n\t\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Adds a vertex to the hull\n\n\t\taddVertexToHull: function ( eyeVertex ) {\n\n\t\t\tvar horizon = [];\n\n\t\t\tthis.unassigned.clear();\n\n\t\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\t\tthis.addNewFaces( eyeVertex, horizon );\n\n\t\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\t\tthis.resolveUnassignedPoints( this.newFaces );\n\n\t\t\treturn\tthis;\n\n\t\t},\n\n\t\tcleanup: function () {\n\n\t\t\tthis.assigned.clear();\n\t\t\tthis.unassigned.clear();\n\t\t\tthis.newFaces = [];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompute: function () {\n\n\t\t\tvar vertex;\n\n\t\t\tthis.computeInitialHull();\n\n\t\t\t// add all available vertices gradually to the hull\n\n\t\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\n\n\t\t\t\tthis.addVertexToHull( vertex );\n\n\t\t\t}\n\n\t\t\tthis.reindexFaces();\n\n\t\t\tthis.cleanup();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tfunction Face() {\n\n\t\tthis.normal = new Vector3();\n\t\tthis.midpoint = new Vector3();\n\t\tthis.area = 0;\n\n\t\tthis.constant = 0; // signed distance from face to the origin\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\t\tthis.mark = Visible;\n\t\tthis.edge = null;\n\n\t}\n\n\tObject.assign( Face, {\n\n\t\tcreate: function ( a, b, c ) {\n\n\t\t\tvar face = new Face();\n\n\t\t\tvar e0 = new HalfEdge( a, face );\n\t\t\tvar e1 = new HalfEdge( b, face );\n\t\t\tvar e2 = new HalfEdge( c, face );\n\n\t\t\t// join edges\n\n\t\t\te0.next = e2.prev = e1;\n\t\t\te1.next = e0.prev = e2;\n\t\t\te2.next = e1.prev = e0;\n\n\t\t\t// main half edge reference\n\n\t\t\tface.edge = e0;\n\n\t\t\treturn face.compute();\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Face.prototype, {\n\n\t\tgetEdge: function ( i ) {\n\n\t\t\tvar edge = this.edge;\n\n\t\t\twhile ( i > 0 ) {\n\n\t\t\t\tedge = edge.next;\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\twhile ( i < 0 ) {\n\n\t\t\t\tedge = edge.prev;\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn edge;\n\n\t\t},\n\n\t\tcompute: function () {\n\n\t\t\tvar triangle;\n\n\t\t\treturn function compute() {\n\n\t\t\t\tif ( triangle === undefined ) triangle = new Triangle();\n\n\t\t\t\tvar a = this.edge.tail();\n\t\t\t\tvar b = this.edge.head();\n\t\t\t\tvar c = this.edge.next.head();\n\n\t\t\t\ttriangle.set( a.point, b.point, c.point );\n\n\t\t\t\ttriangle.getNormal( this.normal );\n\t\t\t\ttriangle.getMidpoint( this.midpoint );\n\t\t\t\tthis.area = triangle.getArea();\n\n\t\t\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) - this.constant;\n\n\t\t}\n\n\t} );\n\n\t// Entity for a Doubly-Connected Edge List (DCEL).\n\n\tfunction HalfEdge( vertex, face ) {\n\n\t\tthis.vertex = vertex;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.twin = null;\n\t\tthis.face = face;\n\n\t}\n\n\tObject.assign( HalfEdge.prototype, {\n\n\t\thead: function () {\n\n\t\t\treturn this.vertex;\n\n\t\t},\n\n\t\ttail: function () {\n\n\t\t\treturn this.prev ? this.prev.vertex : null;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\tvar head = this.head();\n\t\t\tvar tail = this.tail();\n\n\t\t\tif ( tail !== null ) {\n\n\t\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t\t}\n\n\t\t\treturn - 1;\n\n\t\t},\n\n\t\tlengthSquared: function () {\n\n\t\t\tvar head = this.head();\n\t\t\tvar tail = this.tail();\n\n\t\t\tif ( tail !== null ) {\n\n\t\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t\t}\n\n\t\t\treturn - 1;\n\n\t\t},\n\n\t\tsetTwin: function ( edge ) {\n\n\t\t\tthis.twin = edge;\n\t\t\tedge.twin = this;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t// A vertex as a double linked list node.\n\n\tfunction VertexNode( point ) {\n\n\t\tthis.point = point;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.face = null; // the face that is able to see this vertex\n\n\t}\n\n\t// A double linked list that contains vertex nodes.\n\n\tfunction VertexList() {\n\n\t\tthis.head = null;\n\t\tthis.tail = null;\n\n\t}\n\n\tObject.assign( VertexList.prototype, {\n\n\t\tfirst: function () {\n\n\t\t\treturn this.head;\n\n\t\t},\n\n\t\tlast: function () {\n\n\t\t\treturn this.tail;\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.head = this.tail = null;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Inserts a vertex before the target vertex\n\n\t\tinsertBefore: function ( target, vertex ) {\n\n\t\t\tvertex.prev = target.prev;\n\t\t\tvertex.next = target;\n\n\t\t\tif ( vertex.prev === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.prev.next = vertex;\n\n\t\t\t}\n\n\t\t\ttarget.prev = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Inserts a vertex after the target vertex\n\n\t\tinsertAfter: function ( target, vertex ) {\n\n\t\t\tvertex.prev = target;\n\t\t\tvertex.next = target.next;\n\n\t\t\tif ( vertex.next === null ) {\n\n\t\t\t\tthis.tail = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.next.prev = vertex;\n\n\t\t\t}\n\n\t\t\ttarget.next = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Appends a vertex to the end of the linked list\n\n\t\tappend: function ( vertex ) {\n\n\t\t\tif ( this.head === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.tail.next = vertex;\n\n\t\t\t}\n\n\t\t\tvertex.prev = this.tail;\n\t\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\t\tthis.tail = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Appends a chain of vertices where 'vertex' is the head.\n\n\t\tappendChain: function ( vertex ) {\n\n\t\t\tif ( this.head === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.tail.next = vertex;\n\n\t\t\t}\n\n\t\t\tvertex.prev = this.tail;\n\n\t\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\t\twhile ( vertex.next !== null ) {\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t}\n\n\t\t\tthis.tail = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a vertex from the linked list\n\n\t\tremove: function ( vertex ) {\n\n\t\t\tif ( vertex.prev === null ) {\n\n\t\t\t\tthis.head = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.prev.next = vertex.next;\n\n\t\t\t}\n\n\t\t\tif ( vertex.next === null ) {\n\n\t\t\t\tthis.tail = vertex.prev;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\t\tremoveSubList: function ( a, b ) {\n\n\t\t\tif ( a.prev === null ) {\n\n\t\t\t\tthis.head = b.next;\n\n\t\t\t} else {\n\n\t\t\t\ta.prev.next = b.next;\n\n\t\t\t}\n\n\t\t\tif ( b.next === null ) {\n\n\t\t\t\tthis.tail = a.prev;\n\n\t\t\t} else {\n\n\t\t\t\tb.next.prev = a.prev;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\treturn this.head === null;\n\n\t\t}\n\n\t} );\n\n\treturn ConvexHull;\n\n} )();\n\nexport { ConvexHull };\n","import { Box, Quaternion as CQuaternion, ConvexPolyhedron, Cylinder, Shape, Sphere, Trimesh, Vec3 } from 'cannon-es';\nimport { Box3, BufferGeometry, Geometry, Matrix4, Mesh, Quaternion, Vector3, Math as _Math } from 'three';\nimport { ConvexHull } from './lib/ConvexHull.js';\n\nvar PI_2 = Math.PI / 2;\n\nvar Type = {\n  BOX: 'Box',\n  CYLINDER: 'Cylinder',\n  SPHERE: 'Sphere',\n  HULL: 'ConvexPolyhedron',\n  MESH: 'Trimesh'\n};\n\n/**\n * Given a THREE.Object3D instance, creates a corresponding CANNON shape.\n * @param  {THREE.Object3D} object\n * @return {CANNON.Shape}\n */\nexport const threeToCannon = function (object, options) {\n  options = options || {};\n\n  var geometry;\n\n  if (options.type === Type.BOX) {\n    return createBoundingBoxShape(object);\n  } else if (options.type === Type.CYLINDER) {\n    return createBoundingCylinderShape(object, options);\n  } else if (options.type === Type.SPHERE) {\n    return createBoundingSphereShape(object, options);\n  } else if (options.type === Type.HULL) {\n    return createConvexPolyhedron(object);\n  } else if (options.type === Type.MESH) {\n    geometry = getGeometry(object);\n    return geometry ? createTrimeshShape(geometry) : null;\n  } else if (options.type) {\n    throw new Error('[CANNON.threeToCannon] Invalid type \"%s\".', options.type);\n  }\n\n  geometry = getGeometry(object);\n  if (!geometry) return null;\n\n  var type = geometry.metadata\n    ? geometry.metadata.type\n    : geometry.type;\n\n  switch (type) {\n    case 'BoxGeometry':\n    case 'BoxBufferGeometry':\n      return createBoxShape(geometry);\n    case 'CylinderGeometry':\n    case 'CylinderBufferGeometry':\n      return createCylinderShape(geometry);\n    case 'PlaneGeometry':\n    case 'PlaneBufferGeometry':\n      return createPlaneShape(geometry);\n    case 'SphereGeometry':\n    case 'SphereBufferGeometry':\n      return createSphereShape(geometry);\n    case 'TubeGeometry':\n    case 'Geometry':\n    case 'BufferGeometry':\n      return createBoundingBoxShape(object);\n    default:\n      console.warn('Unrecognized geometry: \"%s\". Using bounding box as shape.', geometry.type);\n      return createBoxShape(geometry);\n  }\n};\n\nthreeToCannon.Type = Type;\n\n/******************************************************************************\n * Shape construction\n */\n\n /**\n  * @param  {THREE.Geometry} geometry\n  * @return {CANNON.Shape}\n  */\n function createBoxShape (geometry) {\n   var vertices = getVertices(geometry);\n\n   if (!vertices.length) return null;\n\n   geometry.computeBoundingBox();\n   var box = geometry.boundingBox;\n   return new Box(new Vec3(\n     (box.max.x - box.min.x) / 2,\n     (box.max.y - box.min.y) / 2,\n     (box.max.z - box.min.z) / 2\n   ));\n }\n\n/**\n * Bounding box needs to be computed with the entire mesh, not just geometry.\n * @param  {THREE.Object3D} mesh\n * @return {CANNON.Shape}\n */\nfunction createBoundingBoxShape (object) {\n  var clone = object.clone();\n  clone.quaternion.set(0, 0, 0, 1);\n  clone.updateMatrixWorld();\n\n  var box = new Box3().setFromObject(clone);\n\n  if (!isFinite(box.min.lengthSq())) return null;\n\n  var shape = new Box(new Vec3(\n    (box.max.x - box.min.x) / 2,\n    (box.max.y - box.min.y) / 2,\n    (box.max.z - box.min.z) / 2\n  ));\n\n  var localPosition = box.translate(clone.position.negate()).getCenter(new Vector3());\n  if (localPosition.lengthSq()) {\n    shape.offset = localPosition;\n  }\n\n  return shape;\n}\n\n/**\n * Computes 3D convex hull as a CANNON.ConvexPolyhedron.\n * @param  {THREE.Object3D} mesh\n * @return {CANNON.Shape}\n */\nfunction createConvexPolyhedron (object) {\n  var geometry = getGeometry(object);\n\n  if (!geometry || !geometry.vertices.length) return null;\n\n  // Perturb.\n  var eps = 1e-4;\n  for (var i = 0; i < geometry.vertices.length; i++) {\n    geometry.vertices[i].x += (Math.random() - 0.5) * eps;\n    geometry.vertices[i].y += (Math.random() - 0.5) * eps;\n    geometry.vertices[i].z += (Math.random() - 0.5) * eps;\n  }\n\n  // Compute the 3D convex hull.\n  var hull = new ConvexHull().setFromObject(new Mesh(geometry));\n  var faces = hull.faces;\n  var vertices = [];\n  var normals = [];\n\n  for ( var i = 0; i < faces.length; i ++ ) {\n    var face = faces[ i ];\n    var edge = face.edge;\n    do {\n      var point = edge.head().point;\n      vertices.push( new Vec3(point.x, point.y, point.z) );\n      normals.push( new Vec3(face.normal.x, face.normal.y, face.normal.z) );\n      edge = edge.next;\n    } while ( edge !== face.edge );\n  }\n\n  return new ConvexPolyhedron({vertices, normals});\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {CANNON.Shape}\n */\nfunction createCylinderShape (geometry) {\n  var params = geometry.metadata\n    ? geometry.metadata.parameters\n    : geometry.parameters;\n\n  var shape = new Cylinder(\n    params.radiusTop,\n    params.radiusBottom,\n    params.height,\n    params.radialSegments\n  );\n\n  // Include metadata for serialization.\n  shape._type = Shape.types.CYLINDER; // Patch schteppe/cannon.js#329.\n  shape.radiusTop = params.radiusTop;\n  shape.radiusBottom = params.radiusBottom;\n  shape.height = params.height;\n  shape.numSegments = params.radialSegments;\n\n  shape.orientation = new CQuaternion();\n  shape.orientation.setFromEuler(_Math.degToRad(-90), 0, 0, 'XYZ').normalize();\n  return shape;\n}\n\n/**\n * @param  {THREE.Object3D} object\n * @return {CANNON.Shape}\n */\nfunction createBoundingCylinderShape (object, options) {\n  var axes = ['x', 'y', 'z'];\n  var majorAxis = options.cylinderAxis || 'y';\n  var minorAxes = axes.splice(axes.indexOf(majorAxis), 1) && axes;\n  var box = new Box3().setFromObject(object);\n\n  if (!isFinite(box.min.lengthSq())) return null;\n\n  // Compute cylinder dimensions.\n  var height = box.max[majorAxis] - box.min[majorAxis];\n  var radius = 0.5 * Math.max(\n    box.max[minorAxes[0]] - box.min[minorAxes[0]],\n    box.max[minorAxes[1]] - box.min[minorAxes[1]]\n  );\n\n  // Create shape.\n  var shape = new Cylinder(radius, radius, height, 12);\n\n  // Include metadata for serialization.\n  shape._type = Shape.types.CYLINDER; // Patch schteppe/cannon.js#329.\n  shape.radiusTop = radius;\n  shape.radiusBottom = radius;\n  shape.height = height;\n  shape.numSegments = 12;\n\n  shape.orientation = new CQuaternion();\n  shape.orientation.setFromEuler(\n    majorAxis === 'y' ? PI_2 : 0,\n    majorAxis === 'z' ? PI_2 : 0,\n    0,\n    'XYZ'\n  ).normalize();\n  return shape;\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {CANNON.Shape}\n */\nfunction createPlaneShape (geometry) {\n  geometry.computeBoundingBox();\n  var box = geometry.boundingBox;\n  return new Box(new Vec3(\n    (box.max.x - box.min.x) / 2 || 0.1,\n    (box.max.y - box.min.y) / 2 || 0.1,\n    (box.max.z - box.min.z) / 2 || 0.1\n  ));\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {CANNON.Shape}\n */\nfunction createSphereShape (geometry) {\n  var params = geometry.metadata\n    ? geometry.metadata.parameters\n    : geometry.parameters;\n  return new Sphere(params.radius);\n}\n\n/**\n * @param  {THREE.Object3D} object\n * @return {CANNON.Shape}\n */\nfunction createBoundingSphereShape (object, options) {\n  if (options.sphereRadius) {\n    return new Sphere(options.sphereRadius);\n  }\n  var geometry = getGeometry(object);\n  if (!geometry) return null;\n  geometry.computeBoundingSphere();\n  return new Sphere(geometry.boundingSphere.radius);\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {CANNON.Shape}\n */\nfunction createTrimeshShape (geometry) {\n  var vertices = getVertices(geometry);\n\n  if (!vertices.length) return null;\n\n  var indices = Object.keys(vertices).map(Number);\n  return new Trimesh(vertices, indices);\n}\n\n/******************************************************************************\n * Utils\n */\n\n/**\n * Returns a single geometry for the given object. If the object is compound,\n * its geometries are automatically merged.\n * @param {THREE.Object3D} object\n * @return {THREE.Geometry}\n */\nfunction getGeometry (object) {\n  var mesh,\n      meshes = getMeshes(object),\n      tmp = new Geometry(),\n      combined = new Geometry();\n\n  if (meshes.length === 0) return null;\n\n  // Apply scale  â€“ it can't easily be applied to a CANNON.Shape later.\n  if (meshes.length === 1) {\n    var position = new Vector3(),\n        quaternion = new Quaternion(),\n        scale = new Vector3();\n    if (meshes[0].geometry.isBufferGeometry) {\n      if (meshes[0].geometry.attributes.position\n          && meshes[0].geometry.attributes.position.itemSize > 2) {\n        tmp.fromBufferGeometry(meshes[0].geometry);\n      }\n    } else {\n      tmp = meshes[0].geometry.clone();\n    }\n    tmp.metadata = meshes[0].geometry.metadata;\n    meshes[0].updateMatrixWorld();\n    meshes[0].matrixWorld.decompose(position, quaternion, scale);\n    return tmp.scale(scale.x, scale.y, scale.z);\n  }\n\n  // Recursively merge geometry, preserving local transforms.\n  while ((mesh = meshes.pop())) {\n    mesh.updateMatrixWorld();\n    if (mesh.geometry.isBufferGeometry) {\n      if (mesh.geometry.attributes.position\n          && mesh.geometry.attributes.position.itemSize > 2) {\n        var tmpGeom = new Geometry();\n        tmpGeom.fromBufferGeometry(mesh.geometry);\n        combined.merge(tmpGeom, mesh.matrixWorld);\n        tmpGeom.dispose();\n      }\n    } else {\n      combined.merge(mesh.geometry, mesh.matrixWorld);\n    }\n  }\n\n  var matrix = new Matrix4();\n  matrix.scale(object.scale);\n  combined.applyMatrix(matrix);\n  return combined;\n}\n\n/**\n * @param  {THREE.Geometry} geometry\n * @return {Array<number>}\n */\nfunction getVertices (geometry) {\n  if (!geometry.attributes) {\n    geometry = new BufferGeometry().fromGeometry(geometry);\n  }\n  return (geometry.attributes.position || {}).array || [];\n}\n\n/**\n * Returns a flat array of THREE.Mesh instances from the given object. If\n * nested transformations are found, they are applied to child meshes\n * as mesh.userData.matrix, so that each mesh has its position/rotation/scale\n * independently of all of its parents except the top-level object.\n * @param  {THREE.Object3D} object\n * @return {Array<THREE.Mesh>}\n */\nfunction getMeshes (object) {\n  var meshes = [];\n  object.traverse(function (o) {\n    if (o.type === 'Mesh') {\n      meshes.push(o);\n    }\n  });\n  return meshes;\n}\n"],"names":["ConvexHull","line3","plane","closestPoint","triangle","v1","Vector3","this","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Face","normal","midpoint","area","constant","outside","mark","edge","HalfEdge","vertex","face","prev","next","twin","VertexNode","point","head","tail","Object","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","push","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","undefined","isGeometry","clone","applyMatrix4","matrixWorld","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","containsPoint","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","append","insertBefore","removeVertexFromFace","remove","removeAllVerticesFromFace","start","end","removeSubList","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","distance","computeExtremes","j","minVertices","maxVertices","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","Line3","Plane","v0","v2","v3","extremes","index","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","twinEdge","oppositeFace","addAdjoiningFace","horizonEdge","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","a","b","c","e0","e1","e2","Triangle","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter","PI_2","PI","Type","BOX","CYLINDER","SPHERE","HULL","MESH","threeToCannon","options","type","createBoundingBoxShape","axes","majorAxis","cylinderAxis","minorAxes","splice","indexOf","box","Box3","isFinite","lengthSq","height","radius","shape","Cylinder","_type","Shape","types","radiusTop","radiusBottom","numSegments","orientation","CQuaternion","setFromEuler","normalize","createBoundingCylinderShape","sphereRadius","Sphere","getGeometry","computeBoundingSphere","boundingSphere","createBoundingSphereShape","random","Mesh","normals","Vec3","ConvexPolyhedron","createConvexPolyhedron","getVertices","indices","keys","map","Trimesh","createTrimeshShape","Error","metadata","createBoxShape","params","parameters","radialSegments","_Math","degToRad","createCylinderShape","computeBoundingBox","boundingBox","Box","createPlaneShape","createSphereShape","warn","quaternion","localPosition","translate","negate","getCenter","offset","mesh","meshes","o","getMeshes","tmp","Geometry","combined","Quaternion","scale","itemSize","fromBufferGeometry","decompose","pop","tmpGeom","merge","dispose","matrix","Matrix4","applyMatrix","BufferGeometry","fromGeometry","array"],"mappings":"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"}